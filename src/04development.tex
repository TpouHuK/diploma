\section{Разработка программного средства}

\subsection{Модуль жизненного цикла}
Программа спроектирована по принципу цикла событий, где мы обрабатываем получаемые сообщения от системы.

В цикле прописаны обработчики каждого сообщения.
Виды сообщений:
\begin{itemize}
	\item Сообщения от устройств периферии
	\item Сообщения от модуля навигации
\end{itemize}

Каждый обработчик спроектирован таким образом чтобы тот не имел в себе никаких трудоёмких вычислений.

\subsection{SLAM}
Задача построения карты заключается в добавлении новых данных поступаемых с датчиков на уже построенную карту.
В качестве входных данных у нас данные с лидара с позицией в которых они были произведены, а так-же карта на которую происходит наложение скана.

В качестве алгоритма наложения был выбран алгоритм ICP (Iterative closest point), который был разработан с использованием наработок в KISS ICP.
Алгоритм заключается в итеративном приближении наложения скана к карте.

\subsection{Модуль оценки позиции}

\subsection{Модуль управлением жизненного цикла}





\subsection{Разработка UKF}
Фильтр описывается структурой:
\begin{lstlisting}
pub struct KallmanFilter<const N: usize, const K: usize, const S: usize> {
    pub state: SMatrix<f32, 1, N>,
    prior_state: Option<SMatrix<f32, 1, N>>,
    pub state_sigmas: Option<SMatrix<f32, S, N>>,
    pub state_noise: SMatrix<f32, N, N>,
    pub meas_sigmas: SMatrix<f32, S, K>,
    pub meas_noise: SMatrix<f32, K, K>,
    pub meas_covariance: Option<DMatrix<f32>>,
    pub inv_meas_covariance: Option<DMatrix<f32>>,
    pub covariance: SMatrix<f32, N, N>,
    prior_covariance: Option<SMatrix<f32, N, N>>,
    pub gain: Option<OMatrix<f32, Const<N>, Dyn>>,
    pub weights: SigmaWeights<S>,
}
\end{lstlisting}


Конструктор:
\begin{lstlisting}
pub fn new() -> Self {
     assert_eq!(sigma_order(N), S);

     let weights =
        sigma_points::estimate_merwe_weights::<N, S>(
            sigma_points::SigmaMetadata {
                alpha: 0.1,
                beta: 2.0,
                kappa: (N as f32 - 3.0),
            },
     );
     Self::with_weights(weights)
}

\end{lstlisting}

Расчёт весов сигма-точек выполняется в момент инициализации фильтра Калмана
следующим образом:
\begin{lstlisting}
pub fn estimate_merwe_weights<const N: usize, const S: usize>(
    metadata: SigmaMetadata,
) -> SigmaWeights<S> {
    assert!(S == sigma_order(N));
    let SigmaMetadata { alpha, beta, kappa } = metadata;
    let n = N as f32;
    let lambda = (alpha * alpha) * (n + kappa) - n;
    let c = 0.5 / (n + lambda);
    let mut w_m = vec![c; S];
    let mut w_c = vec![c; S];
    w_c[0] = lambda / (n + lambda) + (1.0 - alpha * alpha + beta);
    w_m[0] = lambda / (n + lambda);
    SigmaWeights {
        covariance: SVector::<f32, S>::from_vec(w_c).transpose(),
        mean: SVector::<f32, S>::from_vec(w_m).transpose(),
        sigma_order: S,
        metadata,
    }
}

\end{lstlisting}

Оценка значений сигма-точек выполняется по алгоритму:
\begin{lstlisting}
pub trait FnDistance<const N: usize>:
    Fn(SMatrixView<f32, 1, N>, SMatrixView<f32, 1, N>) -> SMatrix<f32, 1, N>
{/
}

pub fn estimate_merwe_sigmas<const S: usize, const N: usize, D>(
    state: SMatrixView<f32, 1, N>,
    covariance: SMatrixView<f32, N, N>,
    metadata: SigmaMetadata,
    distance_of: &D,
) -> Result<SMatrix<f32, S, N>, MathError>
where
    D: FnDistance<N>,
{
    let SigmaMetadata { alpha, kappa, .. } = metadata;
    let mean_estimations = {
        let state_size = N as f32;
        let lambda = alpha.powi(2) * (state_size + kappa) - state_size;
        let matrix = covariance.scale(lambda + state_size);
        let matrix = matrix.symmetric_part() + SMatrix::identity() * 0.0001;
        let Some(cholesky) = Cholesky::new(matrix) else {
            let dmatrix = DMatrix::from_iterator(
                matrix.nrows(),
                matrix.ncols(),
                matrix.iter().copied(),
            );
            return Err(MathError::CholeskyFailed(dmatrix));
        };
        cholesky.l()
    };
    let mut sigmas = SMatrix::<f32, S, N>::zeros();
    sigmas.row_mut(0).copy_from(&state);
    for i in 0..state.len() {
        let mean_estimation = mean_estimations.column(i).transpose();
        sigmas
            .row_mut(i + 1)
            .copy_from(&distance_of(state, (-1.0 * mean_estimation).as_view()));
        sigmas
            .row_mut(N + i + 1)
            .copy_from(&distance_of(state, (1.0 * mean_estimation).as_view()));
    }
    Ok(sigmas)
}

\end{lstlisting}
Для извелечения квадратного корня из матрицы ковариации $\mathbf{P}$
используется декомпозиция Холеского. Операция декомпозиции 
определена только над положительно-определёнными матрицами. По определению,
матрица ковариации всегда положительно определена (элементами матрицы являются ковариации
между переменными). Но в процессе работы фильтра возможна ситуация,
что матрица $\mathbf{P}$ оказывается отрицательно-определённой.
Подобная ситуация возникает из-за:
\begin{itemize}
    \item накопления аппаратной вычислительной ошибки;
    \item особенностей способа обновления значений ковариаций в матриц;
    \item высокой сложности модели системы (более трёх переменных в векторе $\mathbf{X}$).
\end{itemize}

В случае, если невозможно произвести декомпозицию Холецкому,
предлагается сброс фильтра (см. подраздел \ref{subsec:motion_estimation}).

Ключевым этапом в работе UKF является реализация алгоритма преобразования  

\begin{lstlisting}
pub fn transform<T, F, const N: usize, const S: usize>(
    sigmas: &SMatrix<f32, S, N>,
    weights: &SigmaWeights<S>,
    noise_opt: Option<SMatrixView<f32, N, N>>,
    residual: &T,
    mean: &F,
) -> (SMatrix<f32, 1, N>, SMatrix<f32, N, N>)
where
    T: FnDistance<N>,
    F: FnMean<N, S>,
{
    let state = mean(weights.mean.as_view(), sigmas.as_view());

    let mut covariance = SMatrix::<f32, N, N>::zeros();

    for i in 0..S {
        let row = sigmas.row(i).clone_owned();

        let y = residual(row.as_view(), state.as_view());

        let mut outer = y.transpose() * y;
        outer.scale_mut(weights.covariance[i]);
        covariance += outer;
    }

    if let Some(noise) = noise_opt {
        //assert noise is diagonal matrix
        covariance += noise;
    }

    (state, covariance)
}
\end{lstlisting}





\subsection{Разработка модуля оценки состояния}
\label{subsec:motion_estimation}

\begin{lstlisting}
pub type FilterState = ukf::FilterState<
    ACCEL_MODEL_STATE_SIZE,
    MEASUREMENT_SIZE,
    ACCELERATION_MODEL_SIGMA_ORDER
>;

pub type KallmanFilter = ukf::KallmanFilter<
    ACCEL_MODEL_STATE_SIZE,
    MEASUREMENT_SIZE,
    ACCELERATION_MODEL_SIGMA_ORDER,
>;

pub struct MotionEstimation {
    pub config: MotionEstimationConfig,
    pub states: Vec<FilterState>,
    pub events: Vec<SensorEvent>,
    pub last_control_input: Option<ControlInput>,
    pub ukf_filter: KallmanFilter,
    pub imu_filter: Option<ImuFilter>,
}
\end{lstlisting}

\begin{lstlisting}
fn apply_event(
    &mut self,
    event: SensorEvent,
    observation_time: SystemTime,
) -> Result<(), LocalizationError> {
    let dt_secs = event
        .arrival_time()
        .duration_since(observation_time)
        .inspect_err(|_cause| {
            log::error!(
                "Reversed time for event={:?} with obs_time={:?}",
                event,
                observation_time
            );
        })
        .expect("Time goes in reverse order")
        .as_secs_f32()
        .max(0.001);

    let mut indices = Vec::<usize>::new();
    let mut meas_matrix = SVector::<f32, MEASUREMENT_SIZE>::zeros();

    match event {
        SensorEvent::MatchedPose(data) => {
            meas_matrix[SCAN_X] = data.coords.x;
            meas_matrix[SCAN_Y] = data.coords.y;
            meas_matrix[SCAN_THETA] = data.heading_rad;

            indices.push(SCAN_X);
            indices.push(SCAN_Y);
            indices.push(SCAN_THETA);

            self.imu_filter = None;
        }

	SensorEvent::Imu(data) => {
            let mut filter: ImuFilter =
                self.imu_filter.take().unwrap_or_else(|| {
                    ImuFilter::new(
                        self.config.epoch_duration_ms as f32 / 1000.0,
                        &self.get_estimated_state_unchecked(),
                        &self.config.noise,
                    )
                })
            filter.predict(dt_secs)?;
            filter.update(
                    dt_secs,
                    self.config.params.imu_filter,
                    &self.config.noise,
		    data
            )?;
	    return Ok(());
        }

        SensorEvent::GpsCoords(data) => {
            meas_matrix[GPS_X] = data.coords.x;
            meas_matrix[GPS_Y] = data.coords.y;

            indices.push(GPS_X);
            indices.push(GPS_Y);
        }
    }

    let transform = build_dyn_transform(&indices);

    let _ = self.predict(dt_secs)?;

    self.ukf_filter.update(
        &meas_matrix.transpose(),
        Some(transform),
        UpdateConfig {
            state_to_meas,
            mean_transform: meas_mean,
            meas_sub: meas_residual,
            state_sub: state_residual,
        },
    )?;

    Ok(())
}

\end{lstlisting}


Функции для преобразования сигма-точек
\begin{lstlisting}
fn meas_residual(
    m1: SMatrixView<f32, 1, MEASUREMENT_SIZE>,
    m2: SMatrixView<f32, 1, MEASUREMENT_SIZE>,
) -> SMatrix<f32, 1, MEASUREMENT_SIZE> {
    let mut m = m1 - m2;
    m[SCAN_THETA] = normalize_angle(m[SCAN_THETA]);
    m[IMU_THETA] = normalize_angle(m[IMU_THETA]);
    m
}

fn meas_mean(
    weights: SMatrixView<f32, 1, ACCELERATION_MODEL_SIGMA_ORDER>,
    sigmas: SMatrixView<f32, ACCELERATION_MODEL_SIGMA_ORDER, MEASUREMENT_SIZE>,
) -> SMatrix<f32, 1, MEASUREMENT_SIZE> {
    let column = sigmas.column(SCAN_THETA).transpose();

    let sum_sin = weights.dot(&column.map(f32::sin));
    let sum_cos = weights.dot(&column.map(f32::cos));

    let lidar_theta = f32::atan2(sum_sin, sum_cos);

    let column = sigmas.column(IMU_THETA).transpose();

    let sum_sin = weights.dot(&column.map(f32::sin));
    let sum_cos = weights.dot(&column.map(f32::cos));

    let imu_theta = f32::atan2(sum_sin, sum_cos);

    let x = weights.dot(&sigmas.column(SCAN_X).transpose());
    let y = weights.dot(&sigmas.column(SCAN_Y).transpose());

    let gps_x = weights.dot(&sigmas.column(GPS_X).transpose());
    let gps_y = weights.dot(&sigmas.column(GPS_Y).transpose());

    SMatrix::from_row_slice(&[
        x,
        y,
        lidar_theta,
        imu_theta,
        imu_v_theta,
        imu_a_x,
        imu_a_y,
        gps_x,
        gps_y,
        compass_theta,
    ])
}
\end{lstlisting}


\subsection{Глобальный планировщик}



\subsection{Локальный планировщик}

