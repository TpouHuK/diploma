\section{Разработка программного средства}

\subsection{Модуль жизненного цикла}
Программа спроектирована по принципу цикла событий, где мы обрабатываем получаемые сообщения от системы.

В цикле прописаны обработчики каждого сообщения.
Виды сообщений:
\begin{itemize}
	\item сообщения от устройств периферии;
	\item сообщения от модуля навигации.
\end{itemize}

Каждый обработчик предполагает чтобы в нём не было трудоёмких вычислений, что позволяет циклу событий непрерывно выполнятся вне зависимости от того какие входные данные были получены.

Схема обработки выглядит вот так: % TODO

\subsection{SLAM}
Задача построения карты заключается в добавлении новых данных поступающих с датчиков на уже построенную карту.
В качестве входных данных у нас данные с лидара с позицией в которых они были произведены, а так-же карта на которую происходит наложение скана.

В качестве алгоритма наложения был выбран алгоритм ICP (Iterative closest point), который был разработан с использованием наработок в KISS ICP.
Алгоритм заключается в итеративном приближении наложения скана к карте.

% \subsection{Модуль оценки позиции}
%
% \subsection{Модуль управлением жизненного цикла}

\subsection{Разработка UKF}
Фильтр описывается структурой:
\begin{lstlisting}
pub struct KallmanFilter<const N: usize, const K: usize, const S: usize> {
    pub state: SMatrix<f32, 1, N>,
    prior_state: Option<SMatrix<f32, 1, N>>,
    pub state_sigmas: Option<SMatrix<f32, S, N>>,
    pub state_noise: SMatrix<f32, N, N>,
    pub meas_sigmas: SMatrix<f32, S, K>,
    pub meas_noise: SMatrix<f32, K, K>,
    pub meas_covariance: Option<DMatrix<f32>>,
    pub inv_meas_covariance: Option<DMatrix<f32>>,
    pub covariance: SMatrix<f32, N, N>,
    prior_covariance: Option<SMatrix<f32, N, N>>,
    pub gain: Option<OMatrix<f32, Const<N>, Dyn>>,
    pub weights: SigmaWeights<S>,
}
\end{lstlisting}


Конструктор:
\begin{lstlisting}
pub fn new() -> Self {
     assert_eq!(sigma_order(N), S);

     let weights =
        sigma_points::estimate_merwe_weights::<N, S>(
            sigma_points::SigmaMetadata {
                alpha: 0.1,
                beta: 2.0,
                kappa: (N as f32 - 3.0),
            },
     );
     Self::with_weights(weights)
}

\end{lstlisting}

Расчёт весов сигма-точек выполняется в момент инициализации фильтра Калмана
следующим образом:
\begin{lstlisting}
pub fn estimate_merwe_weights<const N: usize, const S: usize>(
    metadata: SigmaMetadata,
) -> SigmaWeights<S> {
    assert!(S == sigma_order(N));
    let SigmaMetadata { alpha, beta, kappa } = metadata;
    let n = N as f32;
    let lambda = (alpha * alpha) * (n + kappa) - n;
    let c = 0.5 / (n + lambda);
    let mut w_m = vec![c; S];
    let mut w_c = vec![c; S];
    w_c[0] = lambda / (n + lambda) + (1.0 - alpha * alpha + beta);
    w_m[0] = lambda / (n + lambda);
    SigmaWeights {
        covariance: SVector::<f32, S>::from_vec(w_c).transpose(),
        mean: SVector::<f32, S>::from_vec(w_m).transpose(),
        sigma_order: S,
        metadata,
    }
}

\end{lstlisting}

Оценка значений сигма-точек выполняется по алгоритму:
\begin{lstlisting}
pub trait FnDistance<const N: usize>:
    Fn(SMatrixView<f32, 1, N>, SMatrixView<f32, 1, N>) -> SMatrix<f32, 1, N>
{/
}

pub fn estimate_merwe_sigmas<const S: usize, const N: usize, D>(
    state: SMatrixView<f32, 1, N>,
    covariance: SMatrixView<f32, N, N>,
    metadata: SigmaMetadata,
    distance_of: &D,
) -> Result<SMatrix<f32, S, N>, MathError>
where
    D: FnDistance<N>,
{
    let SigmaMetadata { alpha, kappa, .. } = metadata;
    let mean_estimations = {
        let state_size = N as f32;
        let lambda = alpha.powi(2) * (state_size + kappa) - state_size;
        let matrix = covariance.scale(lambda + state_size);
        let matrix = matrix.symmetric_part() + SMatrix::identity() * 0.0001;
        let Some(cholesky) = Cholesky::new(matrix) else {
            let dmatrix = DMatrix::from_iterator(
                matrix.nrows(),
                matrix.ncols(),
                matrix.iter().copied(),
            );
            return Err(MathError::CholeskyFailed(dmatrix));
        };
        cholesky.l()
    };
    let mut sigmas = SMatrix::<f32, S, N>::zeros();
    sigmas.row_mut(0).copy_from(&state);
    for i in 0..state.len() {
        let mean_estimation = mean_estimations.column(i).transpose();
        sigmas
            .row_mut(i + 1)
            .copy_from(&distance_of(state, (-1.0 * mean_estimation).as_view()));
        sigmas
            .row_mut(N + i + 1)
            .copy_from(&distance_of(state, (1.0 * mean_estimation).as_view()));
    }
    Ok(sigmas)
}

\end{lstlisting}
Для извлечения квадратного корня из матрицы ковариации $\mathbf{P}$
используется декомпозиция Холецкого. Операция декомпозиции 
определена только над положительно-определёнными матрицами. По определению,
матрица ковариации всегда положительно определена (элементами матрицы являются ковариации
между переменными). Но в процессе работы фильтра возможна ситуация,
что матрица $\mathbf{P}$ оказывается отрицательно-определённой.
Подобная ситуация возникает из-за:
\begin{itemize}
    \item накопления аппаратной вычислительной ошибки;
    \item особенностей способа обновления значений ковариаций в матриц;
    \item высокой сложности модели системы (более трёх переменных в векторе $\mathbf{X}$).
\end{itemize}

В случае, если невозможно произвести декомпозицию по Холецкому,
предлагается сброс фильтра (см. подраздел \ref{subsec:motion_estimation}).

Ключевым этапом в работе UKF является реализация алгоритма преобразования  

\begin{lstlisting}
pub fn transform<T, F, const N: usize, const S: usize>(
    sigmas: &SMatrix<f32, S, N>,
    weights: &SigmaWeights<S>,
    noise_opt: Option<SMatrixView<f32, N, N>>,
    residual: &T,
    mean: &F,
) -> (SMatrix<f32, 1, N>, SMatrix<f32, N, N>)
where
    T: FnDistance<N>,
    F: FnMean<N, S>,
{
    let state = mean(weights.mean.as_view(), sigmas.as_view());

    let mut covariance = SMatrix::<f32, N, N>::zeros();

    for i in 0..S {
        let row = sigmas.row(i).clone_owned();

        let y = residual(row.as_view(), state.as_view());

        let mut outer = y.transpose() * y;
        outer.scale_mut(weights.covariance[i]);
        covariance += outer;
    }

    if let Some(noise) = noise_opt {
        //assert noise is diagonal matrix
        covariance += noise;
    }

    (state, covariance)
}
\end{lstlisting}

\subsection{Разработка модуля оценки состояния}
\label{subsec:motion_estimation}

\begin{lstlisting}
pub type FilterState = ukf::FilterState<
    ACCEL_MODEL_STATE_SIZE,
    MEASUREMENT_SIZE,
    ACCELERATION_MODEL_SIGMA_ORDER
>;

pub type KallmanFilter = ukf::KallmanFilter<
    ACCEL_MODEL_STATE_SIZE,
    MEASUREMENT_SIZE,
    ACCELERATION_MODEL_SIGMA_ORDER,
>;

pub struct MotionEstimation {
    pub config: MotionEstimationConfig,
    pub states: Vec<FilterState>,
    pub events: Vec<SensorEvent>,
    pub last_control_input: Option<ControlInput>,
    pub ukf_filter: KallmanFilter,
    pub imu_filter: Option<ImuFilter>,
}
\end{lstlisting}

\begin{lstlisting}
fn apply_event(
    &mut self,
    event: SensorEvent,
    observation_time: SystemTime,
) -> Result<(), LocalizationError> {
    let dt_secs = event
        .arrival_time()
        .duration_since(observation_time)
        .expect("Time goes in reverse order")
        .as_secs_f32()
        .max(0.001);

    let mut indices = Vec::<usize>::new();
    let mut meas_matrix = SVector::<f32, MEASUREMENT_SIZE>::zeros();

    match event {
        SensorEvent::MatchedPose(data) => {
            meas_matrix[SCAN_X] = data.coords.x;
            meas_matrix[SCAN_Y] = data.coords.y;
            meas_matrix[SCAN_THETA] = data.heading_rad;

            indices.push(SCAN_X);
            indices.push(SCAN_Y);
            indices.push(SCAN_THETA);

            self.imu_filter = None;
        }

	SensorEvent::Imu(data) => {
            let mut filter: ImuFilter =
                self.imu_filter.take().unwrap_or_else(|| {
                    ImuFilter::new(
                        self.config.epoch_duration_ms as f32 / 1000.0,
                        &self.get_estimated_state_unchecked(),
                        &self.config.noise,
                    )
                })
            filter.predict(dt_secs)?;
            filter.update(
                    dt_secs,
                    self.config.params.imu_filter,
                    &self.config.noise,
		    data
            )?;
	    return Ok(());
        }

        SensorEvent::GpsCoords(data) => {
            meas_matrix[GPS_X] = data.coords.x;
            meas_matrix[GPS_Y] = data.coords.y;

            indices.push(GPS_X);
            indices.push(GPS_Y);
        }
    }

    let transform = build_dyn_transform(&indices);

    let _ = self.predict(dt_secs)?;

    self.ukf_filter.update(
        &meas_matrix.transpose(),
        Some(transform),
        UpdateConfig {
            state_to_meas,
            mean_transform: meas_mean,
            meas_sub: meas_residual,
            state_sub: state_residual,
        },
    )?;

    Ok(())
}

\end{lstlisting}


Функции для преобразования сигма-точек
\begin{lstlisting}
fn meas_residual(
    m1: SMatrixView<f32, 1, MEASUREMENT_SIZE>,
    m2: SMatrixView<f32, 1, MEASUREMENT_SIZE>,
) -> SMatrix<f32, 1, MEASUREMENT_SIZE> {
    let mut m = m1 - m2;
    m[SCAN_THETA] = normalize_angle(m[SCAN_THETA]);
    m[IMU_THETA] = normalize_angle(m[IMU_THETA]);
    m
}

fn meas_mean(
    weights: SMatrixView<f32, 1, ACCELERATION_MODEL_SIGMA_ORDER>,
    sigmas: SMatrixView<f32, ACCELERATION_MODEL_SIGMA_ORDER, MEASUREMENT_SIZE>,
) -> SMatrix<f32, 1, MEASUREMENT_SIZE> {
    let column = sigmas.column(SCAN_THETA).transpose();

    let sum_sin = weights.dot(&column.map(f32::sin));
    let sum_cos = weights.dot(&column.map(f32::cos));

    let lidar_theta = f32::atan2(sum_sin, sum_cos);

    let column = sigmas.column(IMU_THETA).transpose();

    let sum_sin = weights.dot(&column.map(f32::sin));
    let sum_cos = weights.dot(&column.map(f32::cos));

    let imu_theta = f32::atan2(sum_sin, sum_cos);

    let x = weights.dot(&sigmas.column(SCAN_X).transpose());
    let y = weights.dot(&sigmas.column(SCAN_Y).transpose());

    let gps_x = weights.dot(&sigmas.column(GPS_X).transpose());
    let gps_y = weights.dot(&sigmas.column(GPS_Y).transpose());

    SMatrix::from_row_slice(&[
        x,
        y,
        lidar_theta,
        imu_theta,
        imu_v_theta,
        imu_a_x,
        imu_a_y,
        gps_x,
        gps_y,
        compass_theta,
    ])
}
\end{lstlisting}


% \subsection{Глобальный планировщик} % TODO




\subsection{Локальный планировщик}

Формирование минимальной скорости основывается
на тенденции к застреванию:
\begin{lstlisting}
let mut estimate_min_velocity = || -> Result<f32, LocalPlanError> {
    if rotation.abs() > config.stuck.rotation_tolerance
        || dist > *config.stuck.distance_tolerance
    {
        world.tracker.reset_stuck();
        return Ok(default_min_velocity);
    }
    let stuck_duration = world.tracker.detect_stuck();
    if stuck_duration < config.stuck.stuck_time_tolerance {
        return Ok(default_min_velocity);
    }
    if stuck_duration > config.stuck.max_stuck_time {
        return Err(LocalPlanError::StuckDetected);
    }

    let elapsed = stuck_duration;
    let max_elapsed = config.stuck.max_stuck_time;
    let v = config.robot.min_velocity
        + (config.robot.max_velocity - config.robot.min_velocity)
            * elapsed.as_secs_f32()
            / max_elapsed.as_secs_f32();

    if stuck_duration > config.stuck.stuck_time_force_backward {
        force_back_movement = true;
        Ok(v)
    } else {
        Ok(config.robot.max_velocity)
    }
};

\end{lstlisting}

Оценка максимальной скорости происходит по:
\begin{lstlisting}
let estimate_max_velocity = |state: &RobotState| -> f32 {
    let dist_to_goal =
        (world.target_pose.coords - state.position.coords).norm();
    let stop_time = dist_to_goal / config.robot.max_velocity;
    if stop_time <= limits.deceleration_time.as_secs_f32() {
        //slow deceleration
        let y = limits.deceleration_time.as_secs_f32();
        let base_pow = -y.log10() / y;
        let pow =
            base_pow * (limits.deceleration_time.as_secs_f32() - stop_time);
        let output = f32::exp(pow) * config.robot.max_velocity;
        output.clamp(config.robot.min_velocity, config.robot.max_velocity)
    } else if motion_time < limits.acceleration_time {
        //slow acceleration
        let x = motion_time.as_secs_f32();
        let a = x / limits.acceleration_time.as_secs_f32();
        f32::max(v_min, a.powi(3) * config.robot.max_velocity)
    } else {
        config.robot.max_velocity
    }
};
\end{lstlisting}

Оценка максимальной угловой скорости происходит (c задаваемой табличной функции $\omega_{max} = F(v)$):
\begin{lstlisting}
impl MovementOptimization {
    pub fn estimate_angular(&self, velocity: f32) -> f32 {
        let model = self.model.as_ref().unwrap();

        model
            .predict(&DenseMatrix::from_2d_vec(&vec![vec![velocity]]).unwrap())
            .unwrap()[0]
    }
}

let estimate_max_angular = move |state: &RobotState| -> f32 {
    let v_local = state.velocity.into_local(state.position.heading_rad);
    optimization
        .estimate_angular(v_local.translation.x)
        .clamp(0.0, max_angular)
};
\end{lstlisting}

\begin{lstlisting}
pub fn generate_range(v_min: f32, v_max: f32, step: f32) -> Vec<f32> {
    if v_max <= v_min {
        return vec![v_min];
    }
    let count = ((v_max - v_min) / step) as usize;
    if count <= 1 {
        return vec![v_min];
    }
    let count = count.max(2);
    (0..count).map(|i| v_min + i as f32 * step).collect()
}
\end{lstlisting}

Метрика выравнивания по целевому углу: 
\begin{lstlisting}

pub fn target_alignment(&self, target_heading: f32) -> TrajectoryMetric {
    Box::new(move |trajectory| {
        let rotation = normalize_angle(
            trajectory.finish_state().position.heading_rad - target_heading,
        );
        let cost = rotation.abs() / f32::consts::FRAC_PI_2;
        Ok((MetricKind::TargetAlignment, MetricCost::new(cost)))
    })
}
\end{lstlisting}

Метрика кратчайшего пути
\begin{lstlisting}
pub fn shortest_path_metric(&self, goal: Point2<f32>) -> TrajectoryMetric {
    Box::new(move |trajectory| {
        let dist2 = (goal - trajectory.finish_state().position.coords)
            .norm_squared();

        Ok((MetricKind::ShortestPath, MetricCost::new(dist2)))
    })
}
\end{lstlisting}


Метрика коллизии:
\begin{lstlisting}
pub fn collision_metrics(
    &self,
    obstacles: &'a DynamicObstacles,
    map_chunk: &'a MapChunk,
) -> TrajectoryMetric {
    let robot = self.robot;
    let config = self.planner_config;
    Box::new(move |trajectory| {
        for state in trajectory.states.iter() {
            let state_shape = robot.build_shape(
                map_chunk.resolution,
                config.collision_distance,
                &(*state).into(),
            );
            if has_dynamic_collision(&state_shape, obstacles)
                || has_static_collision(&state_shape, map_chunk)
            {
                //collisions are not acceptable
                return Err(MetricError::Unreacheable);
            }
        }
        Ok((MetricKind::Collision, MetricCost::ZERO))
    })
}
\end{lstlisting}

Для расчёта метрики удалённости от коллизий в позиции можно заранее просчитать
расстояние до ближайшего препятствия в каждой точке, что превратит
вычислительную задачу в поисковую.



Метрика удалённости от коллизий:
\begin{lstlisting}
fn collision_map_metric(
    &'a self,
    map: &'a DistanceGrid,
    maybe_obstacles: Option<&'a DynamicObstacles>,
) -> TrajectoryMetric<'a> {
    Box::new(move |trajectory| {
        let state = trajectory.finish_state();
        let mut min_dist = f32::MAX;
        let coords = state.position.coords;
        let dist_cost = map.index_distance(&coords);
        if dist_cost.is_reacheable() {
            let dist = map.resolution.to_metres(dist_cost.as_f32());
            min_dist = f32::min(min_dist, dist);
        }
        if let Some(obstacles) = maybe_obstacles {
            let obstacle = obstacles.closest(&coords);
            let dist_to_dynamic_obstacle = (obstacle - coords).norm();
            min_dist = f32::min(min_dist, dist_to_dynamic_obstacle);
        }
        Ok((
            MetricKind::CollisionDistance,
            MetricCost::new(1.0 / min_dist),
        ))
    })
}
\end{lstlisting}

Метрика близости траектории к глобальному маршруту:
\begin{lstlisting}
fn distance_map_metric(
    &'a self,
    distance_grid: &'a DistanceGrid,
) -> TrajectoryMetric<'a> {
    Box::new(move |trajectory| {
        let states = &trajectory.states;
        let mut distance_cost = 0.0;
        for state in states.iter() {
            let world_point = state.position.coords;
            let distance = distance_grid.index_distance(&world_point);
            if distance.is_unreacheable() {
                return Err(MetricError::Unreacheable);
            }
            distance_cost += distance.as_f32();
        }
        Ok((MetricsKind::GlobalPath, MetricCost::new(distance_cost)))
    })
}
\end{lstlisting}
