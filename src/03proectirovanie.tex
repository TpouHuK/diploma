\section{Проектирование программного средства}
\subsection{Датчики}
В качестве поддерживаемых датчиков было выбрано три ключевых:
\begin{itemize}
	\item 2D Lidar;
	\item IMU;
	\item GPS.
\end{itemize}

Эти датчики обеспечивают систему данными о пространстве, в котором находится
робот, его ориентации и глобальном местоположении.
2D Lidar позволяет получать информацию о препятствиях вокруг устройства, IMU
предоставляет данные о наклоне и угловых ускорениях, а GPS — о глобальной
позиции робота. Все эти данные интегрируются в систему навигации, создавая
основу для безопасного и эффективного перемещения устройства в различных
условиях.

2D Lidar (Light Detection and Ranging) работает на основе принципа измерения
расстояния до объектов с использованием лазерных импульсов. Ли дар излучает
лазерные импульсы, которые отражаются от объектов, встречающих их на пути.
Время, которое требуется импульсу для прохождения от лидара до объекта и
обратно, используется для вычисления расстояния до объекта. Этот процесс
повторяется многократно по всей области сканирования, создавая карту расстояний
на основе измерений.

\begin{figure}[h]
\centering
	\fbox{\includegraphics[width=9cm]{2d_lidar}}
\caption{2D Lidar}
\end{figure}

2D лидары обычно работают в плоскости, что означает, что они измеряют расстояния
только в одном направлении (по горизонтали или вертикали). Сканер вращается или
перемещается по оси, чтобы покрыть широкую область, создавая двумерное
изображение окружающего пространства. С помощью таких данных система может
строить карту и распознавать объекты, определяя их положение и расстояние до
них, что крайне важно для навигации роботов и беспилотных автомобилей.

IMU (Inertial Measurement Unit) — это датчик, который измеряет и сообщает
информацию о движении и ориентации объекта в пространстве. Он состоит из трех
основных компонентов: акселерометров, гироскопов и иногда магнитометров.
Акселерометры измеряют ускорения по трем осям (X, Y, Z), что позволяет
определить изменение скорости и положение объекта относительно земной
гравитации. Гироскопы отслеживают угловые скорости вращения вокруг тех же осей,
что помогает измерять ориентацию объекта и его вращения. Магнитометры, если они
присутствуют, измеряют магнитное поле Земли, что позволяет дополнительно
корректировать ориентацию.

Принцип работы IMU заключается в интеграции данных с этих сенсоров, чтобы
получить полное представление о движении и положении объекта. Например,
акселерометры могут обнаружить, если устройство наклоняется или ускоряется, а
гироскопы отслеживают угловые изменения, такие как вращение вокруг своей оси.
Это позволяет системе вычислить изменения ориентации и траекторию движения, что
полезно в таких приложениях, как робототехника, авиация и навигация в условиях
отсутствия GPS.

GPS — это навигационная система, основанная на использовании спутников для
определения местоположения объектов на Земле. Система состоит из спутников,
находящихся на орбите, наземных станций и приемников, которые используются для
получения данных о местоположении. Спутники передают сигналы с точным временем,
и приемник на Земле, получая эти сигналы от нескольких спутников, может
вычислить свое местоположение.

Принцип работы GPS заключается в измерении времени, которое требуется сигналу,
чтобы добраться от спутника до приемника. Поскольку спутники известны своей
точной орбитой, приемник может определить расстояние до каждого спутника,
используя это время. Получая сигналы от как минимум четырех спутников, приемник
может точно вычислить свою абсолютную позицию в трехмерном пространстве —
определяя широту, долготу и высоту, а также время. Эти данные обеспечивают
высокую точность определения местоположения, что критически важно для навигации
и локализации в реальном времени.


\subsection{Проектирование архитектуры}	

После того, как были сформулированы функциональные требования к разрабатываемой
системе,  а  также  исходя  из  результатов  анализа  существующих
программных решений, можно определить основные моменты организации системы,  в
которой  будет  функционировать  разрабатываемое  программное  решение.

Процесс проектирования архитектуры программного обеспечения включает в себя сбор
требований, их анализ и создание проекта для компонента программного
обеспечения в соответствие с требованиями. Успешная разработка ПО должна
обеспечивать баланс неизбежных компромиссов вследствие противоречащих
требований;  соответствовать  принципам  проектирования  и  рекомендованным
методам,  выработанным  со  временем;  и  дополнять  современное оборудование,
сети и системы управления. 

Архитектуру  программного  обеспечения  можно рассматривать  как  сопоставление
между целью компонента ПО и сведениями о реализации в коде. Правильное понимание
архитектуры  обеспечит  оптимальный баланс требований и результатов. Только
программное обеспечение с хорошо продуманной архитектурой способно выполнять
указанные задачи с параметрами исходных требований, одновременно обеспечивая
максимально высокую производительность. Программное средство построено на основе
модульной архитектуры. 

\FloatBarrier
\begin{figure}[H]
\label{fig:components}
\centering
	\fbox{\includegraphics[width=15cm]{MODULES.drawio}}
\caption{Диаграмма компонентов проектируемого ПО}
\end{figure}

На рисунке \ref{fig:components} отображены модули системы:~
\begin{itemize}
	\item модуль жизненного цикла;
	\item модуль построения маршрута;
	\item модуль исполнения маршрута;
	\item модуль получения данных сенсоров;
	\item модуль отправки данных на шасси;
	\item модуль получения информации о целевой позиции;
	\item модуль построения карты;
	\item модуль оценки позиции;
	\item модуль совмещения измерений Lidar сенсора.
\end{itemize}

\subsection{Описание модулей системы}

Коммуникация между модулями осуществляется через модуль жизненного цикла, все
модули получают и отправляют информацию через него, не считая сильно-связных
модулей в системе SLAM. 

% Модули сбора информации
Модуль получения данных сенсоров осуществляет сбор информации: 2D Lidar
предоставляет информацию о расстояниях до объектов в окружающем пространстве,
IMU — данные об угловых ускорениях и наклоне устройства, а GPS — информацию о
глобальном местоположении. Все эти данные передаются в модуль SLAM, который
использует их для построения карты окружающей среды и вычисления текущего
местоположения робота. Это позволяет системе иметь точную картину окружающего
мира и следить за положением устройства.

Модуль совмещения измерений Lidar сенсора, является основой для построения карты
и локализации робота. С помощью данных от лидаров и модуля оценки позиции он
строит карту пространства, постоянно обновляя ее по мере движения робота, и
вычисляет его местоположение относительно этой карты. Это позволяет системе
динамично корректировать действия робота в зависимости от изменений в окружающей
среде, таких как появление новых препятствий или изменение положения объектов.

Полученные от совмещения измерений данные о местоположении робота передаются в модуль оценки
позиции. Этот модуль анализирует текущее положение устройства с использованием
фильтрации и различных методов оценки, таких как фильтр Калмана. Оценка позиции
робота имеет важное значение для корректного планирования маршрута, поскольку
точность информации о местоположении напрямую влияет на точность движений
устройства.

Модуль создания маршрута отвечает за вычисление оптимального пути от текущего
местоположения робота до заданной цели. Этот модуль использует данные о
местоположении, а также информацию о препятствиях, чтобы планировать наиболее
эффективный и безопасный маршрут. Важно, чтобы система могла адаптироваться к
изменениям окружающей среды, например, при возникновении новых препятствий,
система должна пересчитать маршрут в реальном времени, обеспечивая продолжение
движения робота без ошибок.

После того как маршрут спланирован, информация о нем передается в модуль
управления моторами. Этот модуль отвечает за выполнение команд, таких как
движение вперед, повороты и торможение. Модуль управления моторами должен
обеспечить точное выполнение команд с минимальными задержками, чтобы робот мог
двигаться по маршруту с высокой точностью. Кроме того, он должен поддерживать
оперативную реакцию на данные от сенсоров, такие как сигнал от лидаров,
предупреждающий о близко расположенных препятствиях.

При обнаружении препятствий вблизи, например, если расстояние до объекта
становится меньше заданного порога, система должна немедленно реагировать. Это
может быть реализовано командой «стоп», которая отправляется в модуль управления
моторами для немедленной остановки робота. Такие меры безопасности необходимы
для предотвращения столкновений и обеспечения безопасной работы робота в
различных условиях.


\subsection{Модуль оценки текущей позиции}
В качестве алгоритма для оценки движения предполагается использование UKF (см. раздел \ref{subsec:kf})

Вектор состояния системы на шаге \( k \) обозначается как \( \mathbf{x}_k \) и включает следующие компоненты:
\[
\mathbf{x}_k = \begin{bmatrix}
x_k \\
y_k \\
v_{x,k} \\
v_{y,k} \\
a_{x,k} \\
a_{y,k} \\
\theta_k \\
v_{\theta,k} \\
a_{\theta,k}
\end{bmatrix},
\]

где:
\begin{itemize}
  \item \( x_k, y_k \) — координаты объекта в двумерной плоскости (в метрах),
  \item \( v_{x,k}, v_{y,k} \) — скорости объекта по осям \( x \) и \( y \) (в м/с),
  \item \( a_{x,k}, a_{y,k} \) — ускорения объекта по осям \( x \) и \( y \) (в м/с\(^2\)), \item \( \theta_k \) — угол ориентации объекта (в радианах),
  \item \( v_{\theta,k} \) — угловая скорость объекта (в рад/с),
  \item \( a_{\theta,k} \) — угловое ускорение объекта (в рад/с\(^2\)).
\end{itemize}

\subsection{Модель состояния}
Динамика системы описывается уравнением состояния:
\[
\mathbf{x}_{k+1} = \mathbf{F}_k \mathbf{x}_k + \mathbf{B}_k \mathbf{u}_k + \mathbf{w}_k,
\]
где:
\begin{itemize}
  \item \( \mathbf{F}_k \) — матрица перехода состояния,
  \item \( \mathbf{B}_k \) — матрица управления,
  \item \( \mathbf{u}_k \) — вектор управляющего воздействия,
  \item \( \mathbf{w}_k \sim \mathcal{N}(0, \mathbf{Q}_k) \) — гауссовский шум процесса с ковариационной матрицей \( \mathbf{Q}_k \).
\end{itemize}

Например, для модели с постоянным ускорением и угловой скоростью матрица \( \mathbf{F}_k \) может иметь вид:
\[
\mathbf{F}_k = \begin{bmatrix}
1 & 0 & \Delta t & 0 & \frac{\Delta t^2}{2} & 0 & 0 & 0 & 0 \\
0 & 1 & 0 & \Delta t & 0 & \frac{\Delta t^2}{2} & 0 & 0 & 0 \\
0 & 0 & 1 & 0 & \Delta t & 0 & 0 & 0 & 0 \\
0 & 0 & 0 & 1 & 0 & \Delta t & 0 & 0 & 0 \\
0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 \\
0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 \\
0 & 0 & 0 & 0 & 0 & 0 & 1 & \Delta t & \frac{\Delta t^2}{2} \\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & \Delta t \\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1
\end{bmatrix},
\]
где \( \Delta t \) -- шаг.


Вектор состояния системы является ключевым элементом фильтра Калмана, 
описывающим динамическое состояние объекта в каждый момент времени \( k \). 
Он включает скрытые переменные, которые не измеряются напрямую, но определяют поведение системы.

Вектор состояния \( \mathbf{x}_k \) на шаге \( k \) задается следующим образом:

\[
\mathbf{x}_k = \begin{bmatrix}
x_k \\
y_k \\
v_{x,k} \\
v_{y,k} \\
a_{x,k} \\
a_{y,k} \\
\theta_k \\
v_{\theta,k} \\
a_{\theta,k}
\end{bmatrix},
\]

где компоненты вектора имеют следующий физический смысл:
\begin{itemize}
  \item \( x_k, y_k \) — координаты объекта в двумерной плоскости (в метрах),
  \item \( v_{x,k}, v_{y,k} \) — скорости объекта по осям \( x \) и \( y \) (в м/с),
  \item \( a_{x,k}, a_{y,k} \) — ускорения объекта по осям \( x \) и \( y \) (в м/с\(^2\)),
  \item \( \theta_k \) — угол ориентации объекта относительно оси \( x \) (в радианах),
  \item \( v_{\theta,k} \) — угловая скорость объекта (в рад/с),
  \item \( a_{\theta,k} \) — угловое ускорение объекта (в рад/с\(^2\)).
\end{itemize}

Вектор состояния \( \mathbf{x}_k \) на шаге \( k \) задается следующим образом:

\[
\mathbf{x}_k = \begin{bmatrix}
x_k \\
y_k \\
v_{x,k} \\
v_{y,k} \\
a_{x,k} \\
a_{y,k} \\
\theta_k \\
v_{\theta,k} \\
a_{\theta,k}
\end{bmatrix},
\]

\subsection{Взаимодействие с периферией}
В процессе разработки программного обеспечения для автономной навигации
мобильных платформ одной из ключевых задач стало обеспечение гибкого и надёжного
взаимодействия с периферийными устройствами, такими как датчики, камеры и
лидары. После анализа различных подходов было принято решение реализовать это
взаимодействие с использованием стека протоколов TCP/IP. Такой выбор обусловлен
универсальностью и стандартизацией данного протокола, который широко применяется
в сетевых технологиях и позволяет организовать стабильное соединение между
компонентами системы. Это решение обеспечивает возможность передачи данных в
реальном времени, что критически важно для задач управления и обработки
информации в динамичной среде.

Использование TCP/IP стека предоставляет значительное преимущество в виде
модульности и расширяемости системы. Благодаря этому подходу стало возможным
подключение различных датчиков к программе непосредственно во время её работы,
без необходимости останавливать или перезапускать систему. Например, если в
процессе эксплуатации мобильной платформы потребуется добавить новый лидар или
ультразвуковой датчик, это можно сделать "на лету", что существенно повышает
адаптивность системы к изменяющимся условиям или требованиям задачи. Такая
гибкость особенно ценна в экспериментальных или полевых условиях, где заранее
предусмотреть все сценарии использования невозможно.

Реализация взаимодействия через TCP/IP также упрощает интеграцию с современными
технологиями и стандартами, используемыми в робототехнике. Например, многие
устройства уже имеют встроенную поддержку сетевых протоколов, что позволяет
избежать разработки сложных проприетарных интерфейсов для каждого типа
периферии. Кроме того, TCP/IP обеспечивает надёжную передачу данных с механизмом
проверки ошибок, что снижает риск потери критически важной информации от
датчиков. Это особенно актуально для автономных систем, где точность и
своевременность получения данных напрямую влияют на качество навигации и
принятия решений.

Наконец, выбор TCP/IP стека открывает перспективы для дальнейшего развития
проекта в сторону распределённых систем. В будущем это позволит не только
подключать датчики локально, но и организовывать взаимодействие между
несколькими мобильными платформами или центральным сервером через сеть. Такой
подход может быть полезен, например, для координации группы роботов или передачи
данных в облако для анализа. Таким образом, использование TCP/IP не только
решает текущие задачи взаимодействия с периферией, но и закладывает фундамент
для масштабирования системы, делая её более универсальной и готовой к новым
вызовам в области автономной навигации.

\subsection{Язык программирования}
Robot Operating System (ROS) представляет собой широко используемую программную
платформу для разработки робототехнических систем, и одной из её ключевых
особенностей является то, что она написана на языке программирования C++. Этот
выбор не случаен: C++ считается стандартом индустрии благодаря своей высокой
производительности, гибкости и возможности работы на низком уровне с аппаратным
обеспечением. В контексте робототехники, где требуется быстрая обработка данных
с датчиков и управление механизмами в реальном времени, такие качества C++
становятся незаменимыми. Использование C++ в ROS позволяет разработчикам
создавать эффективные и масштабируемые решения для сложных задач, таких как
автономная навигация, обработка сигналов или взаимодействие с физическими
устройствами. Этот язык обеспечивает тонкий контроль над ресурсами системы, что
особенно важно для мобильных платформ с ограниченными вычислительными
мощностями. Кроме того, C++ обладает богатым набором библиотек и инструментов,
которые упрощают интеграцию ROS с другими технологиями, укрепляя его как
стандарта в индустрии робототехники.

Несмотря на все преимущества C++ как стандарта индустрии и основы для ROS, в
последние годы всё большее внимание в разработке программного обеспечения,
включая робототехнику, привлекает язык программирования Rust. В контексте ROS
уже появляются инициативы по интеграции Rust, что может дополнить или даже со
временем частично заменить C++, предлагая разработчикам более надёжный и удобный
инструмент для создания автономных систем, сохраняя при этом совместимость с
существующей экосистемой ROS.

Одним из ключевых преимуществ Rust является его способность обеспечивать
безопасность многозадачности. В отличие от C++, который требует дополнительных
усилий для безопасного выполнения параллельных операций, Rust изначально
предусматривает механизмы предотвращения гонок данных, что делает код более
надежным. Это особенно важно для системы навигации, где необходимо параллельно
обрабатывать данные с различных сенсоров и вычислять управляющие команды без
риска возникновения ошибок синхронизации.

Rust также предоставляет встроенные инструменты для работы с асинхронным
программированием, что позволяет эффективно организовать обработку данных в
реальном времени. Асинхронные операции позволяют системе собирать данные с
сенсоров, планировать маршрут и управлять моторами без блокировки основного
потока выполнения, что способствует повышению производительности и снижению
задержек.

Программная экосистема Rust активно развивается, и существует множество
библиотек, которые могут быть использованы для решения задач, связанных с
обработкой сенсорных данных, математическими расчетами и оптимизацией маршрутов.
Это позволяет разработчикам легко интегрировать необходимые инструменты и
сокращать время на разработку и тестирование системы. Также, благодаря хорошей
поддержке со стороны сообщества, Rust предоставляет разработчикам множество
ресурсов для быстрого решения возникающих вопросов.

Ключевым преимуществом Rust является его кроссплатформенность. Код, написанный
на этом языке, может быть скомпилирован для различных платформ, что делает Rust
отличным выбором для мобильных роботов, которые могут работать на разных типах
оборудования. Это позволяет без значительных усилий адаптировать систему под
разные архитектуры и аппаратные платформы.

Будущие улучшения системы могут включать в себя добавление новых сенсоров,
улучшение алгоритмов SLAM и маршрутизации, а также интеграцию с внешними
системами, такими как онлайн-карты или системы для прогнозирования дорожной
ситуации. Rust, благодаря своей гибкости и безопасному управлению памятью,
идеально подходит для такой работы, обеспечивая долгосрочную устойчивость и
развитие проекта.

Таким образом, проектирование программного обеспечения для системы мобильной
навигации с использованием сенсоров и алгоритмов SLAM требует тщательной
проработки архитектуры, выбора эффективных технологий и инструментов. Язык Rust
является отличным выбором для разработки таких систем, благодаря своим
преимуществам в безопасности, производительности и поддержке многозадачности,
что делает его идеальным для создания высоконадежных и высокопроизводительных
приложений для робототехники.

Robot Operating System (ROS) представляет собой широко используемую программную
платформу для разработки робототехнических систем, и одной из её ключевых
особенностей является то, что она написана на языке программирования C++. Этот
выбор не случаен: C++ считается стандартом индустрии благодаря своей высокой
производительности, гибкости и возможности работы на низком уровне с аппаратным
обеспечением. В контексте робототехники, где требуется быстрая обработка данных
с датчиков и управление механизмами в реальном времени, такие качества C++
становятся незаменимыми. Использование C++ в ROS позволяет разработчикам
создавать эффективные и масштабируемые решения для сложных задач, таких как
автономная навигация, обработка сигналов или взаимодействие с физическими
устройствами. Этот язык обеспечивает тонкий контроль над ресурсами системы, что
особенно важно для мобильных платформ с ограниченными вычислительными
мощностями. Кроме того, C++ обладает богатым набором библиотек и инструментов,
которые упрощают интеграцию ROS с другими технологиями, укрепляя его как
стандарта в индустрии робототехники.

Несмотря на все преимущества C++ как стандарта индустрии и основы для ROS, в
последние годы всё большее внимание в разработке программного обеспечения,
включая робототехнику, привлекает язык программирования Rust. В контексте ROS
уже появляются инициативы по интеграции Rust, что может дополнить или даже со
временем частично заменить C++, предлагая разработчикам более надёжный и удобный
инструмент для создания автономных систем, сохраняя при этом совместимость с
существующей экосистемой ROS.

Одним из ключевых преимуществ Rust является его способность обеспечивать
безопасность многозадачности. В отличие от C++, который требует дополнительных
усилий для безопасного выполнения параллельных операций, Rust изначально
предусматривает механизмы предотвращения гонок данных, что делает код более
надежным. Это особенно важно для системы навигации, где необходимо параллельно
обрабатывать данные с различных сенсоров и вычислять управляющие команды без
риска возникновения ошибок синхронизации.

Rust также предоставляет встроенные инструменты для работы с асинхронным
программированием, что позволяет эффективно организовать обработку данных в
реальном времени. Асинхронные операции позволяют системе собирать данные с
сенсоров, планировать маршрут и управлять моторами без блокировки основного
потока выполнения, что способствует повышению производительности и снижению
задержек.

Программная экосистема Rust активно развивается, и существует множество
библиотек, которые могут быть использованы для решения задач, связанных с
обработкой сенсорных данных, математическими расчетами и оптимизацией маршрутов.
Это позволяет разработчикам легко интегрировать необходимые инструменты и
сокращать время на разработку и тестирование системы. Также, благодаря хорошей
поддержке со стороны сообщества, Rust предоставляет разработчикам множество
ресурсов для быстрого решения возникающих вопросов.

Ключевым преимуществом Rust является его кроссплатформенность. Код, написанный
на этом языке, может быть скомпилирован для различных платформ, что делает Rust
отличным выбором для мобильных роботов, которые могут работать на разных типах
оборудования. Это позволяет без значительных усилий адаптировать систему под
разные архитектуры и аппаратные платформы.

Будущие улучшения системы могут включать в себя добавление новых сенсоров,
улучшение алгоритмов SLAM и маршрутизации, а также интеграцию с внешними
системами, такими как онлайн-карты или системы для прогнозирования дорожной
ситуации. Rust, благодаря своей гибкости и безопасному управлению памятью,
идеально подходит для такой работы, обеспечивая долгосрочную устойчивость и
развитие проекта.

Таким образом, проектирование программного обеспечения для системы мобильной
навигации с использованием сенсоров и алгоритмов SLAM требует тщательной
проработки архитектуры, выбора эффективных технологий и инструментов. Язык Rust
является отличным выбором для разработки таких систем, благодаря своим
преимуществам в безопасности, производительности и поддержке многозадачности,
что делает его идеальным для создания высоконадежных и высокопроизводительных
приложений для робототехники.
