==> ./config/mod.rs <==
mod world_map;

use std::time::Duration;

use roboq_types::{
    from_variant,
    model::{
        localization::{LocalizationParams, MatchingParams, NoiseParams},
        map::MapParams,
        plan::{MetricsParams, PlannerParams, StuckParams},
        robot_params::RobotParams2D,
        Metres,
    },
};
use serde::{Deserialize, Serialize};

use crate::{
    icp::icp_slam::{IcpSlamConfig, IcpSlamInitConfig},
    planner::PlannerSimulationConfig,
};

pub use roboq_types::model::localization::SensorParams;

#[cfg(feature = "localization")]
pub use crate::localization::MotionEstimationConfig;

pub use crate::planner::RobotConfig;
pub use world_map::WorldMapConfig;

#[derive(Debug, Clone)]
pub enum ConfigProperty {
    UpdateMap(bool),
    UseCollisions(bool),
    UseDebug(bool),
    /// the maximal period of time
    /// after which robot will be stopped
    /// if no more commands were supplied
    ReactionTimeout(Duration),
    CollisionDistance(Metres),

    MapParams(MapParams),
    RobotParams(RobotParams2D),
    NoiseParams(NoiseParams),
    LocalizationParams(LocalizationParams),
    MatchingParams(MatchingParams),
    SensorParams(SensorParams),

    //planner related params
    PlannerParams(PlannerParams),
    StuckParams(StuckParams),
    MetricsParams(MetricsParams),
}

from_variant!(ConfigProperty, SensorParams);
from_variant!(ConfigProperty, MapParams);
from_variant!(ConfigProperty, NoiseParams);
from_variant!(ConfigProperty, PlannerParams);
from_variant!(ConfigProperty, LocalizationParams);
from_variant!(ConfigProperty, MatchingParams);
from_variant!(ConfigProperty, StuckParams);
from_variant!(ConfigProperty, MetricsParams);

#[derive(Default, Clone, Serialize, Deserialize)]
pub struct DebugConfig {
    pub enabled: bool,
}

#[derive(Default, Clone, Serialize, Deserialize)]
pub struct NavigationConfig {
    pub icp_slam_init_config: IcpSlamInitConfig,
    //base icp_slam_config
    pub icp_slam_config: IcpSlamConfig,
    pub planner_config: PlannerSimulationConfig,

    #[cfg(all(feature = "localization", feature = "gps"))]
    pub world_map_config: WorldMapConfig,

    #[cfg(feature = "localization")]
    pub estimation_config: MotionEstimationConfig,

    pub debug_config: DebugConfig,
    #[cfg(feature = "localization")]
    pub devices_config: SensorParams,

    #[serde(default)]
    pub matching_config: MatchingParams,
}

impl NavigationConfig {
    pub fn apply_property(&mut self, property: ConfigProperty) {
        let config = self;

        match property {
            ConfigProperty::UpdateMap(updating_map) => {
                config.icp_slam_config.updating_map = updating_map;
            }

            ConfigProperty::UseCollisions(use_collisions) => {
                config.planner_config.use_collisions = use_collisions;
            }

            ConfigProperty::UseDebug(enabled) => {
                config.debug_config.enabled = enabled;
            }

            ConfigProperty::RobotParams(params) => {
                config.planner_config.robot.update(params);
            }

            ConfigProperty::ReactionTimeout(timeout) => {
                config.planner_config.idle_timeout_ms =
                    timeout.as_millis() as u64;
            }

            ConfigProperty::CollisionDistance(distance) => {
                config.planner_config.collision_distance = distance;
            }

            ConfigProperty::PlannerParams(params) => {
                config.planner_config.update(params);
            }

            ConfigProperty::NoiseParams(params) => {
                config.estimation_config.update_noise(params);
            }

            ConfigProperty::MapParams(params) => {
                #[cfg(feature = "gps")]
                config.world_map_config.update(params);

                #[cfg(not(feature = "gps"))]
                drop(params);
            }

            ConfigProperty::LocalizationParams(params) => {
                config.estimation_config.update(params);
            }

            ConfigProperty::MatchingParams(params) => {
                config.matching_config = params;
            }

            ConfigProperty::SensorParams(params) => {
                config.devices_config = params;
            }

            ConfigProperty::StuckParams(params) => {
                config.planner_config.stuck = params;
            }

            ConfigProperty::MetricsParams(params) => {
                config.planner_config.metrics = params;
            }
        }
    }

    pub fn to_properties(&self) -> Vec<ConfigProperty> {
        vec![
            ConfigProperty::UpdateMap(self.icp_slam_config.updating_map),
            ConfigProperty::UseCollisions(self.planner_config.use_collisions),
            ConfigProperty::UseDebug(self.debug_config.enabled),
            ConfigProperty::ReactionTimeout(Duration::from_millis(
                self.planner_config.idle_timeout_ms,
            )),
            ConfigProperty::RobotParams(
                self.planner_config.robot.clone().into(),
            ),
            ConfigProperty::CollisionDistance(
                self.planner_config.collision_distance,
            ),
            ConfigProperty::PlannerParams((&self.planner_config).into()),
            ConfigProperty::StuckParams(self.planner_config.stuck.clone()),
            ConfigProperty::MatchingParams(self.matching_config.clone()),
            #[cfg(feature = "localization")]
            ConfigProperty::SensorParams(self.devices_config.clone()),
            ConfigProperty::MetricsParams(self.planner_config.metrics.clone()),
            #[cfg(feature = "localization")]
            ConfigProperty::NoiseParams(self.estimation_config.noise_params()),
            #[cfg(not(feature = "localization"))]
            ConfigProperty::NoiseParams(Default::default()),
            #[cfg(feature = "gps")]
            ConfigProperty::MapParams((&self.world_map_config).into()),
            #[cfg(feature = "localization")]
            ConfigProperty::LocalizationParams(self.estimation_config.params()),
            #[cfg(not(feature = "localization"))]
            ConfigProperty::LocalizationParams(Default::default()),
        ]
    }
}

==> ./config/world_map.rs <==
use std::time::Duration;

use roboq_types::model::map::MapParams;

#[derive(Clone, serde::Serialize, serde::Deserialize, o2o::o2o)]
#[from(MapParams)]
#[into(MapParams)]
pub struct WorldMapConfig {
    /// Should we use predefined zone or not
    #[serde(default)]
    pub utm_zone: Option<u8>,

    #[serde(default = "default_utm_threshold")]
    pub utm_threshold: f64,

    pub map_rotation: f64,

    #[serde(
        serialize_with = "roboq_types::serde::serialize_millis",
        deserialize_with = "roboq_types::serde::deserialize_millis",
        default = "default_coords_lifetime"
    )]
    pub coords_lifetime: Duration,
}

impl WorldMapConfig {
    pub fn update(&mut self, params: MapParams) {
        *self = params.into();
    }
}

fn default_utm_threshold() -> f64 {
    10000.0
}

fn default_coords_lifetime() -> Duration {
    Duration::from_millis(1_000)
}

impl Default for WorldMapConfig {
    fn default() -> Self {
        Self {
            coords_lifetime: default_coords_lifetime(),
            utm_threshold: default_utm_threshold(),
            map_rotation: 0.0,
            utm_zone: None,
        }
    }
}

==> ./correlative_scan_matching/correlation_grid.rs <==
use nalgebra::{Point2, Vector2};
use roboq_types::model::{map::MetresPerPixel, Metres};
use serde::{Deserialize, Serialize};

use super::localized_range_scan::LocalizedRangeScan;
use crate::model::array2d::Array2D;

#[derive(Clone, Serialize, Deserialize)]
pub struct CorrelationGrid {
    pub grid: Array2D<u8>,
    pub resolution: MetresPerPixel,
    pub size_metres: f32,
    pub top_left_corner: Vector2<f32>,
    pub gauss_blur: Array2D<u8>,
}

impl CorrelationGrid {
    pub fn new(
        size_metres: f32,
        resolution: MetresPerPixel,
        pos: Vector2<f32>,
        std_deviation: Metres,
    ) -> Self {
        let correlation_grid_size_pixels =
            resolution.to_pixels(Metres(size_metres)) as u32;

        let kernel_size = 2 * resolution.to_pixels(std_deviation * 2.0) + 1;

        let gauss_blur = new_gaussian_blur_kernel(
            kernel_size as u32,
            &resolution,
            std_deviation,
        );

        CorrelationGrid {
            resolution,
            size_metres,
            grid: Array2D::new_square(correlation_grid_size_pixels),
            top_left_corner: pos,
            gauss_blur,
        }
    }

    /// Reset probability lookup grid
    pub fn clear(&mut self) {
        self.grid.fill(0);
    }

    pub fn set_center(&mut self, center: Vector2<f32>) {
        let grid_size_metres =
            self.resolution.vector_to_metres(&self.grid.size());
        self.top_left_corner = center - grid_size_metres / 2.0;
    }

    pub fn add_scan(&mut self, scan: &LocalizedRangeScan) {
        for point in &scan.points {
            self.add_point(point);
        }
    }

    ///Add point to grid applying gaussian blur
    ///to estimate pose probability for this one
    pub fn add_point(&mut self, point: &Point2<f32>) {
        let point_on_grid = self
            .resolution
            .point_to_pixels(&(point - self.top_left_corner));

        let kernel_size = self.gauss_blur.get_width();
        let radius = (kernel_size - 1) / 2;

        let top_left_kernel_on_grid =
            point_on_grid - Vector2::new(radius, radius);

        if top_left_kernel_on_grid.x < 0
            || top_left_kernel_on_grid.y < 0
            || top_left_kernel_on_grid.x > (self.grid.get_width() - kernel_size)
            || top_left_kernel_on_grid.y > (self.grid.get_width() - kernel_size)
        {
            return;
        }

        for x in 0..kernel_size {
            for y in 0..kernel_size {
                let kernel_weight =
                    self.gauss_blur.index_grid(&Point2::new(x, y));

                let grid_weight = self.grid.index_grid_mut(
                    &(top_left_kernel_on_grid + Vector2::new(x, y)),
                );

                *grid_weight = (*grid_weight).max(*kernel_weight);
            }
        }
    }
}

fn new_gaussian_blur_kernel(
    size: u32,
    resolution: &MetresPerPixel,
    std_deviation: Metres,
) -> Array2D<u8> {
    let mut kernel = Array2D::new_square(size);

    let kernel_size = size as i32;
    let sigma = *std_deviation;

    for x in 0..kernel_size {
        for y in 0..kernel_size {
            let x_dist = (x - kernel_size / 2) as f32;
            let y_dist = (y - kernel_size / 2) as f32;

            let distance = resolution
                .to_metres((x_dist * x_dist + y_dist * y_dist).sqrt());

            let z = ((-0.5f32) * (distance / sigma).powi(2)).exp();

            *kernel.index_grid_mut(&Point2::new(x, y)) = (z * 255.0) as u8;
        }
    }

    kernel
}

==> ./correlative_scan_matching/localized_range_scan.rs <==
use nalgebra::Point2;
use serde::{Deserialize, Serialize};

use crate::{icp::icp_svd::PointCloud, model::pose::Pose2D};

#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct LocalizedRangeScan {
    /// All points in LocalizedRangeScan are already in the position of robots pose
    /// changing robot pose doesn't change the offset of the points, and points are not stored in
    /// respect to the origin.
    pub points: Vec<Point2<f32>>,
    /// Center of the scan pose with rotation.
    pub pose: Pose2D,
}

impl LocalizedRangeScan {
    pub fn cloud_at_position(
        point_cloud: PointCloud,
        robot_pose: Pose2D,
    ) -> Self {
        let transformation = robot_pose.as_isometry();

        let points: Vec<_> = point_cloud
            .into_iter()
            .map(|p| transformation * p)
            .collect();

        LocalizedRangeScan {
            pose: robot_pose,
            points,
        }
    }
}

==> ./correlative_scan_matching/mod.rs <==
pub mod correlation_grid;
pub mod localized_range_scan;
pub mod scan_matcher;
pub mod scan_ring_buffer;

// TODO
/*
pub fn find_corelation(scan: LidarResponse, map: &mut Map) -> (f32, f32, f32) {
    let mut most_good = (0.0, 0.0, 0.0);
    let mut most_good_score = 0;

    for angle in 0..360 {
        let points = point_cloud_from_lidar_response_angle(&scan, (angle as f32).to_radians());
        for x in -100..100 {
            for y in -100..100 {
                let mut current_score = 0;
                for point in &points {
                    let translated_point = point + Vector2::new(x as f32, y as f32);
                    current_score += *map.access_clamped_metres(&translated_point) as u64;
                }
                if current_score > most_good_score {
                    most_good_score = current_score;
                    most_good = (x as f32, y as f32, angle as f32);
                }
            }
        }
    }

    most_good
}

pub fn match_two_scans(source: Vec<Point2<f32>>, target: Vec<Point2<f32>>) {
    let probability_map: Map = Map::new_empty(Vector2::new(500, 500), 0.03);
}

/*struct MapperParemeters {
    use_scan_matching: bool,
    use_scan_barycetner: bool,
    minimum_time_interval: f64,
    minimum_travel_distance: f64,
    minimum_travel_heading: f64,
    scan_buffer_size: u32,
    scan_buffer_maximum_scan_distance: f64,
    link_match_minumum_response_fine: f64,
    linux_scan_maximum_distance: f64,
    do_loop_closing: bool,
    loop_search_maximum_distance: f64,
    loop_match_minimum_chain_size: u32,

    loop_match_maximum_variance_coarse: f64,

    loop_match_minimum_response_coarse: f64,
    loop_match_minimum_respose_fine: f64,

    correlation_search_space_dimension: f64,
    correlation_search_space_resolution: f64,
    correlation_search_space_smear_deviation: f64,

    loop_search_space_dimension: f64,
    loop_search_space_resolution: f64,
}

struct LocalizedRangeScan {

}

struct Mapper {

}

impl Mapper {
    fn process_scan(scan: LocalizedRangeScan) {

    }
}

pub fn correlate_scan() {

}*/*/

==> ./correlative_scan_matching/scan_matcher.rs <==
use nalgebra::{Rotation2, Vector2};
use roboq_types::model::{map::MetresPerPixel, Metres};
use serde::{Deserialize, Serialize};

use crate::model::{array2d::Array2D, pose::Pose2D};

use super::{
    correlation_grid::CorrelationGrid, localized_range_scan::LocalizedRangeScan,
};

#[derive(Serialize, Deserialize)]
pub struct ScanMatcher {
    correlation_grid: CorrelationGrid,

    search_space_probabilities: Vec<Array2D<f32>>,
    search_space_resolution: MetresPerPixel,
    search_space_size: f32,
    scan_circle_buffer: Vec<LocalizedRangeScan>,
}

impl ScanMatcher {
    pub fn new() -> Self {
        let correlation_grid_resolution = MetresPerPixel(0.01);

        let max_range_scan = 30.0;

        let search_space_size = 0.5;

        // all values <= 3 * sigma = 10cm
        let std_deviation = Metres(0.03);

        let correlation_grid_size_metres =
            max_range_scan * 2.0 + search_space_size;

        let correlation_grid_pos = Vector2::new(0.0, 0.0);

        let correlation_grid = CorrelationGrid::new(
            correlation_grid_size_metres,
            correlation_grid_resolution,
            correlation_grid_pos,
            std_deviation,
        );

        let search_space_resolution = MetresPerPixel(0.01);

        let mut search_space_grid_size =
            search_space_resolution.to_pixels(Metres(search_space_size)) as u32;

        // Ensuring that search space is odd number, so we can search -half_size and +half_size
        // without worrying about 0 (like 5 is -2 to +2, with 0)
        if (search_space_grid_size % 2) == 0 {
            search_space_grid_size += 1;
        }
        assert!(search_space_grid_size % 2 == 1);

        let revolution_resolution = 360;

        let space_at_resolution = Array2D::new_square(search_space_grid_size);

        let search_space_probabilities =
            vec![space_at_resolution; revolution_resolution];

        ScanMatcher {
            correlation_grid,
            search_space_probabilities,
            scan_circle_buffer: Vec::new(),
            search_space_resolution,
            search_space_size,
        }
    }

    pub fn match_scan_against_set_of_scans<'a>(
        &mut self,
        scan: &LocalizedRangeScan,
        set_of_scans: impl Iterator<Item = &'a LocalizedRangeScan>,
    ) -> Pose2D {
        let revolution_resolution = 360;
        let rad_per_degree =
            std::f32::consts::TAU / revolution_resolution as f32;

        // Initialization of correlation grid
        {
            self.correlation_grid.clear();
            self.correlation_grid.set_center(scan.pose.coords.coords);

            for scan in set_of_scans {
                self.correlation_grid.add_scan(scan);
            }
        }

        let (search_space_size, half_search_space) = {
            //each search_space has same width
            let width = self.search_space_probabilities[0].get_width() as usize;

            let half_width = ((width - 1) / 2) as i32;

            (width, half_width)
        };

        for iangle in 0..revolution_resolution {
            let angle = iangle as f32 * rad_per_degree;

            let mut current_test_scan = Vec::with_capacity(scan.points.len());

            let rotation = Rotation2::new(angle);

            for point in scan.points.iter() {
                let rotated_point = rotation
                    * (point - scan.pose.coords.coords)
                    + scan.pose.coords.coords
                    - self.correlation_grid.top_left_corner;

                let point_on_grid = self
                    .correlation_grid
                    .resolution
                    .point_to_pixels(&rotated_point)
                    - Vector2::new(half_search_space, half_search_space);

                let point_weigth =
                    self.correlation_grid.grid.index(&(point_on_grid));

                current_test_scan.push(point_weigth);
            }

            let search_space_probabilities =
                &mut self.search_space_probabilities[iangle];

            let correlation_grid_size =
                self.correlation_grid.grid.get_width() as usize;

            for y in 0..search_space_size {
                let y_offset = y * correlation_grid_size;
                let y_offset_search_space = y * search_space_size;

                for point in &current_test_scan {
                    let point_offset = point + y_offset;

                    update_search_space(
                        &mut search_space_probabilities.data,
                        &self.correlation_grid.grid.data,
                        point_offset,
                        y_offset_search_space,
                        search_space_size,
                    );
                }
            }
        }

        let divisor: f32 = 1.0 / scan.points.len() as f32;
        let mut max_prob: f32 = f32::MIN;

        for array in self.search_space_probabilities.iter_mut() {
            for prob in &mut array.data {
                *prob *= divisor;

                if *prob > max_prob {
                    max_prob = *prob;
                }
            }
        }

        let mut avg_count: usize = 0;
        let mut avg_x: f32 = 0.0;
        let mut avg_y: f32 = 0.0;
        let mut avg_sin: f32 = 0.0;
        let mut avg_cos: f32 = 0.0;
        let mut angle_old = 0.0;

        assert_eq!(revolution_resolution, 360);

        for (angle_index, array) in
            self.search_space_probabilities.iter().enumerate()
        {
            let angle: f32 = angle_index as f32;

            for (index, prob) in array.data.iter().enumerate() {
                if *prob >= max_prob {
                    angle_old = angle;
                    let (sin, cos) = angle.to_radians().sin_cos();
                    let (x, y) = array.from_index_to_xy(index);
                    avg_sin += sin;
                    avg_cos += cos;
                    avg_x += x as f32;
                    avg_y += y as f32;
                    avg_count += 1;
                }
            }
        }

        log::trace!("Old angle: {angle_old}");
        log::trace!("Max response: {max_prob}");
        log::trace!("AVG X: {avg_x}. AVG Y: {avg_y}");
        log::trace!("AVG COUNT: {avg_count}");

        avg_x /= avg_count as f32;
        avg_y /= avg_count as f32;

        let angle = scan.pose.heading_rad + avg_sin.atan2(avg_cos);

        let coords = scan.pose.coords
            - Vector2::new(
                self.search_space_size / 2.0,
                self.search_space_size / 2.0,
            )
            + Vector2::new(
                self.search_space_resolution.to_metres(avg_x),
                self.search_space_resolution.to_metres(avg_y),
            );

        Pose2D {
            heading_rad: angle,
            coords,
        }
    }
}

/// Update values in given search space `probabilities`
/// applying weight values from grid lookup slice
#[inline]
pub fn update_search_space(
    probabilities: &mut [f32],
    grid: &[u8],
    point_offset: usize,
    y_offset_search_space: usize,
    search_space_size: usize,
) {
    unsafe {
        let weight_ptr = grid.get_unchecked(point_offset) as *const u8;

        let prob_ptr =
            probabilities.get_unchecked_mut(y_offset_search_space) as *mut f32;

        for x in 0..search_space_size {
            *(prob_ptr.add(x)) += *weight_ptr.add(x) as f32;
        }
    }
}

// #[inline]
// pub fn update_search_space_safe(
//     probabilities: &mut [f32],
//     grid: &[u8],
//     point_offset: usize,
//     y_offset_search_space: usize,
//     search_space_size: usize,
// ) {
//     for x in 0..search_space_size {
//         probabilities[y_offset_search_space + x] +=
//             grid[point_offset + x] as f32;
//     }
// }
//
// #[inline]
// pub fn update_search_space2(
//     probabilities: &mut [u32],
//     grid: &[u8],
//     point_offset: usize,
//     y_offset_search_space: usize,
//     search_space_size: usize,
// ) {
//     unsafe {
//         for x in 0..search_space_size {
//             let data = grid.get_unchecked(point_offset + x);
//             *(probabilities.get_unchecked_mut(y_offset_search_space + x)) +=
//                 *data as u32;
//         }
//     }
// }

impl Default for ScanMatcher {
    fn default() -> Self {
        Self::new()
    }
}

==> ./correlative_scan_matching/scan_ring_buffer.rs <==
use std::{collections::HashMap, time::SystemTime};

use roboq_types::devices::DeviceId;
use serde::{Deserialize, Serialize};

use super::localized_range_scan::LocalizedRangeScan;

#[derive(Clone, Serialize, Deserialize)]
pub struct ScanRingBuffer {
    #[serde(skip)]
    raw_scans: HashMap<DeviceId, (LocalizedRangeScan, SystemTime)>,
    #[serde(skip)]
    matched_scans: Vec<LocalizedRangeScan>,

    len: usize,
}

//todo: remove old scans

impl ScanRingBuffer {
    pub fn new(len: usize) -> Self {
        assert!(len >= 1, "Not empty buffer is allowed");

        ScanRingBuffer {
            raw_scans: HashMap::new(),
            matched_scans: vec![],
            len,
        }
    }

    pub fn iter(&self) -> impl Iterator<Item = &LocalizedRangeScan> {
        self.matched_scans.iter()
    }

    pub fn add_raw_scan(
        &mut self,
        device_id: DeviceId,
        scan: LocalizedRangeScan,
    ) {
        self.raw_scans.insert(device_id, (scan, SystemTime::now()));
    }

    pub fn add_matched_scan(&mut self, scan: LocalizedRangeScan) {
        let scans = &mut self.matched_scans;

        scans.push(scan);

        if scans.len() > self.len {
            *scans = scans[(scans.len() - self.len)..scans.len()].to_vec();
        }
    }

    pub fn latest(
        &self,
    ) -> impl Iterator<Item = (DeviceId, &LocalizedRangeScan, SystemTime)> {
        self.raw_scans
            .iter()
            .map(|(&id, (scan, time))| (id, scan, *time))
    }

    pub fn is_empty(&self) -> bool {
        self.matched_scans.is_empty()
    }

    pub fn len(&self) -> usize {
        self.len
    }
}

impl std::ops::Deref for ScanRingBuffer {
    type Target = [LocalizedRangeScan];

    fn deref(&self) -> &Self::Target {
        &self.matched_scans
    }
}

==> ./debug/mod.rs <==
pub use roboq_types::model::debug::{DebugData, DebugDataKind};
pub use tokio::sync::mpsc::error::TryRecvError;
pub use tokio::sync::mpsc::{channel, Receiver, Sender};

pub use roboq_types::model::debug::AlgoKind;

pub type DebugSender = Sender<DebugData>;

==> ./devices/compass.rs <==
use std::time::SystemTime;

use roboq_types::model::localization::{SensorData, SensorEvent};

use crate::shared_data::SharedData;

pub fn handle(shared_data: &SharedData, angle: f32) -> Option<SensorEvent> {
    let map_rotation = shared_data
        .config()
        .blocking_read()
        .world_map_config
        .map_rotation;

    log::trace!("Compass angle: {angle}");
    let angle_rad = angle as f64;

    let mut rotation_rad = (angle_rad - map_rotation).abs() as f32;

    if rotation_rad < 0.0 {
        rotation_rad += 2.0 * std::f32::consts::PI;
    }

    if rotation_rad >= 2.0 * std::f32::consts::PI {
        rotation_rad -= 2.0 * std::f32::consts::PI;
    }

    if rotation_rad > std::f32::consts::PI {
        rotation_rad -= 2.0 * std::f32::consts::PI;
    }

    let data = SensorData::new(rotation_rad, SystemTime::now());

    Some(SensorEvent::CompassRotation(data))
}

==> ./devices/gps.rs <==
use nalgebra::Point2;
use roboq_types::{
    devices::{gps::GpsData, NORMAL_VARIANCE},
    model::localization::SensorEvent,
};

use crate::{
    localization::{WorldPoint, WorldTransform},
    shared_data::SharedData,
};

pub fn handle(data: GpsData, shared_data: &SharedData) -> Option<SensorEvent> {
    let has_good_quality = data
        .metadata
        .covariance
        .check_variance(NORMAL_VARIANCE * 2.0);

    if !has_good_quality {
        log::debug!("Bad quality for gps data");
        return None;
    }

    let Some(position) = data.position else {
        log::warn!("No position for good gps quality!?");
        return None;
    };

    log::trace!("Incoming gps pos: {:?}", position);

    let config = shared_data
        .config()
        .blocking_read()
        .world_map_config
        .clone();

    //todo: consider to use ENU (local tanget plan coordinates as option)

    let (northing, easting, meridian_convergence) =
        if let Some(zone) = config.utm_zone {
            utm::to_utm_wgs84(position.latitude, position.longitude, zone)
        } else {
            utm::to_utm_wgs84_no_zone(position.latitude, position.longitude)
        };

    let odom_pose = {
        let me = shared_data.motion_estimation.read().unwrap();

        me.get_estimated_state_unchecked().position
    };

    let should_update = |transform: &WorldTransform| -> bool {
        let world_distance = ((transform.last_world_coords.x - easting)
            .powi(2)
            + (transform.last_world_coords.y - northing).powi(2))
        .sqrt();

        world_distance > config.utm_threshold
    };

    let mut transform_lock = shared_data
        .world_transform
        .write()
        .expect("Failed to access word transform");

    if let Some(transform) = transform_lock.as_mut() {
        if !should_update(transform) {
            let world_coords = Point2::new(easting, northing);

            let odom_coords = transform.to_odom_from_world(&world_coords);

            log::debug!("Odom pos: {}", odom_pose.coords);
            log::trace!(
                "UTM pos: N={northing}, E={easting}, MC={meridian_convergence}"
            );

            log::debug!("Transform: {transform:?}");

            transform.set_current_coords(&world_coords, config.coords_lifetime);

            return Some(SensorEvent::GpsCoords(odom_coords.into()));
        }
    }

    let point = WorldPoint::new(
        Point2::new(odom_pose.coords.x as f64, odom_pose.coords.y as f64),
        Point2::new(easting, northing),
    );

    let mut transform = WorldTransform::with_rotation(point, config.map_rotation);
    transform.set_current_coords(&point.world_coords(), config.coords_lifetime);

    *transform_lock = Some(transform);

    Some(SensorEvent::GpsCoords(odom_pose.coords.into()))
}

==> ./devices/imu.rs <==
use std::time::SystemTime;

use nalgebra::Vector3;
use roboq_types::{
    devices::imu::ImuData,
    model::localization::{ImuSensorParams, SensorData, SensorEvent},
};

#[derive(Default)]
pub struct ImuSharedData {
    prev_angular: Option<(SystemTime, Vector3<f32>)>,
}

pub fn handle(
    data: ImuData,
    config: &ImuSensorParams,
    state: &mut ImuSharedData,
) -> Option<SensorEvent> {
    let accel = {
        let (x, y, z) = data.measurement.accel?.norm();
        Vector3::new(x, y, z)
    };

    let gyro = {
        let (x, y, z) = data.measurement.gyro?.into();
        let mut angular = Vector3::new(x, y, -z);

        angular.iter_mut().for_each(|v| {
            if v.abs() < config.gyro_noise_level {
                *v = 0.0
            }
        });

        if let Some((time, prev)) = state.prev_angular.as_ref() {
            if let Ok(elapsed) =
                data.time_marker.as_time().duration_since(*time)
            {
                if elapsed <= config.data_lifetime {
                    angular = config.gyro_smoothing_level * angular
                        + (1.0 - config.gyro_smoothing_level) * prev;
                } else {
                    log::debug!("Invalid lifetime for imu data");
                }
            }
        }

        state.prev_angular = (data.time_marker.as_time(), angular).into();

        angular
    };

    let data = SensorData::new((accel, gyro), SystemTime::now());

    Some(SensorEvent::Imu(data))
}

==> ./devices/lidar.rs <==
use std::{ops::DerefMut, time::SystemTime};

use nalgebra::Point2;
use roboq_types::{
    devices::{lidar::LidarScan2D, DeviceId},
    model::{
        debug::AlgoKind,
        localization::{LidarSensorConfig, MatchingAlgorithm, RobotState},
        pose::{MapPoint, Pose2D},
    },
};

use crate::{
    correlative_scan_matching::localized_range_scan::LocalizedRangeScan,
    debug::DebugData,
    devices::scan_transform::ScanTransform,
    icp::{
        icp_slam::IcpSlamConfig, icp_svd::point_cloud_from_lidar_scan_deskew,
    },
    shared_data::SharedData,
};

#[cfg(feature = "debug")]
use crate::debug::DebugSender;

pub struct LidarSharedData<'a> {
    pub id: DeviceId,
    pub runtime_data: &'a SharedData,
    pub slam_config: &'a IcpSlamConfig,
    pub sensor_config: &'a LidarSensorConfig,

    #[cfg(feature = "debug")]
    pub debug_tx: DebugSender,
}

impl LidarSharedData<'_> {
    pub fn state(&self) -> RobotState {
        self.runtime_data
            .motion_estimation
            .write()
            .unwrap()
            .get_estimated_state_unchecked()
    }
}

// this thing is top level handler, and the we are processing it
pub fn handle(scan: &LidarScan2D, data: LidarSharedData) -> Option<Pose2D> {
    if scan.points.len() < 5 {
        return None;
    }

    let mut robot_state = data.state();

    //set robot position at lidar position
    robot_state.position = robot_state.position.translate_pose(scan.offset);

    let mut localized_scan =
        build_localized_scan(scan, &robot_state, data.sensor_config);

    let _ = data.debug_tx.try_send(DebugData::new_localized_scan(
        data.id,
        &localized_scan.points,
    ));

    if data.sensor_config.use_clusterization {
        let max_distance = *data.sensor_config.max_cluster_dist;
        let min_points_count = data.sensor_config.min_cluster_size;

        let time = std::time::Instant::now();

        let input = localized_scan
            .points
            .iter()
            .map(|p| vec![p.x, p.y])
            .collect();

        let model =
            dbscan::Model::<f32>::new(max_distance as f64, min_points_count);

        let classes = model.run(&input);

        let _ = data
            .debug_tx
            .try_send(DebugData::new_algo(AlgoKind::DbScan, time.elapsed()));

        log::trace!("Was {}", localized_scan.points.len());

        localized_scan.points = input
            .into_iter()
            .enumerate()
            .filter_map(|(index, p)| {
                if classes[index] != dbscan::Classification::Noise {
                    Some(Point2::new(p[0], p[1]))
                } else {
                    None
                }
            })
            .collect::<Vec<_>>();

        log::trace!("Will {}", localized_scan.points.len());
    }

    if localized_scan.points.is_empty() {
        log::debug!("dbscan removed all points");
        return None;
    }

    let mut new_points: Vec<Point2<f32>> =
        Vec::with_capacity(localized_scan.points.len());

    let filter_sq = data.sensor_config.filter_distance.powi(2);

    for point in &localized_scan.points {
        let can_add = !new_points
            .iter()
            .any(|p| (point - p).norm_squared() < filter_sq);

        if can_add {
            new_points.push(*point);
        }
    }

    localized_scan.points = new_points;

    data.runtime_data
        .scan_history
        .write()
        .unwrap()
        .add_raw_scan(data.id, localized_scan.clone());

    if data.sensor_config.use_scan_history {
        let other_scan_points = data
            .runtime_data
            .scan_history
            .read()
            .unwrap()
            .latest()
            .filter(|&(id, _scan, time)| {
                let lifetime = SystemTime::now()
                    .duration_since(time)
                    .unwrap_or(data.sensor_config.max_lifetime);

                (id != data.id) && (lifetime < data.sensor_config.max_lifetime)
            })
            .flat_map(|(_id, scan, _time)| scan.points.iter())
            .copied()
            .collect::<Vec<MapPoint>>();

        localized_scan.points.extend_from_slice(&other_scan_points);
    }

    let matched_scan = match data.slam_config.match_kind {
        MatchingAlgorithm::Svd => ScanTransform::new_svd(
            localized_scan,
            data.slam_config,
            data.runtime_data,
        )
        .set_debug(data.debug_tx)
        .match_scan(),

        MatchingAlgorithm::Csm => ScanTransform::new_csm(
            localized_scan,
            data.slam_config,
            data.runtime_data,
        )
        .set_debug(data.debug_tx)
        .match_scan(),
    };

    let matched_pose = matched_scan.pose;

    data.runtime_data
        .scan_history
        .write()
        .unwrap()
        .deref_mut()
        .add_matched_scan(matched_scan);

    Some(matched_pose.untranslate_pose(scan.offset))
}

pub fn build_localized_scan(
    scan: &LidarScan2D,
    robot_state: &RobotState,
    config: &LidarSensorConfig,
) -> LocalizedRangeScan {
    let deskewed_scan = point_cloud_from_lidar_scan_deskew(
        scan,
        config.scan_duration,
        &robot_state.velocity,
        config.deskew_scan,
        config.ignore_distance_mm,
    );

    LocalizedRangeScan::cloud_at_position(deskewed_scan, robot_state.position)
}

==> ./devices/mod.rs <==
#[cfg(feature = "compass")]
pub mod compass;
#[cfg(feature = "gps")]
pub mod gps;
#[cfg(feature = "imu")]
pub mod imu;
#[cfg(feature = "lidar")]
pub mod lidar;

#[cfg(feature = "rt")]
mod scan_transform;

pub use roboq_types::devices::{
    gps::GpsData, imu::ImuData, lidar::LidarScan2D, motor::Odometry, DeviceId,
};

use roboq_types::devices::camera::StereoScan2D;

#[cfg(feature = "lidar")]
#[cfg(feature = "rt")]
pub use lidar::build_localized_scan;

#[derive(Debug, Clone)]
pub struct DeviceFeedback {
    pub id: DeviceId,
}

#[derive(Clone)]
pub struct DeviceMessage {
    pub id: DeviceId,
    pub data: DeviceData,
}

#[derive(Clone)]
pub enum DeviceData {
    LidarScanOffset(LidarScan2D),
    MotorOdometry(Odometry),
    Gps(GpsData),
    Imu(ImuData),
    //angle in rad to north from heading
    //clock wise
    Compass(f32),
    StereoScan(StereoScan2D),
}

/// This method is supposed to be non-blocking
/// Access to config is supposed to be non-blocking call (because any read | write access is moment
/// action)
/// Each access to shared data should be considered as non-blocking call
#[cfg(feature = "rt")]
pub fn handle_data(
    shared_data: crate::shared_data::RuntimeData,

    debug_tx: crate::debug::DebugSender,
    event_tx: crate::pipeline::Sender<(
        DeviceMessage,
        roboq_types::model::localization::SensorEvent,
    )>,
    msg: DeviceMessage,
) {
    use lidar::LidarSharedData;

    use roboq_types::model::localization::SensorData;
    use roboq_types::model::localization::SensorEvent;

    let DeviceMessage { data, id } = msg.clone();

    match data {
        crate::devices::DeviceData::LidarScanOffset(scan) => {
            #[cfg(feature = "lidar")]
            {
                rayon::spawn(move || {
                    let config_lock = shared_data.config();

                    let config = config_lock.blocking_read();

                    let sensor_config = config.devices_config.lidar.clone();
                    let slam_config = {
                        let mut base_config = config.icp_slam_config.clone();
                        let matching_config = config.matching_config.clone();

                        base_config
                            .update_icp_config(matching_config.default_icp);
                        base_config.match_kind =
                            matching_config.default_algorithm;
                        base_config.add_points_maximum_distance =
                            sensor_config.add_distance;

                        base_config
                    };

                    drop(config);

                    let data = LidarSharedData {
                        id,
                        runtime_data: &shared_data,
                        slam_config: &slam_config,
                        sensor_config: &sensor_config,
                        debug_tx,
                    };

                    let Some(matched_pose) = lidar::handle(&scan, data) else {
                        return;
                    };

                    let data = SensorData::new(matched_pose, scan.get_time());
                    let _ = event_tx
                        .blocking_send((msg, SensorEvent::MatchedPose(data)));
                });
            }
        }
        crate::devices::DeviceData::MotorOdometry(_odometry) => {}
        crate::devices::DeviceData::Gps(data) => {
            #[cfg(feature = "gps")]
            {
                rayon::spawn(move || {
                    let Some(event) = gps::handle(data, &shared_data) else {
                        return;
                    };
                    let _ = event_tx.blocking_send((msg, event));
                });
            }
        }
        crate::devices::DeviceData::Imu(data) => {
            rayon::spawn(move || {
                let config = {
                    let config_lock = shared_data.config();

                    let imu =
                        config_lock.blocking_read().devices_config.imu.clone();

                    imu
                };

                let mut history = shared_data.imu_history.write().unwrap();

                let Some(event) = imu::handle(data, &config, &mut history)
                else {
                    return;
                };

                drop(history);

                let _ = event_tx.blocking_send((msg, event));
            });
        }
        crate::devices::DeviceData::Compass(angle) => {
            #[cfg(feature = "compass")]
            {
                rayon::spawn(move || {
                    let Some(event) = compass::handle(&shared_data, angle)
                    else {
                        return;
                    };

                    let _ = event_tx.blocking_send((msg, event));
                });
            }
        }
        DeviceData::StereoScan(scan) => {
            rayon::spawn(move || {
                let has_collision =
                    scan.into_points().into_iter().any(|p| p.distance == 0.0);

                shared_data.set_stereo_collision(has_collision);
            });
            //todo: process stereo scan as regular lidar scan
        }
    }
}

#[cfg(feature = "rt")]
pub fn handle_unreliable_data(
    message: DeviceMessage,
    shared_data: crate::shared_data::RuntimeData,
    debug_tx: crate::debug::DebugSender,
) {
    use lidar::LidarSharedData;

    use crate::devices;

    rayon::spawn(move || {
        if shared_data.try_enable_sync().is_err() {
            return;
        }

        match message.data {
            DeviceData::LidarScanOffset(scan) => {
                let config_lock = shared_data.config();
                let config = config_lock.blocking_read();

                let sensor_config = config.devices_config.lidar.clone();
                let slam_config = {
                    let mut base_config = config.icp_slam_config.clone();
                    let matching_config = config.matching_config.clone();

                    drop(config);

                    base_config.update_icp_config(matching_config.reliable_icp);
                    base_config.match_kind = matching_config.reliable_algorithm;
                    base_config.add_points_maximum_distance =
                        sensor_config.add_distance;

                    base_config
                };

                let data = LidarSharedData {
                    id: message.id,
                    runtime_data: &shared_data,
                    slam_config: &slam_config,
                    sensor_config: &sensor_config,
                    debug_tx,
                };

                let Some(pose) = devices::lidar::handle(&scan, data) else {
                    shared_data.disable_sync();
                    return;
                };

                shared_data
                    .motion_estimation
                    .write()
                    .unwrap()
                    .reset_with_position(pose);

                shared_data.disable_sync();
            }
            _ => {
                shared_data.disable_sync();
                //ignore any data
            }
        }
    });
}

==> ./devices/scan_transform.rs <==
use std::{marker::PhantomData, time::Instant};

use nalgebra::{IsometryMatrix2, Point2};
use roboq_types::model::{debug::AlgoKind, pose::Pose2D};

use crate::{
    correlative_scan_matching::localized_range_scan::LocalizedRangeScan,
    debug::DebugData,
    icp::{
        icp_slam::IcpSlamConfig,
        icp_svd::{match_points_cloud_with_kdtree, PointCloud},
    },
    model::{
        big_map::MapChunk,
        kd_tree::{points_to_kdtree, Point2Kd},
        point_cloud_grid::PointCloudExt,
    },
    SharedData,
};

#[cfg(feature = "debug")]
use crate::debug::DebugSender;

pub struct Svd;
pub struct Csm;

/// Used to estimate the estimated position
/// during scan localization
pub struct ScanTransform<'a, ALGO> {
    config: &'a IcpSlamConfig,
    shared_data: &'a SharedData,
    scan: LocalizedRangeScan,
    map_chunk: MapChunk,
    //corresponding scans for devices
    #[cfg(feature = "debug")]
    debug_tx: Option<crate::debug::DebugSender>,
    _marker: PhantomData<ALGO>,
}

impl<'a> ScanTransform<'a, Svd> {
    pub fn new_svd(
        scan: LocalizedRangeScan,
        config: &'a IcpSlamConfig,
        shared_data: &'a SharedData,
    ) -> Self {
        Self::new(scan, config, shared_data)
    }

    pub fn match_scan(self) -> LocalizedRangeScan {
        let map_points = self.map_chunk.get_points();

        if map_points.len() < 5 {
            // not enought points in map to perform matching
            return self.post_process(None);
        }

        let start = Instant::now();

        let kd_tree = points_to_kdtree(&map_points);

        let (transform, point_cloud) = match_points_cloud_with_kdtree(
            &self.config.into(),
            self.scan.points.clone(),
            &kd_tree,
        );

        if let Some(ref debugger) = self.debug_tx {
            let _ = debugger
                .try_send(DebugData::new_algo(AlgoKind::Svd, start.elapsed()));
        }

        let matched_scan = self.new_matched_scan(transform, point_cloud);

        self.post_process(matched_scan.into())
    }
}

impl<'a> ScanTransform<'a, Csm> {
    pub fn new_csm(
        scan: LocalizedRangeScan,
        config: &'a IcpSlamConfig,
        shared_data: &'a SharedData,
    ) -> Self {
        Self::new(scan, config, shared_data)
    }

    pub fn match_scan(self) -> LocalizedRangeScan {
        let start = Instant::now();

        // let set_of_scans = [self.scan.clone()];

        let new_pose = {
            let mut csm =
                self.shared_data.correlative_scan_matching.write().unwrap();

            let set_of_scans =
                self.shared_data.scan_history.read().unwrap().clone();

            csm.match_scan_against_set_of_scans(&self.scan, set_of_scans.iter())
        };

        let transform =
            new_pose.as_isometry() * self.scan.pose.as_isometry().inverse();

        let point_cloud = self
            .scan
            .points
            .iter()
            .map(|point| transform * point)
            .collect();

        if let Some(ref debugger) = self.debug_tx {
            let _ = debugger
                .try_send(DebugData::new_algo(AlgoKind::Csm, start.elapsed()));
        }

        let matched_scan = self.new_matched_scan(transform, point_cloud);

        self.post_process(matched_scan.into())
    }
}

impl<'a, T> ScanTransform<'a, T> {
    fn new(
        scan: LocalizedRangeScan,
        config: &'a IcpSlamConfig,
        shared_data: &'a SharedData,
    ) -> Self {
        assert!(
            !scan.points.is_empty(),
            "Only not empty scan should be used"
        );

        let map_chunk = {
            let point_cloud = PointCloudExt::from_points_with_center(
                &scan.points,
                scan.pose.coords,
            );

            let mut big_map = shared_data.big_map.write().unwrap();

            big_map.get_chunk_at(
                point_cloud.center,
                (1.3 * point_cloud.radius).into(),
            )
        };

        Self {
            config,
            shared_data,

            scan,
            map_chunk,

            debug_tx: None,
            _marker: PhantomData,
        }
    }

    #[cfg(feature = "debug")]
    pub fn set_debug(mut self, debug_tx: DebugSender) -> Self {
        self.debug_tx = Some(debug_tx);

        self
    }

    fn new_matched_scan(
        &self,
        transform: IsometryMatrix2<f32>,
        point_cloud: PointCloud,
    ) -> LocalizedRangeScan {
        let next_robot_pos =
            Pose2D::from_isometry(transform * self.scan.pose.as_isometry());

        if (next_robot_pos - self.scan.pose).translation.norm() > 10.0 {
            //there is not needs to build new scan
            //because we at the same place
            self.scan.clone()
        } else {
            LocalizedRangeScan {
                points: point_cloud,
                pose: next_robot_pos,
            }
        }
    }

    fn post_process(
        self,
        matched_scan: Option<LocalizedRangeScan>,
    ) -> LocalizedRangeScan {
        let matched_scan = matched_scan.unwrap_or(self.scan);

        let update_point_cloud;
        let maybe_last_pose = *self.shared_data.last_added_pose.read().unwrap();

        if let Some(last_pose) = maybe_last_pose {
            update_point_cloud = (matched_scan.pose.coords - last_pose.coords)
                .magnitude()
                > *self.config.move_threshold_for_adding_points;
        } else {
            update_point_cloud = true;
        }

        let start = Instant::now();

        if self.config.updating_map {
            *self.shared_data.last_added_pose.write().unwrap() =
                Some(matched_scan.pose);

            update_map(
                &matched_scan,
                self.config,
                update_point_cloud,
                &self.map_chunk,
            );

            self.shared_data.on_update_map();
        }

        let end = start.elapsed();
        log::trace!("Map update time: {end:?}");

        matched_scan
    }
}

/// Update the contents of the map (Occupation Grid and ground truth points)
/// according to the degree of sparsity of points
/// If the points are sufficiently removed, they will be added
fn update_map(
    localized_scan: &LocalizedRangeScan,
    config: &IcpSlamConfig,
    update_point_cloud: bool,
    chunk: &MapChunk,
) {
    chunk.raycast_scan(localized_scan);

    if update_point_cloud {
        let points = chunk.get_points();

        if !points.is_empty() {
            let kd_tree = points_to_kdtree(&points);
            let range_limit_sq = config.add_points_maximum_distance.powi(2);

            let points_to_add: Vec<_> = localized_scan
                .points
                .clone()
                .into_iter()
                .filter(|point| {
                    let point = *point;
                    let kd_point: Point2Kd = point.into();
                    let nearest_point: Point2<f32> =
                        kd_tree.nearest_search(&kd_point).into();
                    (point - nearest_point).magnitude_squared() > range_limit_sq
                })
                .collect();

            chunk.add_points(&points_to_add);
        } else {
            chunk.add_points(&localized_scan.points);
        }
    }

    chunk.filter_points();
}

==> ./filter/error.rs <==
use nalgebra::DMatrix;
use thiserror::Error;

#[derive(Debug, Error)]
pub enum MathError {
    #[error("Provided covariance matrix is not positive defined")]
    CholeskyFailed(DMatrix<f32>),
    #[error("Failed to find inverse matrix for meas covariance")]
    NoInverseMatrix,
    #[error("Data type is not supported")]
    NotSupportedData,

    #[error("The covariance is not positively defined")]
    NotPositiveCovariance,
}

==> ./filter/imu.rs <==
#![allow(unused)]

use nalgebra::{
    Const, Dyn, OMatrix, SMatrix, SMatrixView, SVector, UnitQuaternion, Vector3,
};
use roboq_types::model::localization::{AhrsFilter, RobotState};

use crate::{
    filter::{noise, PredictionConfig},
    localization::NoiseConfig,
    model::normalize_angle,
};

use super::{sigma_order, KallmanFilter, MathError, UpdateConfig};

const VAR_NAME: usize = 0;
pub const THETA: usize = VAR_NAME;
pub const V_THETA: usize = 1;

pub const AHRS_THETA: usize = 0;
pub const GYRO_V_THETA: usize = 1;

pub const STATE_SIZE: usize = 2;
pub const MEASUREMENT_SIZE: usize = 2;
pub const SIGMA_ORDER: usize = sigma_order(STATE_SIZE);

//theta, v_theta

//heading, gyro
#[derive(Debug)]
pub struct ImuFilter {
    pub filter: KallmanFilter<STATE_SIZE, MEASUREMENT_SIZE, SIGMA_ORDER>,
    pub state: State,
}

#[derive(Default, Debug)]
pub struct State {
    pub theta: f32,
    pub v_theta: f32,
}

impl ImuFilter {
    pub fn new(
        sampling_dt: f32,
        state: &RobotState,
        noise: &NoiseConfig,
    ) -> Self {
        let mut filter =
            KallmanFilter::<STATE_SIZE, MEASUREMENT_SIZE, SIGMA_ORDER>::new();
        // let state_matrix: SMatrix<f32, 1, STATE_SIZE> =
        filter.state = SVector::<f32, STATE_SIZE>::from_row_slice(&[
            state.position.heading_rad,
            state.velocity.angular,
        ])
        .transpose();

        filter
            .state_noise
            .copy_from(&noise::discrete_white::<2, 1, 2>(
                sampling_dt,
                noise.state_heading,
            ));

        filter
            .meas_noise
            .copy_from(&meas_matrix(noise.gyro, noise.ahrs_heading));

        filter.covariance.scale_mut(0.5);

        Self {
            filter,
            state: Default::default(),
        }
    }

    pub fn state(&self) -> State {
        State {
            theta: self.filter.state[THETA],
            v_theta: self.filter.state[V_THETA],
        }
    }

    #[rustfmt::skip] pub fn predict(&mut self, _dt: f32) -> Result<(), MathError> {
        // let transform =
        //     SMatrix::<f32, STATE_SIZE, STATE_SIZE>::from_row_slice(&[
        //         1.0, dt, 
        //         0.0, 1.0,
        //     ]);
        //
        // let next_state_fn =
        //     move |prev_state: SMatrixView<f32, 1, STATE_SIZE>| {
        //         let next_state = transform * prev_state.transpose();
        //
        //         next_state.transpose()
        //     };
        //
        // self.filter.predict(PredictionConfig {
        //     next_state: next_state_fn,
        //     mean_transform: state_mean,
        //     state_sub: state_residual,
        // })?;

        Ok(())
    }

    pub fn update(
        &mut self,
        dt: f32,
        ahrs: AhrsFilter,
        noise: &NoiseConfig,
        gyro: Vector3<f32>,
    ) -> Result<(), MathError> {
        let mut indices = Vec::<usize>::new();
        let mut meas_matrix = SVector::<f32, MEASUREMENT_SIZE>::zeros();

        let ahrs_theta = match ahrs {
            AhrsFilter::Linear => None,

            AhrsFilter::Madgwick => {
                let heading = self.filter.state[THETA];
                let quat = UnitQuaternion::from_euler_angles(0.0, 0.0, heading);

                let mut filter =
                    ahrs::Madgwick::new_with_quat(dt, noise.ahrs_beta, quat);

                let quat = *ahrs::Ahrs::update_gyro(&mut filter, &gyro);

                let (_roll, _pith, yaw) = quat.euler_angles();

                yaw.into()
            }

            AhrsFilter::Mahagony => {
                let heading = self.filter.state[THETA];
                let quat = UnitQuaternion::from_euler_angles(0.0, 0.0, heading);

                let mut filter = ahrs::Mahony::new_with_quat(
                    dt,
                    noise.ahrs_alpha,
                    noise.ahrs_beta,
                    quat,
                );

                let quat = *ahrs::Ahrs::update_gyro(&mut filter, &gyro);

                let (_roll, _pith, yaw) = quat.euler_angles();

                yaw.into()
            }
        };

        if let Some(theta) = ahrs_theta {
            indices.push(AHRS_THETA);
            meas_matrix[AHRS_THETA] = theta;
        }

        meas_matrix[GYRO_V_THETA] = gyro.z;
        indices.push(GYRO_V_THETA);

        let _transform = build_dyn_transform(&indices);

        // self.filter.update(
        //     &meas_matrix.transpose(),
        //     Some(transform),
        //     UpdateConfig {
        //         state_to_meas,
        //         mean_transform: meas_mean,
        //         meas_sub: meas_residual,
        //         state_sub: state_residual,
        //     },
        // )?;

        self.state.theta = ahrs_theta.unwrap();
        self.state.v_theta = gyro.z;

        Ok(())
    }
}

fn state_residual<const N: usize>(
    s1: SMatrixView<f32, 1, N>,
    s2: SMatrixView<f32, 1, N>,
) -> SMatrix<f32, 1, N> {
    let mut s = s1 - s2;

    s[THETA] = normalize_angle(s[THETA]);

    s
}

pub fn meas_matrix(
    gyro_noise: f32,
    ahrs_heading: f32,
) -> SMatrix<f32, MEASUREMENT_SIZE, MEASUREMENT_SIZE> {
    let diag = SVector::from_row_slice(&[ahrs_heading, gyro_noise]);

    SMatrix::from_diagonal(&diag)
}

pub fn state_to_meas(
    state: SMatrixView<f32, 1, STATE_SIZE>,
) -> SMatrix<f32, 1, MEASUREMENT_SIZE> {
    SMatrix::from_column_slice(&[state[THETA], state[V_THETA]])
}

fn build_dyn_transform(
    indices: &[usize],
) -> OMatrix<f32, Dyn, Const<MEASUREMENT_SIZE>> {
    let mut matrix =
        OMatrix::<f32, Dyn, Const<MEASUREMENT_SIZE>>::zeros(indices.len());

    for (col_i, row_i) in indices.iter().enumerate() {
        matrix[(col_i, *row_i)] = 1.0;
    }

    matrix
}

fn meas_mean(
    weights: SMatrixView<f32, 1, SIGMA_ORDER>,
    sigmas: SMatrixView<f32, SIGMA_ORDER, MEASUREMENT_SIZE>,
) -> SMatrix<f32, 1, MEASUREMENT_SIZE> {
    let column = sigmas.column(AHRS_THETA).transpose();

    let sum_sin = weights.dot(&column.map(f32::sin));
    let sum_cos = weights.dot(&column.map(f32::cos));

    let ahrs_theta = f32::atan2(sum_sin, sum_cos);

    let gyro_v_theta = weights.dot(&sigmas.column(GYRO_V_THETA).transpose());

    SMatrix::from_row_slice(&[ahrs_theta, gyro_v_theta])
}

fn meas_residual(
    m1: SMatrixView<f32, 1, MEASUREMENT_SIZE>,
    m2: SMatrixView<f32, 1, MEASUREMENT_SIZE>,
) -> SMatrix<f32, 1, MEASUREMENT_SIZE> {
    let mut m = m1 - m2;

    m[AHRS_THETA] = normalize_angle(m[AHRS_THETA]);

    m
}

fn state_mean(
    weights: SMatrixView<f32, 1, SIGMA_ORDER>,
    sigmas: SMatrixView<f32, SIGMA_ORDER, STATE_SIZE>,
) -> SMatrix<f32, 1, STATE_SIZE> {
    let theta = {
        let column = sigmas.column(THETA).transpose();

        let sum_sin = weights.dot(&column.map(f32::sin));
        let sum_cos = weights.dot(&column.map(f32::cos));
        f32::atan2(sum_sin, sum_cos)
    };

    let v_theta = weights.dot(&sigmas.column(V_THETA).transpose());

    SMatrix::from_row_slice(&[theta, v_theta])
}

==> ./filter/mod.rs <==
mod error;
mod imu;
pub mod noise;
mod sigma_points;
mod state;
mod unscented;

use nalgebra::{Const, Dyn, OMatrix, SMatrix, SMatrixView};

pub use error::*;
pub use imu::ImuFilter;
pub use sigma_points::{
    estimate_merwe_sigmas, estimate_merwe_weights, sigma_order, SigmaMetadata,
    SigmaWeights,
};
pub use state::*;

pub use unscented::{
    mean, residual, KallmanFilter, PredictionConfig, UpdateConfig,
};

pub trait FnState<const N: usize>:
    Fn(SMatrixView<f32, 1, N>) -> SMatrix<f32, 1, N>
{
}

impl<T, const N: usize> FnState<N> for T where
    T: Fn(SMatrixView<f32, 1, N>) -> SMatrix<f32, 1, N>
{
}

pub trait FnMeasurement<const N: usize, const K: usize>:
    Fn(SMatrixView<f32, 1, N>) -> SMatrix<f32, 1, K>
{
}

impl<T, const N: usize, const K: usize> FnMeasurement<N, K> for T where
    T: Fn(SMatrixView<f32, 1, N>) -> SMatrix<f32, 1, K>
{
}

pub trait FnDistance<const N: usize>:
    Fn(SMatrixView<f32, 1, N>, SMatrixView<f32, 1, N>) -> SMatrix<f32, 1, N>
{
}

impl<T, const N: usize> FnDistance<N> for T where
    T: Fn(SMatrixView<f32, 1, N>, SMatrixView<f32, 1, N>) -> SMatrix<f32, 1, N>
{
}

pub trait FnMean<const N: usize, const S: usize>:
    Fn(SMatrixView<f32, 1, S>, SMatrixView<f32, S, N>) -> SMatrix<f32, 1, N>
{
}

impl<T, const N: usize, const S: usize> FnMean<N, S> for T where
    T: Fn(SMatrixView<f32, 1, S>, SMatrixView<f32, S, N>) -> SMatrix<f32, 1, N>
{
}

//specially for dynamically sized measurements
pub trait FnMeanDyn<const N: usize, const S: usize>:
    Fn(
    SMatrixView<f32, 1, S>,
    SMatrixView<f32, S, N>,
) -> OMatrix<f32, Const<1>, Dyn>
{
}

impl<T, const N: usize, const S: usize> FnMeanDyn<N, S> for T where
    T: Fn(
        SMatrixView<f32, 1, S>,
        SMatrixView<f32, S, N>,
    ) -> OMatrix<f32, Const<1>, Dyn>
{
}

==> ./filter/noise.rs <==
use nalgebra::SMatrix;

/// N - the count of state variable
/// K - the count of derivations per block (i.e. x, x', x''). By another words, block size
/// S - output matrix size (N * K)
pub fn discrete_white<const N: usize, const K: usize, const S: usize>(
    dt: f32,
    base_var: f32,
) -> SMatrix<f32, S, S> {
    assert!(S == N * K);
    let noise_matrix = match N {
        2 => {
            SMatrix::<f32, N, N>::from_column_slice(&[
                //first column
                0.25 * dt.powi(4),
                0.5 * dt.powi(3),
                //second column
                0.5 * dt.powi(3),
                dt.powi(2),
            ])
        }
        3 => {
            SMatrix::<f32, N, N>::from_column_slice(&[
                //first column
                0.25 * dt.powi(4),
                0.5 * dt.powi(3),
                0.5 * dt.powi(2),
                //second column
                0.5 * dt.powi(3),
                dt.powi(2),
                dt,
                //third column
                0.5 * dt.powi(2),
                dt,
                1.0,
            ])
        }
        4 => {
            SMatrix::<f32, N, N>::from_column_slice(&[
                //first column
                dt.powi(6) / 36.0,
                dt.powi(5) / 12.0,
                dt.powi(4) / 6.0,
                dt.powi(3) / 6.0,
                //second column
                dt.powi(5) / 12.0,
                dt.powi(4) / 4.0,
                dt.powi(3) / 2.0,
                dt.powi(2) / 2.0,
                //third column
                dt.powi(4) / 6.0,
                dt.powi(3) / 2.0,
                dt.powi(2),
                dt,
                //fourth column
                dt.powi(3) / 6.0,
                dt.powi(2) / 2.0,
                dt,
                1.0,
            ])
        }
        _ => {
            unreachable!("Invalid dimmensions");
        }
    };
    order_by_derivative::<N, K, S>(noise_matrix) * base_var
}

/// Given a matrix Q, ordered assuming state space
///        `[x y z x' y' z' x'' y'' z''...]`
///
///    return a reordered matrix assuming an ordering of
///       `[ x x' x'' y y' y'' z z' y'']`
///
///    This works for any covariance matrix or state transition function
fn order_by_derivative<const N: usize, const K: usize, const S: usize>(
    raw_matrix: SMatrix<f32, N, N>,
) -> SMatrix<f32, S, S> {
    assert!(S == N * K);

    let mut matrix = SMatrix::<f32, S, S>::zeros();
    for (index, value) in raw_matrix.iter().enumerate() {
        let mut eye = SMatrix::<f32, K, K>::identity();
        eye.scale_mut(*value);

        let first_row = index / N * K;
        let first_column = index % N * K;

        let mut view = matrix.view_range_mut(
            first_row..first_row + K,
            first_column..first_column + K,
        );
        view.copy_from(&eye);
    }
    matrix
}

==> ./filter/sigma_points.rs <==
use nalgebra::{Cholesky, DMatrix, SMatrix, SMatrixView, SVector};
use serde::{Deserialize, Serialize};

use super::{FnDistance, MathError};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum SigmaPointsType {
    #[serde(other)]
    Merwe,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SigmaWeights<const S: usize> {
    pub covariance: SMatrix<f32, 1, S>,
    pub mean: SMatrix<f32, 1, S>,

    /// number of sigma-points for each state
    pub sigma_order: usize,
    /// metadata by which weights were built
    pub metadata: SigmaMetadata,
    /// generation strategy
    points_type: SigmaPointsType,
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub struct SigmaMetadata {
    pub alpha: f32,
    pub beta: f32,
    pub kappa: f32,
}

impl Default for SigmaMetadata {
    fn default() -> Self {
        Self {
            alpha: 0.1,
            beta: 2.0,
            kappa: -1.0,
        }
    }
}

pub const fn sigma_order(state_size: usize) -> usize {
    2 * state_size + 1
}

pub fn estimate_merwe_weights<const N: usize, const S: usize>(
    metadata: SigmaMetadata,
) -> SigmaWeights<S> {
    assert!(S == sigma_order(N));

    let SigmaMetadata { alpha, beta, kappa } = metadata;

    let n = N as f32;

    let lambda = (alpha * alpha) * (n + kappa) - n;
    let c = 0.5 / (n + lambda);
    let mut w_m = vec![c; S];
    let mut w_c = vec![c; S];
    w_c[0] = lambda / (n + lambda) + (1.0 - alpha * alpha + beta);
    w_m[0] = lambda / (n + lambda);

    SigmaWeights {
        covariance: SVector::<f32, S>::from_vec(w_c).transpose(),
        mean: SVector::<f32, S>::from_vec(w_m).transpose(),
        sigma_order: S,
        metadata,
        points_type: SigmaPointsType::Merwe,
    }
}

pub fn estimate_merwe_sigmas<const S: usize, const N: usize, D>(
    state: SMatrixView<f32, 1, N>,
    covariance: SMatrixView<f32, N, N>,
    metadata: SigmaMetadata,
    distance_of: &D,
) -> Result<SMatrix<f32, S, N>, MathError>
where
    D: FnDistance<N>,
{
    let SigmaMetadata { alpha, kappa, .. } = metadata;

    let mean_estimations = {
        let state_size = N as f32;
        let lambda = alpha.powi(2) * (state_size + kappa) - state_size;
        let matrix = covariance.scale(lambda + state_size);
        let matrix = matrix.symmetric_part() + SMatrix::identity() * 0.0001;
        let Some(cholesky) = Cholesky::new(matrix) else {
            let dmatrix = DMatrix::from_iterator(
                matrix.nrows(),
                matrix.ncols(),
                matrix.iter().copied(),
            );

            return Err(MathError::CholeskyFailed(dmatrix));
        };
        cholesky.l()
    };

    let mut sigmas = SMatrix::<f32, S, N>::zeros();
    sigmas.row_mut(0).copy_from(&state);

    for i in 0..state.len() {
        let mean_estimation = mean_estimations.column(i).transpose();

        sigmas
            .row_mut(i + 1)
            .copy_from(&distance_of(state, (-1.0 * mean_estimation).as_view()));

        sigmas
            .row_mut(N + i + 1)
            .copy_from(&distance_of(state, (1.0 * mean_estimation).as_view()));
    }

    Ok(sigmas)
}

==> ./filter/state.rs <==
use std::{marker::PhantomData, time::SystemTime};

use nalgebra::SMatrix;
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct FilterState<const N: usize, const K: usize, const S: usize> {
    /// X
    pub state: SMatrix<f32, 1, N>,
    /// P
    pub covariance: SMatrix<f32, N, N>,
    /// R
    pub meas_noise: SMatrix<f32, K, K>,

    pub timestamp: SystemTime,
    pub(crate) _marker: PhantomData<[f32; S]>,
}

impl<const N: usize, const K: usize, const S: usize> PartialOrd
    for FilterState<N, K, S>
{
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        self.timestamp.partial_cmp(&other.timestamp)
    }
}

==> ./filter/unscented.rs <==
use std::time::SystemTime;

use nalgebra::{
    Cholesky, Const, DMatrix, DMatrixView, DVector, DVectorView, Dyn, OMatrix,
    SMatrix, SMatrixView,
};
use serde::{Deserialize, Serialize};

use crate::filter::{sigma_order, sigma_points};

use super::{
    estimate_merwe_sigmas, FilterState, FnDistance, FnMean, FnMeasurement,
    FnState, MathError, SigmaWeights,
};

#[allow(unused)]
pub fn residual<const N: usize>(
    x: SMatrixView<f32, 1, N>,
    y: SMatrixView<f32, 1, N>,
) -> SMatrix<f32, 1, N> {
    x - y
}

#[allow(unused)]
pub fn mean<const N: usize, const S: usize>(
    weights: SMatrixView<f32, 1, S>,
    sigmas: SMatrixView<f32, S, N>,
) -> SMatrix<f32, 1, N> {
    weights * sigmas
}

#[allow(unused)]
pub fn identity_state<const N: usize>(
    view: SMatrixView<f32, 1, N>,
) -> SMatrix<f32, 1, N> {
    view.clone_owned()
}

#[allow(unused)]
pub fn zeros_measurement<const N: usize, const K: usize>(
    _state: SMatrixView<f32, 1, N>,
) -> SMatrix<f32, 1, K> {
    SMatrix::zeros()
}

pub fn identity_transform<const N: usize>() -> OMatrix<f32, Dyn, Const<N>> {
    OMatrix::<f32, Dyn, Const<N>>::identity(N)
}

pub fn transform_dyn<T, F, const N: usize, const S: usize>(
    sigmas: &SMatrix<f32, S, N>,
    weights: &SigmaWeights<S>,
    noise_opt: Option<SMatrixView<f32, N, N>>,
    dyn_transform: DMatrixView<f32>,
    residual: &T,
    mean: &F,
) -> (SMatrix<f32, 1, N>, OMatrix<f32, Dyn, Dyn>)
where
    T: FnDistance<N>,
    F: FnMean<N, S>,
{
    assert!(dyn_transform.ncols() == N);

    let state = mean(weights.mean.as_view(), sigmas.as_view());

    let mut covariance =
        DMatrix::zeros(dyn_transform.nrows(), dyn_transform.nrows());

    if let Some(raw_noise) = noise_opt {
        let noise = {
            let diag = dyn_transform * raw_noise.diagonal();
            DMatrix::from_diagonal(&diag)
        };
        //assert noise is diagonal matrix
        covariance += noise;
    }

    let apply_dyn_transform = move |state: SMatrixView<f32, 1, N>| {
        (dyn_transform * state.transpose()).transpose()
    };

    for i in 0..S {
        let row = sigmas.row(i).clone_owned();

        let y = {
            let raw_y = residual(row.as_view(), state.as_view());
            apply_dyn_transform(raw_y.as_view())
        };

        let mut outer = y.transpose() * y;
        outer.scale_mut(weights.covariance[i]);
        covariance += outer;
    }

    (state, covariance)
}

pub fn transform<T, F, const N: usize, const S: usize>(
    sigmas: &SMatrix<f32, S, N>,
    weights: &SigmaWeights<S>,
    noise_opt: Option<SMatrixView<f32, N, N>>,
    residual: &T,
    mean: &F,
) -> (SMatrix<f32, 1, N>, SMatrix<f32, N, N>)
where
    T: FnDistance<N>,
    F: FnMean<N, S>,
{
    let state = mean(weights.mean.as_view(), sigmas.as_view());

    let mut covariance = SMatrix::<f32, N, N>::zeros();

    for i in 0..S {
        let row = sigmas.row(i).clone_owned();

        let y = residual(row.as_view(), state.as_view());

        let mut outer = y.transpose() * y;
        outer.scale_mut(weights.covariance[i]);
        covariance += outer;
    }

    if let Some(noise) = noise_opt {
        //assert noise is diagonal matrix
        covariance += noise;
    }

    (state, covariance)
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct KallmanFilter<const N: usize, const K: usize, const S: usize> {
    /// X
    pub state: SMatrix<f32, 1, N>,
    prior_state: Option<SMatrix<f32, 1, N>>,
    /// sigmas_f
    pub state_sigmas: Option<SMatrix<f32, S, N>>,
    /// Q
    pub state_noise: SMatrix<f32, N, N>,

    /// sigmas_h
    /// the only one reason why this field is not optional
    /// is memory
    pub meas_sigmas: SMatrix<f32, S, K>,
    /// R
    pub meas_noise: SMatrix<f32, K, K>,

    #[cfg(feature = "debug")]
    /// S
    pub meas_covariance: Option<DMatrix<f32>>,
    #[cfg(feature = "debug")]
    /// SI
    pub inv_meas_covariance: Option<DMatrix<f32>>,
    #[cfg(feature = "debug")]
    pub meas_residual: Option<DVector<f32>>,

    /// P
    pub covariance: SMatrix<f32, N, N>,
    prior_covariance: Option<SMatrix<f32, N, N>>,

    /// K
    #[cfg(feature = "debug")]
    pub gain: Option<OMatrix<f32, Const<N>, Dyn>>,
    pub weights: SigmaWeights<S>,
}

pub struct PredictionConfig<F, M, R> {
    pub next_state: F,
    pub mean_transform: M,
    pub state_sub: R,
}

pub struct UpdateConfig<M, MT, MR, SR> {
    pub state_to_meas: M,
    /// transformation for sigma points
    pub mean_transform: MT,
    pub meas_sub: MR,
    pub state_sub: SR,
}

impl<const N: usize, const K: usize, const S: usize> Default
    for KallmanFilter<N, K, S>
{
    fn default() -> Self {
        Self::new()
    }
}

impl<const N: usize, const K: usize, const S: usize> KallmanFilter<N, K, S> {
    pub fn new() -> Self {
        assert_eq!(sigma_order(N), S);

        let weights = sigma_points::estimate_merwe_weights::<N, S>(
            sigma_points::SigmaMetadata {
                alpha: 0.1,
                beta: 2.0,
                kappa: (N as f32 - 3.0),
            },
        );
        Self::with_weights(weights)
    }
    pub fn with_weights(weights: SigmaWeights<S>) -> Self {
        Self {
            state: SMatrix::zeros(),
            prior_state: None,
            state_sigmas: None,
            state_noise: SMatrix::identity(),

            meas_sigmas: SMatrix::zeros(),
            meas_noise: SMatrix::identity(),

            #[cfg(feature = "debug")]
            meas_residual: None,
            #[cfg(feature = "debug")]
            meas_covariance: None,
            #[cfg(feature = "debug")]
            inv_meas_covariance: None,

            covariance: SMatrix::identity(),
            prior_covariance: None,

            #[cfg(feature = "debug")]
            gain: None,
            weights,
        }
    }

    /// return the state at current time
    pub fn state_snapshot(
        &self,
        timestamp: SystemTime,
    ) -> FilterState<N, K, S> {
        FilterState {
            state: self.state.clone_owned(),
            covariance: self.covariance.clone_owned(),
            meas_noise: self.meas_noise.clone_owned(),
            timestamp,
            _marker: std::marker::PhantomData,
        }
    }

    pub fn reset(&mut self) {
        self.prior_state = None;
        self.prior_covariance = None;

        self.state_sigmas = None;

        #[cfg(feature = "debug")]
        {
            self.meas_covariance = None;
            self.inv_meas_covariance = None;
            self.meas_residual = None;
            self.gain = None;
        }
    }

    pub fn reset_with_state(
        &mut self,
        FilterState {
            state,
            covariance,
            meas_noise,
            ..
        }: FilterState<N, K, S>,
    ) {
        self.state = state;
        self.covariance = covariance;
        self.meas_noise = meas_noise;
    }

    pub fn predict<F, M, R>(
        &mut self,
        PredictionConfig {
            next_state,
            mean_transform,
            state_sub,
        }: PredictionConfig<F, M, R>,
    ) -> Result<(SMatrixView<f32, 1, N>, SMatrixView<f32, N, N>), MathError>
    where
        F: FnState<N>,
        M: FnMean<N, S>,
        R: FnDistance<N>,
    {
        self.reset();

        //compute procces sigmas
        let mut sigmas = estimate_merwe_sigmas::<S, N, _>(
            self.state.as_view(),
            self.covariance.as_view(),
            self.weights.metadata,
            &state_sub,
        )?;

        for mut row in sigmas.row_iter_mut() {
            let row_copy = row.clone_owned();
            row.copy_from(&next_state(row_copy.as_view()));
        }

        // pass sigmas through the unscented transform to compute prior
        let (prior_state, prior_covariance) = transform(
            &sigmas,
            &self.weights,
            Some(self.state_noise.as_view()),
            &state_sub,
            &mean_transform,
        );

        // log::info!("Second estimate");
        // update sigma points to reflect the new variance of the points
        self.state_sigmas = Some(estimate_merwe_sigmas(
            prior_state.as_view(),
            prior_covariance.as_view(),
            self.weights.metadata,
            &state_sub,
        )?);

        self.prior_state = Some(prior_state);
        self.prior_covariance = Some(prior_covariance);

        Ok((
            self.prior_state.as_ref().unwrap().as_view(),
            self.prior_covariance.as_ref().unwrap().as_view(),
        ))
    }

    pub fn update<M, MT, MR, SR>(
        &mut self,
        meas: &SMatrix<f32, 1, K>,
        dyn_transform: Option<OMatrix<f32, Dyn, Const<K>>>,
        UpdateConfig {
            state_to_meas,
            mean_transform,
            meas_sub,
            state_sub,
        }: UpdateConfig<M, MT, MR, SR>,
    ) -> Result<(), MathError>
    where
        M: FnMeasurement<N, K>,
        MT: FnMean<K, S>,
        MR: FnDistance<K>,
        SR: FnDistance<N>,
    {
        let update_size =
            dyn_transform.as_ref().map(|m| m.nrows()).unwrap_or(K);
        // pass prior sigmas through h(x) to get measurement sigmas
        // the shape of sigmas_h will vary if the shape of z varies, so
        // recreate each time

        // let Some(state_sigmas) = self.sta

        let state_sigmas = self
            .state_sigmas
            .as_ref()
            .expect("Update method should be invoked after predict");

        let (prior_state, prior_covariance) = self
            .prior_state
            .as_ref()
            .zip(self.prior_covariance.as_ref())
            .expect("Prior estimations are not provided");

        state_sigmas
            .row_iter()
            .zip(self.meas_sigmas.row_iter_mut())
            .for_each(|(f_row, mut h_row)| {
                let row_copy = f_row.clone_owned();
                h_row.copy_from(&state_to_meas(row_copy.as_view()));
            });

        let transform = dyn_transform.unwrap_or(identity_transform());
        let transform_view = transform.as_view();

        // mean and covariance of prediction passed through unscented transform
        let (meas_mean, meas_covariance) = transform_dyn(
            &self.meas_sigmas,
            &self.weights,
            Some(self.meas_noise.as_view()),
            transform_view,
            &meas_sub,
            &mean_transform,
        );

        let Some(inv_meas_covarinace) =
            meas_covariance.clone_owned().try_inverse()
        else {
            return Err(MathError::NoInverseMatrix);
        };

        // compute cross variance of the state and the measurements
        let cross_variance = {
            // let mut pxz = SMatrix::<f32, N, K>::zeros();
            let mut pxz = OMatrix::<f32, Const<N>, Dyn>::zeros(update_size);
            state_sigmas
                .row_iter()
                .zip(self.meas_sigmas.row_iter())
                .zip(self.weights.covariance.iter())
                .for_each(|((f_row, h_row), weight)| {
                    let dx = state_sub(
                        f_row.clone_owned().as_view(),
                        prior_state.as_view(),
                    );

                    let dz = {
                        let raw_dz = meas_sub(
                            h_row.clone_owned().as_view(),
                            meas_mean.as_view(),
                        );
                        (transform_view * raw_dz.transpose()).transpose()
                    };

                    pxz += *weight * (dx.transpose() * dz);
                });
            pxz
        };
        let gain = cross_variance * inv_meas_covarinace.clone();
        // cross_variance.mul_to(&inv_meas_covarinace, &mut self.gain);

        let y = {
            let raw_y = meas_sub(meas.as_view(), meas_mean.as_view());
            transform_view * raw_y.transpose()
        };

        //todo: consider to add custom method add
        let state_diff = (gain.clone() * y.clone()).transpose();
        let covariance_diff =
            gain.clone() * (meas_covariance.clone() * gain.transpose());

        let covariance = *prior_covariance - covariance_diff;

        if Cholesky::new(covariance).is_none() {
            return Err(MathError::NotPositiveCovariance);
        }

        self.state = prior_state + state_diff;
        self.covariance = *prior_covariance - covariance_diff;

        #[cfg(feature = "debug")]
        {
            self.gain = Some(gain);
            self.meas_covariance = Some(meas_covariance);
            self.inv_meas_covariance = Some(inv_meas_covarinace);
            self.meas_residual = Some(y);
        }

        Ok(())
    }

    /// calculate the mahalanobis distance of update
    #[cfg(feature = "debug")]
    pub fn mahalanobis(&self) -> Option<f32> {
        let y = self.meas_residual.as_ref()?;
        let inv_meas_covariance = self.inv_meas_covariance.as_ref()?;
        Some(mahalanobis(y.as_view(), inv_meas_covariance.as_view()))
    }
}

/// Mahalanobis distance of measurement. E.g. 3 means measurement
/// was 3 standard deviations away from the predicted value.
#[cfg(feature = "debug")]
pub fn mahalanobis(
    meas_residual: DVectorView<f32>,
    inv_meas_covariance: DMatrixView<f32>,
) -> f32 {
    // let meas_residual = self.meas_residual.as_ref()?;
    // let inv_meas_covariance = self.inv_meas_covariance.as_ref()?;

    let dot = meas_residual.transpose() * inv_meas_covariance;

    let dist2 = (dot * meas_residual)[0];

    dist2.sqrt()
}

==> ./icp/icp_least_squares.rs <==
use std::f32::consts::PI;

use nalgebra::{
    IsometryMatrix2, Matrix2, Matrix2x3, Matrix3, Point2, Rotation2, Vector2,
    Vector3,
};

use super::icp_svd::PointCloud;
use crate::model::kd_tree::{KdTree, MyKdTree};

pub fn icp_least_squares(
    p: &[Point2<f32>],
    q: &MyKdTree,
    iterations: usize,
) -> IsometryMatrix2<f32> {
    let mut x = Vector3::zeros();
    let mut p_copy = p.to_vec();

    for _i in 0..iterations {
        let correspondences =
            get_correspondence_indices(&p_copy, q.get_points().as_slice());

        let (h, g) =
            prepare_system(&x, p, q.get_points().as_slice(), &correspondences);
        let epsilon = 1e-6;
        let dx = lstsq::lstsq(&h, &-g, epsilon).unwrap().solution;

        x += dx;
        x[2] = x[2].rem_euclid(2.0 * PI);
        let rotation = Rotation2::new(x[2]);
        let translation = Vector2::new(x[0], x[1]);
        p_copy = p
            .iter()
            .map(|point| (rotation * point) + translation)
            .collect();
    }

    IsometryMatrix2::new(Vector2::new(x[0], x[1]), x[2])
}

#[allow(clippy::needless_range_loop)] // Code is more clear
fn get_correspondence_indices(
    p: &[Point2<f32>],
    q: &[Point2<f32>],
) -> Vec<usize> {
    let mut correspondences = Vec::with_capacity(p.len());

    for i in 0..p.len() {
        let mut min_dist = f32::MAX;
        let mut min_index = 0;
        for j in 0..q.len() {
            let dist = (p[i] - q[j]).norm();
            if dist < min_dist {
                min_dist = dist;
                min_index = j;
            }
        }
        correspondences.push(min_index);
    }
    correspondences
}

pub fn nearest_neighboor_kdtree_sq(
    a: &PointCloud,
    b: &KdTree,
    _max_distance_for_nn_matching: f32,
) -> (PointCloud, PointCloud, Vec<usize>) {
    let mut source_points = Vec::with_capacity(a.len());
    let mut new_points = Vec::with_capacity(a.len());
    let mut indexes = Vec::with_capacity(a.len());

    for (i, point_a) in a.iter().enumerate() {
        let nearest_point: Point2<f32> =
            b.nearest_search(&(*point_a).into()).into();
        let _distance = (point_a - nearest_point).magnitude();

        new_points.push(nearest_point);
        source_points.push(*point_a);
        indexes.push(i);
    }

    (source_points, new_points, indexes)
}

fn prepare_system(
    x: &Vector3<f32>,
    p: &[Point2<f32>],
    q: &[Point2<f32>],
    correspondences: &[usize],
) -> (Matrix3<f32>, Vector3<f32>) {
    let mut h = Matrix3::zeros();
    let mut g = Vector3::zeros();
    for (i, j) in correspondences.iter().enumerate() {
        let p_point = p[i];
        let q_point = q[*j];
        let e = error(x, &p_point.coords, &q_point.coords);
        let jacobian = jacobian(&p_point.coords);
        let transposed_jacobian = jacobian.transpose();
        h += transposed_jacobian * jacobian;
        g += transposed_jacobian * e;
    }
    (h, g)
}

#[allow(unused)]
fn prepare_system_old(
    x: &Vector3<f32>,
    correspondences: (Vec<Point2<f32>>, Vec<Point2<f32>>),
) -> (Matrix3<f32>, Vector3<f32>) {
    fn kernel(_error: Vector2<f32>) -> f32 {
        // error.norm() > 0.3, check on error norm to reject points
        1.0
    }

    let mut h = Matrix3::zeros();
    let mut g = Vector3::zeros();
    for (p_point, q_point) in
        correspondences.0.iter().zip(correspondences.1.iter())
    {
        let e = error(x, &p_point.coords, &q_point.coords);
        let weight = kernel(e);

        let jacobian = jacobian(&p_point.coords);
        let transposed_jacobian = jacobian.transpose();
        h += weight * (transposed_jacobian * jacobian);
        g += weight * (transposed_jacobian * e);
    }
    (h, g)
}

/// Returns the derivative of a rotation matrix with a given angle.
fn d_r(theta: f32) -> Matrix2<f32> {
    let mut d_r = Matrix2::zeros();
    d_r[(0, 0)] = -theta.sin();
    d_r[(0, 1)] = -theta.cos();
    d_r[(1, 0)] = theta.cos();
    d_r[(1, 1)] = -theta.sin();
    d_r
}

fn jacobian(p: &Vector2<f32>) -> Matrix2x3<f32> {
    let mut j = Matrix2x3::zeros();
    j[(0, 0)] = 1.0;
    j[(1, 1)] = 1.0;
    let dr_0 = d_r(0.0); // Not sure why this doesn't use theta but the python code doesn't either
    let dot = dr_0 * p;
    j[(0, 2)] = dot[0];
    j[(1, 2)] = dot[1];
    j
}

fn error(
    x: &Vector3<f32>,
    p_point: &Vector2<f32>,
    q_point: &Vector2<f32>,
) -> Vector2<f32> {
    let rotation = Rotation2::new(x[2]);
    let translation = Vector2::new(x[0], x[1]);
    let prediction = (rotation * p_point) + translation;
    prediction - q_point
}

==> ./icp/icp_least_squares_raw.rs <==
use lstsq::lstsq;
use nalgebra::{IsometryMatrix2, Matrix2, Matrix2x3, Matrix3, Rotation2, Vector2, Vector3};
use std::f32::consts::PI;

pub fn icp_least_squares_raw(
    p: &[Vector2<f32>],
    q: &[Vector2<f32>],
    iterations: usize,
) -> IsometryMatrix2<f32> {
    let mut x = Vector3::zeros();
    let mut p_copy = p.to_vec();

    for _i in 0..iterations {
        let correspondences = get_correspondence_indices(&p_copy, q);
        let (h, g) = prepare_system(&x, p, q, &correspondences);
        let epsilon = 1e-14; //1e-14;
        let dx = lstsq(&h, &-g, epsilon).unwrap().solution;
        if dx.norm() < 1e-14 {
            break;
        }
        x += dx;
        x[2] = x[2].rem_euclid(2.0 * PI);
        let rotation = Rotation2::new(x[2]);
        let translation = Vector2::new(x[0], x[1]);
        p_copy = p
            .iter()
            .map(|point| (rotation * point) + translation)
            .collect();
    }

    IsometryMatrix2::new(Vector2::new(x[0], x[1]), x[2])
}

fn get_correspondence_indices(p: &[Vector2<f32>], q: &[Vector2<f32>]) -> Vec<usize> {
    let mut correspondences = Vec::with_capacity(p.len());

    for i in p {
        let mut min_dist = f32::MAX;
        let mut min_index = 0;
        for (j, j_item) in q.iter().enumerate() {
            let dist = (i - j_item).norm();
            if dist < min_dist {
                min_dist = dist;
                min_index = j;
            }
        }
        correspondences.push(min_index);
    }
    correspondences
}

fn error(x: &Vector3<f32>, p_point: &Vector2<f32>, q_point: &Vector2<f32>) -> Vector2<f32> {
    let rotation = Rotation2::new(x[2]);
    let translation = Vector2::new(x[0], x[1]);
    let prediction = (rotation * p_point) + translation;
    prediction - q_point
}

fn prepare_system(
    x: &Vector3<f32>,
    p: &[Vector2<f32>],
    q: &[Vector2<f32>],
    correspondences: &[usize],
) -> (Matrix3<f32>, Vector3<f32>) {
    fn kernel(_error: Vector2<f32>) -> f32 {
        1.0
    }

    let mut h = Matrix3::zeros();
    let mut g = Vector3::zeros();

    for (i, j) in correspondences.iter().enumerate() {
        let p_point = p[i];
        let q_point = q[*j];
        let e = error(x, &p_point, &q_point);
        let weight = kernel(e);

        let jacobian = jacobian(&p_point, 0.0);
        let transposed_jacobian = jacobian.transpose();
        h += weight * transposed_jacobian * jacobian;
        g += weight * transposed_jacobian * e;
    }
    (h, g)
}

/// Returns the derivative of a rotation matrix with a given angle.
fn d_r(theta: f32) -> Matrix2<f32> {
    let mut d_r = Matrix2::zeros();
    d_r[(0, 0)] = -theta.sin();
    d_r[(0, 1)] = -theta.cos();
    d_r[(1, 0)] = theta.cos();
    d_r[(1, 1)] = -theta.sin();
    d_r
}

fn jacobian(p: &Vector2<f32>, theta: f32) -> Matrix2x3<f32> {
    let mut j = Matrix2x3::zeros();
    j[(0, 0)] = 1.0;
    j[(1, 1)] = 1.0;
    let dr_0 = d_r(theta); // Not sure why this doesn't use theta but the python code doesn't either
    let dot = dr_0 * p;
    j[(0, 2)] = dot[0];
    j[(1, 2)] = dot[1];
    j
}

==> ./icp/icp_slam.rs <==
#![allow(unused)]
use std::{
    f32::consts::{PI, TAU},
    sync::{Arc, Mutex},
    time::Duration,
};

use kdtree::kdtree::Kdtree;
use nalgebra::{Isometry2, IsometryMatrix2, Point2, Rotation2, Vector2};
use serde::{Deserialize, Serialize};

use crate::{
    correlative_scan_matching::localized_range_scan::LocalizedRangeScan,
    icp::icp_svd::match_points_cloud_with_kdtree,
    model::{
        occupancy_grid::OccupancyGrid,
        pose::{Pose2D, VelocityPose2D},
    },
};
use roboq_types::{
    devices::lidar::LidarScan2D,
    model::{
        localization::{LidarSensorConfig, MatchingAlgorithm},
        map::MetresPerPixel,
        Metres,
    },
};

const USE_SVD: bool = true;

use super::icp_least_squares::icp_least_squares;
use crate::model::kd_tree::{KdTree, MyKdTree, Point2Kd};

use super::icp_svd::{
    point_cloud_from_lidar_scan_deskew, IcpConfig, PointCloud,
};

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct IcpSlamInitConfig {
    pub start_position: Pose2D,
    pub map_size_pixels: u32,
    pub map_size_metres: Metres,
}

impl Default for IcpSlamInitConfig {
    fn default() -> Self {
        IcpSlamInitConfig {
            start_position: Pose2D {
                coords: Point2::new(200.0, 200.0),
                heading_rad: std::f32::consts::TAU * 1.4,
            },
            map_size_pixels: 2048 * 2,
            map_size_metres: Metres(400.0 * 2.0),
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct IcpSlamConfig {
    pub move_threshold_for_adding_points: Metres,
    pub max_iterations_icp: usize,
    /// The maximum allowed distance to include a neighbor
    /// into the transform calculation
    #[serde(default = "roboq_types::serde::const_f32::<1>")]
    pub max_distance_for_nn_matching: f32,
    #[serde(default = "default_error")]
    pub delta_error_stop: f32,
    #[serde(default = "default_error")]
    pub min_error_stop: f32,
    #[serde(default)]
    pub match_kind: MatchingAlgorithm,
    /// the minimal distance in metres
    /// above which the point will be added
    pub add_points_maximum_distance: Metres,
    pub filter_scan_points: Metres,
    pub updating_map: bool,
}

fn default_error() -> f32 {
    0.000001
}

impl IcpSlamConfig {
    pub fn icp_config(&self) -> IcpConfig {
        IcpConfig {
            max_iterations: self.max_iterations_icp,
            max_distance_for_nn_matching: self.max_distance_for_nn_matching,
            delta_error_stop: self.delta_error_stop,
            min_error_stop: self.min_error_stop,
        }
    }

    pub fn update_icp_config(&mut self, config: IcpConfig) {
        self.max_iterations_icp = config.max_iterations;
        self.max_distance_for_nn_matching = config.max_distance_for_nn_matching;
        self.delta_error_stop = config.delta_error_stop;
        self.min_error_stop = config.min_error_stop;
    }
}

impl<'a> From<&'a IcpSlamConfig> for IcpConfig {
    fn from(value: &'a IcpSlamConfig) -> Self {
        value.icp_config()
    }
}

impl Default for IcpSlamConfig {
    fn default() -> Self {
        IcpSlamConfig {
            match_kind: MatchingAlgorithm::Svd,
            move_threshold_for_adding_points: Metres(0.30),
            max_iterations_icp: 100,
            max_distance_for_nn_matching: 1.0,
            add_points_maximum_distance: Metres(0.10),
            filter_scan_points: Metres(0.01),
            updating_map: true,
            delta_error_stop: 0.000001,
            min_error_stop: 0.000001,
        }
    }
}

pub struct IcpSlamData {
    // Robot
    robot_position: Pose2D,
    robot_composite_velocity: VelocityPose2D,
    last_added_pose: Pose2D,

    // Map
    my_kd_tree: Arc<Mutex<MyKdTree>>,
    map: OccupancyGrid,

    // Debug
    recent_matched_scan: Vec<Point2<f32>>,
    points_pre_match: Vec<Point2<f32>>,

    // Config
    config: IcpSlamConfig,
}

pub struct IcpSlam {
    map: OccupancyGrid,

    robot_position: Pose2D,
    robot_composite_velocity: VelocityPose2D,
    last_added_pose: Pose2D,

    my_kd_tree: MyKdTree,
    recent_matched_scan: Vec<Point2<f32>>,

    config: IcpSlamConfig,

    // Debug properties
    pub points_pre_match: Vec<Point2<f32>>,
}

const MAP_KEEP_POINT_THRESHOLD: u8 = 129;

impl IcpSlam {
    pub fn new(init_config: &IcpSlamInitConfig, config: IcpSlamConfig) -> Self {
        IcpSlam {
            map: OccupancyGrid::new_empty(
                init_config.map_size_pixels,
                init_config.map_size_pixels,
                MetresPerPixel::new(
                    init_config.map_size_metres,
                    init_config.map_size_pixels,
                ),
            ),

            robot_position: init_config.start_position,
            last_added_pose: init_config.start_position,

            robot_composite_velocity: VelocityPose2D::default(),

            points_pre_match: Vec::new(),

            my_kd_tree: MyKdTree::new(),

            recent_matched_scan: Vec::new(),
            config,
        }
    }

    pub fn rebuild_tree(&mut self) {
        self.my_kd_tree.rebuild_tree();
    }

    pub fn update_map(&mut self) {
        for point in &self.recent_matched_scan {
            self.map
                .sensor_ray_world(&self.robot_position.coords, point);
        }
    }

    pub fn clear_points(&mut self) {
        self.my_kd_tree.retain_points(|point| {
            *self.map.index_world_mut(point) < MAP_KEEP_POINT_THRESHOLD
        });
    }

    pub fn update_lidar(
        &mut self,
        lidar_data: LidarScan2D,
        config: &LidarSensorConfig,
    ) -> LocalizedRangeScan {
        if !self.my_kd_tree.is_empty() {
            self.algorithm_step(lidar_data, config)
        } else {
            self.first_scan(lidar_data, config)
        }
    }

    fn algorithm_step(
        &mut self,
        lidar_data: LidarScan2D,
        config: &LidarSensorConfig,
    ) -> LocalizedRangeScan {
        let prev_pos = self.robot_position;

        self.robot_position += self.robot_composite_velocity;

        let mut source = point_cloud_from_lidar_scan_deskew(
            &lidar_data,
            Duration::from_millis(100),
            &self.robot_composite_velocity,
            true,
            config.ignore_distance_mm,
        );

        let mut source2: Vec<Point2<f32>> = Vec::new();

        'outer: for point in source.iter() {
            for point2 in &source2 {
                if (point - point2).magnitude()
                    < *self.config.filter_scan_points
                {
                    continue 'outer;
                }
            }
            source2.push(*point);
        }

        let mut source = source2;

        let transformation_pre_icp = self.robot_position.as_isometry();

        for point in &mut source {
            *point = transformation_pre_icp * *point;
        }
        self.points_pre_match = source.clone();

        let matched_transform;
        let point_cloud;

        if USE_SVD {
            (matched_transform, point_cloud) = match_points_cloud_with_kdtree(
                &IcpConfig {
                    max_distance_for_nn_matching: 0.2,
                    ..Default::default()
                },
                source,
                self.my_kd_tree.get_kdtree(),
            );
        } else {
            (matched_transform, point_cloud) = {
                let transform = icp_least_squares(
                    &source,
                    &self.my_kd_tree,
                    self.config.max_iterations_icp,
                );
                let point_cloud: Vec<_> =
                    source.iter().map(|p| transform * p).collect();
                (transform, point_cloud)
            };
        }

        self.recent_matched_scan = point_cloud.clone();
        let new_transform_as_robot_position =
            matched_transform * transformation_pre_icp;
        self.robot_position =
            Pose2D::from_isometry(new_transform_as_robot_position);
        self.robot_composite_velocity = self.robot_position - prev_pos;

        let point_cloud_to_return = point_cloud.clone();

        if (self.last_added_pose.coords - self.robot_position.coords)
            .magnitude()
            > *self.config.move_threshold_for_adding_points
        {
            self.last_added_pose = self.robot_position;
            self.my_kd_tree.add_points_within_range(
                &point_cloud,
                *self.config.add_points_maximum_distance,
            );
        }

        self.update_map();
        self.clear_points();

        LocalizedRangeScan {
            points: point_cloud_to_return,
            pose: self.robot_position,
        }
    }

    fn first_scan(
        &mut self,
        lidar_data: LidarScan2D,
        config: &LidarSensorConfig,
    ) -> LocalizedRangeScan {
        let mut lidar_points = point_cloud_from_lidar_scan_deskew(
            &lidar_data,
            Duration::from_millis(100),
            &self.robot_composite_velocity,
            true,
            config.ignore_distance_mm,
        );

        let isometry = self.robot_position.as_isometry();
        for point in &mut lidar_points {
            *point = isometry * *point;
        }

        self.my_kd_tree.add_points_within_range(
            &lidar_points,
            *self.config.add_points_maximum_distance,
        );
        self.update_map();

        LocalizedRangeScan {
            points: lidar_points,
            pose: self.robot_position,
        }
    }

    pub fn get_map_points(&self) -> PointCloud {
        self.my_kd_tree.get_points().clone()
    }

    pub fn get_lidar_matched(&self) -> PointCloud {
        self.recent_matched_scan.clone()
    }

    pub fn get_position(&self) -> (Point2<f32>, f32) {
        (self.robot_position.coords, self.robot_position.heading_rad)
    }

    pub fn get_map(&self) -> OccupancyGrid {
        self.map.clone()
    }
}

==> ./icp/icp_svd.rs <==
#![allow(non_snake_case)]
use std::time::Duration;

use nalgebra::{
    Dyn, IsometryMatrix2, Matrix2, OMatrix, Point2, Rotation2, Vector2, U2,
};
use rayon::iter::{IntoParallelRefIterator, ParallelIterator};

use crate::model::pose::VelocityPose2D;
use roboq_types::devices::lidar::LidarScan2D;

use crate::model::kd_tree::KdTree;

pub use roboq_types::model::localization::IcpConfig;
pub type PointCloud = Vec<Point2<f32>>;

/// Deskew scan. Provided pose is pose at the time when the first point in the scan is takes, and
/// it's expected that the last point is taken at pose + vel * scan_duration.
/// Points which are at a max distance are ignored.
pub fn point_cloud_from_lidar_scan_deskew(
    scan: &LidarScan2D,
    scan_duration: Duration,
    pose_and_velocity: &VelocityPose2D,
    should_skew: bool,
    ignore_distance_mm: u32,
) -> PointCloud {
    let mut points = Vec::new();
    let time_per_scan = scan_duration.as_secs_f32();
    let end_translation = pose_and_velocity.translation * time_per_scan;

    for (i, point) in scan.points.iter().enumerate() {
        //todo: do it at lidar
        if point.distance_mm < ignore_distance_mm {
            continue;
        }

        let (angle, _) = point.get_rad_metres();
        if !scan.range.contains(&angle) {
            continue;
        }

        let t = i as f32 / scan.points.len() as f32;
        let t = if should_skew { 1.0 - t } else { 0.0 };

        let translation_dt = Vector2::zeros().lerp(&end_translation, t);
        let rotation_dt = pose_and_velocity.angular * time_per_scan * t;

        if let Some((x, y)) = point.get_xy_angle(-rotation_dt) {
            points.push(Point2::new(x, y) - translation_dt);
        }
    }

    points
}

pub fn match_points_cloud_with_kdtree(
    config: &IcpConfig,
    mut source: PointCloud,
    target: &KdTree,
) -> (IsometryMatrix2<f32>, PointCloud) {
    let initial_source = source.clone();

    let mut prev_error = 0.0;
    let mut _iter_count = 0;

    for _i in 0..config.max_iterations {
        _iter_count = _i;

        let (new_source_points, new_target_points) = nearest_neighboor_kdtree(
            &source,
            target,
            config.max_distance_for_nn_matching,
        );

        //source points are unknown
        //therefore no assumption about transform must be done
        if new_source_points.is_empty() {
            return (IsometryMatrix2::identity(), source);
        }

        let (trans, rot, error) =
            best_fit_transform(&new_source_points, &new_target_points);

        for point in source.iter_mut() {
            *point = Point2::from(trans + rot * point.coords);
        }

        if (error - prev_error).abs() < config.delta_error_stop
            || error.abs() < config.min_error_stop
        {
            break;
        }

        prev_error = error;
    }

    let transformation = best_fit_transform(&initial_source, &source);

    (
        IsometryMatrix2::from_parts(
            transformation.0.into(),
            Rotation2::from_matrix(&transformation.1),
        ),
        source,
    )
}

/// The central algorithm for finding the transformation using SVD
pub fn best_fit_transform(
    source: &PointCloud,
    target: &PointCloud,
) -> (Vector2<f32>, Matrix2<f32>, f32) {
    assert_eq!(source.len(), target.len());
    assert!(!source.is_empty());

    let source_centroid = source
        .iter()
        .fold(Point2::new(0.0, 0.0), |sum, point| sum + point.coords)
        / source.len() as f32;

    let target_centroid = target
        .iter()
        .fold(Point2::new(0.0, 0.0), |sum, point| sum + point.coords)
        / target.len() as f32;

    let moved_source: Vec<_> = source
        .iter()
        .map(|point| (point - source_centroid).transpose())
        .collect();
    let moved_target: Vec<_> = target
        .iter()
        .map(|point| (point - target_centroid).transpose())
        .collect();

    let moved_source: OMatrix<f32, Dyn, U2> =
        OMatrix::<f32, Dyn, U2>::from_rows(moved_source.as_slice());
    let moved_target: OMatrix<f32, Dyn, U2> =
        OMatrix::<f32, Dyn, U2>::from_rows(moved_target.as_slice());

    let cov_mat = moved_target.transpose() * &moved_source;
    let svd = nalgebra::SVD::new(cov_mat, true, true);
    let u = svd.u.unwrap();
    let v_t = svd.v_t.unwrap();
    let r = u * v_t;
    let t = target_centroid - r * source_centroid;

    let error =
        (moved_target - (r * moved_source.transpose()).transpose()).norm();

    (t, r, error)
}

pub fn nearest_point_search(a: Point2<f32>, cloud: &PointCloud) -> Point2<f32> {
    let mut min_distance = f32::INFINITY;
    let mut min_point = Point2::<f32>::default();
    for point in cloud.iter() {
        let distance = (a - point).magnitude_squared();
        if distance < min_distance {
            min_distance = distance;
            min_point = *point;
        }
    }
    min_point
}

/// Search for the closest points to the original ones
pub fn nearest_neighboor_kdtree(
    a: &PointCloud,
    b: &KdTree,
    max_distance_for_nn_matching: f32,
) -> (PointCloud, PointCloud) {
    let mut source_points = Vec::with_capacity(a.len());
    let mut new_points = Vec::with_capacity(a.len());

    let threaded = false;

    if threaded {
        let x: Vec<_> = a
            .par_iter()
            .filter_map(|point_a| {
                let nearest_point: Point2<f32> =
                    b.nearest_search(&(*point_a).into()).into();
                let distance = (point_a - nearest_point).magnitude();
                if distance > max_distance_for_nn_matching {
                    None
                } else {
                    Some((nearest_point, point_a))
                }
            })
            .collect();

        for (nearest_point, point_a) in x {
            new_points.push(nearest_point);
            source_points.push(*point_a);
        }
    } else {
        for point_a in a.iter() {
            let nearest_point: Point2<f32> =
                b.nearest_search(&(*point_a).into()).into();
            let distance = (point_a - nearest_point).magnitude();

            /*
            let nearest_point_b: Point2<f32> = nearest_point_search(nearest_point, a);
            if distance / 2.0 > (nearest_point - nearest_point_b).magnitude() {
                continue;
            }
            */

            if distance > max_distance_for_nn_matching {
                continue;
            }

            new_points.push(nearest_point);
            source_points.push(*point_a);
        }
    }

    (source_points, new_points)
}

/*
/// Returns the derivative of a rotation matrix with a given angle.
fn d_r(theta: f32) -> Matrix2<f32> {
    let mut d_r = Matrix2::zeros();
    d_r[(0, 0)] = -theta.sin();
    d_r[(0, 1)] = -theta.cos();
    d_r[(1, 0)] = theta.cos();
    d_r[(1, 1)] = -theta.sin();
    d_r
}

fn jacobian(p: &Vector2<f32>) -> Matrix2x3<f32> {
    let mut j = Matrix2x3::zeros();
    j[(0, 0)] = 1.0;
    j[(1, 1)] = 1.0;
    let dr_0 = d_r(0.0); // Not sure why this doesn't use theta but the python code doesn't either
    let dot = dr_0 * p;
    j[(0, 2)] = dot[0];
    j[(1, 2)] = dot[1];
    j
}

fn error(x: &Vector3<f32>, p_point: &Vector2<f32>, q_point: &Vector2<f32>) -> Vector2<f32> {
    let rotation = Rotation2::new(x[2]);
    let translation = Vector2::new(x[0], x[1]);
    let prediction = (rotation * p_point) + translation;
    prediction - q_point
}

fn prepare_system(
    x: &Vector3<f32>,
    p: &[Point2<f32>],
    q: &[Point2<f32>],
    correspondences: &[usize],
) -> (Matrix3<f32>, Vector3<f32>) {
    fn kernel(error: Vector2<f32>) -> f32 {
        if error.norm() > 0.5 {
            0.0
        } else {
            1.0
        }
    }
    let mut h = Matrix3::zeros();
    let mut g = Vector3::zeros();
    for (i, j) in correspondences.iter().enumerate() {
        let p_point = p[i];
        let q_point = q[*j];
        let e = error(x, &p_point.coords, &q_point.coords);
        let weight = kernel(e);

        let jacobian = jacobian(&p_point.coords);
        let transposed_jacobian = jacobian.transpose();
        h += weight * (transposed_jacobian * jacobian);
        g += weight * (transposed_jacobian * e);
    }
    (h, g)
}

#[allow(unused)]
pub fn icp_least_squares(
    p: &[Point2<f32>],
    q: &[Point2<f32>],
    iterations: usize,
) -> IsometryMatrix2<f32> {
    let mut x = Vector3::zeros();
    let mut p_copy = p.to_vec();

    for _i in 0..iterations {
        let correspondences = get_correspondence_indices(&p_copy, q);
        let (h, g) = prepare_system(&x, p, q, &correspondences);
        let epsilon = 1e-6;
        let dx = lstsq::lstsq(&h, &-g, epsilon).unwrap().solution;
        if dx.norm() < 1e-14 {
            break;
        }
        x += dx;
        x[2] = x[2].rem_euclid(2.0 * PI);
        let rotation = Rotation2::new(x[2]);
        let translation = Vector2::new(x[0], x[1]);
        p_copy = p
            .iter()
            .map(|point| (rotation * point) + translation)
            .collect();
    }

    //x;
    IsometryMatrix2::new(Vector2::new(x[0], x[1]), x[2])
}

fn get_correspondence_indices(p: &[Point2<f32>], q: &[Point2<f32>]) -> Vec<usize> {
    let mut correspondences = Vec::with_capacity(p.len());
    // closest point
    for p_i in p {
        let mut min_dist = f32::MAX;
        let mut min_index = 0;
        for (j, q_j) in q.iter().enumerate() {
            let dist = (p_i - q_j).norm();
            if dist < min_dist {
                min_dist = dist;
                min_index = j;
            }
        }
        correspondences.push(min_index);
    }
    correspondences
}
*/

==> ./icp/mod.rs <==
pub mod icp_least_squares;
pub mod icp_least_squares_raw;
pub mod icp_slam;
pub mod icp_svd;
//pub mod point_cloud;

==> ./icp/point_cloud.rs <==
pub type PointCloud = Vec<Point2<f32>>;

pub fn point_cloud_from_lidar_response(lidar_response: &LidarResponse) -> PointCloud {
    let mut points = Vec::new();
    for point in &lidar_response.points {
        if let Some((x, y)) = point.get_xy() {
            points.push(Point2::new(x, y));
        }
    }
    points
}

pub fn point_cloud_from_lidar_response_angle(
    lidar_response: &LidarResponse,
    angle: f32,
) -> PointCloud {
    let mut points = Vec::new();
    for point in &lidar_response.points {
        if let Some((x, y)) = point.get_xy_angle(angle) {
            points.push(Point2::new(x, y));
        }
    }
    points
}

==> ./input_data.rs <==
#[cfg(feature = "gps")]
use nalgebra::Point2;
use roboq_types::model::waypoint::Waypoint;

use crate::{
    config::ConfigProperty, devices::DeviceMessage,
    model::motor_action::MotorAction,
};

#[derive(Clone)]
pub enum InputData {
    Device(DeviceMessage),
    State(StateAction),
    Planner(PlannerAction),
}

impl From<StateAction> for InputData {
    fn from(value: StateAction) -> Self {
        Self::State(value)
    }
}

impl From<PlannerAction> for InputData {
    fn from(value: PlannerAction) -> Self {
        Self::Planner(value)
    }
}

impl From<DeviceMessage> for InputData {
    fn from(value: DeviceMessage) -> Self {
        Self::Device(value)
    }
}

#[derive(Clone)]
pub enum StateAction {
    SetConfigProperty(ConfigProperty),
    GetConfig,
}

#[derive(Clone)]
pub enum PlannerAction {
    /// move to global gps points
    /// coords are given in utm
    #[cfg(feature = "gps")]
    MoveToWorldPoint {
        coords: Point2<f64>,
    },
    ///set target point on local map
    MoveToTargetPoint((f32, f32), Option<f32>),
    ///add point on map and save it
    AddTargetPoint((f32, f32), Option<f32>),
    /// remove all points from waypoints array
    ResetWaypoints,
    SetTargetPoint(u64),
    SetRotation(f32),
    /// set points over which robot should move
    SetPath(Vec<Waypoint>),
    /// manually set control
    /// inputs are given in range []
    SetControlInput(MotorAction),
}

impl From<ConfigProperty> for InputData {
    fn from(value: ConfigProperty) -> Self {
        Self::State(StateAction::SetConfigProperty(value))
    }
}

impl From<MotorAction> for InputData {
    fn from(value: MotorAction) -> Self {
        Self::Planner(PlannerAction::SetControlInput(value))
    }
}

==> ./lib.rs <==
pub mod config;
pub mod correlative_scan_matching;
pub mod icp;
pub mod model;
pub mod planner;
pub mod shared_data;

pub mod devices;
#[cfg(feature = "localization")]
pub mod filter;
#[cfg(feature = "localization")]
pub mod localization;

#[cfg(feature = "debug")]
pub mod debug;
mod input_data;
mod output_data;
#[cfg(feature = "rt")]
pub mod pipeline;

pub use devices::{DeviceData, DeviceId, DeviceMessage};
pub use input_data::{InputData, PlannerAction, StateAction};
pub use output_data::OutputData;
#[cfg(feature = "rt")]
pub use shared_data::SharedData;

#[cfg(feature = "rt")]
pub use pipeline::NavigationModule;

==> ./localization/amcl.rs <==
use std::cmp::Ordering;

use rand::{seq::index::sample_weighted, thread_rng, Rng};

use crate::model::map::OccupancyGrid;

type Point2 = nalgebra::Point2<f32>;

#[derive(Clone)]
struct RobotPos {
    pos: Point2,
    ray_casts: Vec<f32>,
    probability: f32,
    rotation: f32,
}

impl RobotPos {
    fn generate_random_pos(
        top_left: (f32, f32),
        bottom_right: (f32, f32),
    ) -> Self {
        let mut rng = rand::thread_rng();
        let x = rng.gen_range(top_left.0..bottom_right.0);
        let y = rng.gen_range(top_left.1..bottom_right.1);
        RobotPos {
            pos: Point2::new(x, y),
            ray_casts: Vec::new(),
            probability: 0.0,
            rotation: 0.0,
        }
    }

    fn generate_random_pos_around(point: Point2, radius: f32) -> Self {
        let mut rng = rand::thread_rng();
        let r = radius * rng.gen::<f32>().sqrt();
        let angle = rng.gen::<f32>() * std::f32::consts::TAU;

        let x = point.x + r * angle.cos();
        let y = point.y + r * angle.sin();

        RobotPos {
            pos: Point2::new(x, y),
            ray_casts: Vec::new(),
            probability: 0.0,
            rotation: 0.0,
        }
    }
}

pub const METRES_PER_PX: f32 = 0.050;

pub fn calc_rays(center: Point2, initial_angle: f32) -> Vec<Point2> {
    let num_rays = 400;
    let ray_len = 12.0 / METRES_PER_PX;

    let delta_angle = 360.0 / num_rays as f32;
    let mut points = Vec::with_capacity(num_rays);

    for i in 0..num_rays {
        let angle = i as f32 * delta_angle;
        let angle = initial_angle + angle.to_radians();
        let (a_sin, a_cos) = angle.sin_cos();
        let x = a_cos * ray_len;
        let y = a_sin * ray_len;
        points.push(Point2::new(center.x + x, center.y + y));
    }

    points
}

pub struct AMCL {
    points: Vec<RobotPos>,
    maybe_pos: Point2,
    rotation: f32,
}

impl AMCL {
    pub fn new() -> Self {
        AMCL {
            points: Vec::new(),
            maybe_pos: Point2::new(0.0, 0.0),
            rotation: 0.0,
        }
    }

    pub fn generate_points(&mut self, map: &OccupancyGrid, n: usize) {
        let top_left = (730.0, 570.0);
        let bottom_right = (1365.0, 1120.0);

        self.points.clear();
        for _ in 0..n {
            self.points
                .push(RobotPos::generate_random_pos(top_left, bottom_right));
        }

        self.update_raycasts(map);
    }

    fn get_scan_for_point(map: &OccupancyGrid, point: &RobotPos) -> Vec<f32> {
        let rays = calc_rays(point.pos, 0.0);
        let mut distances = Vec::with_capacity(rays.len());

        for ray in rays {
            let distance =
                if let Some(hit_pos) = map.hit_pos_metres(point.pos, ray) {
                    (point.pos - hit_pos).magnitude() * METRES_PER_PX
                } else {
                    f32::INFINITY
                };
            distances.push(distance);
        }

        distances
    }

    fn calc_probability_for_points(&mut self, in_scan: &Vec<f32>) {
        let mut max_error = 0.0f32;

        for point in &mut self.points {
            let test_scan = &point.ray_casts;
            let mut min_error = f32::INFINITY;
            let mut min_angle = 0.0;

            for permutation in 0..(test_scan.len()) / 1 {
                let mut error = 0.0f32;
                let permutation = permutation * 1;

                for (in_scan_point, test_scan_id) in
                    in_scan.iter().zip((0..test_scan.len()).into_iter())
                {
                    let test_scan_point = test_scan
                        [(permutation + test_scan_id) % test_scan.len()];
                    let p1 = if in_scan_point.is_finite() {
                        *in_scan_point
                    } else {
                        12.0
                    };
                    let p2 = if test_scan_point.is_finite() {
                        test_scan_point
                    } else {
                        12.0
                    };
                    error += (p1 - p2).abs();
                }

                if error < min_error {
                    min_error = error;
                    min_angle = (permutation as f32 / test_scan.len() as f32)
                        * std::f32::consts::TAU;
                }
            }
            max_error = max_error.max(min_error);
            point.probability = min_error;
            point.rotation = min_angle;
        }

        let mut total_error = 0.0;

        // Normalize probabilities
        for point in &mut self.points {
            point.probability = max_error - point.probability;
            total_error += point.probability;
        }
        for point in &mut self.points {
            point.probability /= total_error;
        }
    }

    fn resample(&mut self) {
        if self.points.is_empty() {
            return;
        }

        let mut cum_sum = Vec::with_capacity(self.points.len());
        let mut sum = 0.0;
        for point in &self.points {
            sum += point.probability;
            cum_sum.push(sum);
        }

        let r = thread_rng().gen_range(0.0..1.0 / self.points.len() as f32);
        let mut i = 0;
        let mut new_particles = Vec::with_capacity(self.points.len());
        for j in 0..self.points.len() {
            let u = r + j as f32 * (1.0 / self.points.len() as f32);
            while u >= cum_sum[i] && i < cum_sum.len() {
                i += 1
            }
            new_particles.push(self.points[i].clone());
        }
        self.points = new_particles;
    }

    fn random_move(&mut self) {
        let range = 6.0;
        let mut rng = thread_rng();
        for point in &mut self.points {
            point.pos.x += rng.gen_range(-range..range);
            point.pos.y += rng.gen_range(-range..range);
        }
    }

    fn update_raycasts(&mut self, map: &Map) {
        let map = &map;
        for point in &mut self.points {
            point.ray_casts = Self::get_scan_for_point(map, point);
        }
    }

    fn calc_pos(&mut self) {
        let mut avg_point = Point2::new(0.0, 0.0);
        let mut rotation_sin = 0.0;
        let mut rotation_cos = 0.0;
        for point in &self.points {
            avg_point.x += point.pos.x * point.probability;
            avg_point.y += point.pos.y * point.probability;
            let (sin, cos) = point.rotation.sin_cos();
            rotation_sin += sin * point.probability;
            rotation_cos += cos * point.probability;
        }

        self.maybe_pos = avg_point;
        self.rotation = rotation_sin.atan2(rotation_cos);
    }

    pub fn amcl_step(&mut self, map: &Map, in_scan: &Vec<f32>) {
        self.update_raycasts(map);
        self.calc_probability_for_points(in_scan);
        self.calc_pos();
        self.resample();
        self.random_move();
    }

    pub fn get_current_pos(&self) -> (Point2, f32) {
        (self.maybe_pos, self.rotation)
    }

    pub fn vis_points(&self) -> Vec<Point2> {
        self.points.iter().map(|p| p.pos).collect()
    }
}

==> ./localization/config.rs <==
use roboq_types::model::localization::{LocalizationParams, NoiseParams};
use serde::{Deserialize, Serialize};

#[derive(Clone, Default, Debug, Serialize, Deserialize)]
pub struct MotionEstimationConfig {
    #[serde(default)]
    pub enable_metadata: bool,
    pub epoch_duration_ms: u64,

    pub lifetime_duration_ms: u64,

    pub noise: NoiseConfig,
    #[serde(default)]
    pub params: LocalizationParams,
    //used when event cause unreliable transformation
    pub max_mahalanobis: f32,
    // used when dirty, but still reliable events are comming
    // consider to remove this field
    #[serde(default = "normal_mahalanobis")]
    pub noise_mahalanobis: f32,
}

impl MotionEstimationConfig {
    pub fn update_noise(&mut self, params: NoiseParams) {
        self.max_mahalanobis = params.max_mahalanobis;
        self.noise_mahalanobis = params.noise_mahalanobis;

        self.noise = params.into();
    }

    pub fn update(&mut self, params: LocalizationParams) {
        self.params = params;
    }

    pub fn params(&self) -> LocalizationParams {
        self.params.clone()
    }

    pub fn noise_params(&self) -> NoiseParams {
        let mut params: NoiseParams = (&self.noise).into();

        params.max_mahalanobis = self.max_mahalanobis;
        params.noise_mahalanobis = self.noise_mahalanobis;

        params
    }
}

#[derive(Clone, Default, Debug, Serialize, Deserialize, o2o::o2o)]
#[from(NoiseParams)]
#[into(NoiseParams | ..Default::default())]
pub struct NoiseConfig {
    #[serde(default = "coords_noise")]
    pub state_coords: f32,
    #[serde(default = "heading_noise")]
    pub state_heading: f32,

    #[cfg(feature = "lidar")]
    pub lidar_pose: f32,
    #[cfg(feature = "lidar")]
    pub lidar_heading: f32,
    #[cfg(feature = "imu")]
    #[serde(default = "ahrs_noise")]
    pub ahrs_heading: f32,

    #[cfg(feature = "imu")]
    #[serde(default = "ahrs_beta")]
    pub ahrs_alpha: f32,

    #[cfg(feature = "imu")]
    #[serde(default = "ahrs_beta")]
    pub ahrs_beta: f32,

    #[cfg(feature = "imu")]
    #[serde(default = "gyro_noise")]
    pub gyro: f32,
    #[cfg(feature = "imu")]
    #[serde(default = "accel_noise")]
    pub accel: f32,
    #[cfg(feature = "gps")]
    pub gps_pose: f32,
    #[cfg(feature = "imu")]
    #[serde(default = "gyro_bias")]
    pub gyro_bias: f32,
    #[cfg(feature = "compass")]
    pub compass: f32,
}

fn normal_mahalanobis() -> f32 {
    6.0
}

#[cfg(feature = "imu")]
fn ahrs_noise() -> f32 {
    1.0
}

#[cfg(feature = "imu")]
fn ahrs_beta() -> f32 {
    0.6
}

#[cfg(feature = "imu")]
fn accel_noise() -> f32 {
    3.0
}

#[cfg(feature = "imu")]
fn gyro_noise() -> f32 {
    1.0
}

#[cfg(feature = "imu")]
fn gyro_bias() -> f32 {
    0.001
}

fn coords_noise() -> f32 {
    0.5
}

fn heading_noise() -> f32 {
    0.3
}

==> ./localization/error.rs <==
use thiserror::Error;

use crate::filter::MathError;

#[derive(Debug, Error)]
pub enum LocalizationError {
    #[error("High mahalanobis ({0})")]
    HighMahalanobis(f32),

    #[error("No memorized state for such old data event")]
    BadLifetime,

    #[error("Failed to perform math operation: {0}")]
    MathError(#[from] MathError),
}

impl LocalizationError {
    pub fn is_poison_detected(&self) -> bool {
        match self {
            LocalizationError::HighMahalanobis(_) => true,
            LocalizationError::BadLifetime => false,
            LocalizationError::MathError(_) => true,
        }
    }
}

==> ./localization/estimation.rs <==
use nalgebra::{
    Const, Dyn, OMatrix, Point2, SMatrix, SMatrixView, SMatrixViewMut, SVector,
    Vector2,
};
use serde::{Deserialize, Deserializer, Serialize};
use thiserror::Error;

use crate::{
    filter::{
        self, noise, sigma_order, FilterState, ImuFilter, MathError,
        PredictionConfig, UpdateConfig,
    },
    model::normalize_angle,
    pipeline,
};
use roboq_types::model::{
    debug::{DebugData, ErrorCause},
    localization::{self, FilterModel},
    pose::AccelerationPose2D,
};

use super::{LocalizationError, MotionEstimationConfig, NoiseConfig};
use crate::model::pose::{Pose2D, VelocityPose2D};
use roboq_types::model::localization::{
    ControlInput, LocalizationMetadata, RobotState, SensorEvent,
};

use std::{
    f32,
    time::{Duration, Instant, SystemTime},
    vec,
};

pub const ACCEL_MODEL_X: usize = 0;
pub const ACCEL_MODEL_V_X: usize = 1;
pub const ACCEL_MODEL_A_X: usize = 2;
pub const ACCEL_MODEL_Y: usize = 3;
pub const ACCEL_MODEL_V_Y: usize = 4;
pub const ACCEL_MODEL_A_Y: usize = 5;
pub const ACCEL_MODEL_THETA: usize = 6;
pub const ACCEL_MODEL_V_THETA: usize = 7;
pub const ACCEL_MODEL_A_THETA: usize = 8;
pub const ACCEL_MODEL_STATE_SIZE: usize = 9;
pub const ACCELERATION_MODEL_SIGMA_ORDER: usize =
    sigma_order(ACCEL_MODEL_STATE_SIZE);

// pub const VELOCITY_MODEL_X:usize = 0;
// pub const VELOCITY_MODEL_V_X:usize = 1;
// pub const VELOCITY_MODEL_A_X:usize = 2;
// pub const VELOCITY_MODEL_Y:usize = 3;
// pub const VELOCITY_MODEL_V_Y:usize = 4;
// pub const VELOCITY_MODEL_A_Y:usize = 5;
// pub const VELOCITY_MODEL_THETA:usize = 6;
// pub const VELOCITY_MODEL_V_THETA:usize = 7;
// pub const VELOCITY_MODEL_STATE_SIZE: usize = 8;
// pub const VELOCITY_MODEL_SIGMA_ORDER: usize =
//     sigma_order(VELOCITY_MODEL_STATE_SIZE);

pub const SCAN_X: usize = 0;
pub const SCAN_Y: usize = 1;
pub const SCAN_THETA: usize = 2;
pub const IMU_THETA: usize = 3;
pub const IMU_V_THETA: usize = 4;
pub const IMU_A_X: usize = 5;
pub const IMU_A_Y: usize = 6;
pub const GPS_X: usize = 7;
pub const GPS_Y: usize = 8;
pub const COMPASS_THETA: usize = 9;
pub const MEASUREMENT_SIZE: usize = 10;

pub type KallmanFilter = filter::KallmanFilter<
    ACCEL_MODEL_STATE_SIZE,
    MEASUREMENT_SIZE,
    ACCELERATION_MODEL_SIGMA_ORDER,
>;

#[derive(Debug, Error)]
pub enum LifetimeError {
    #[error("No data update event for state")]
    BiasedState,
    /// No events from external sensors (only compass or imu)
    #[error("No events for position. Only rotaion is supplied")]
    BiasedPosition(f32),
}

impl From<LifetimeError> for ErrorCause {
    fn from(_value: LifetimeError) -> Self {
        Self::BiasedState
    }
}

/// Motion estimation based on KallmanFilter.
#[derive(Debug, Serialize, Deserialize)]
pub struct MotionEstimation {
    #[serde(default, skip)]
    //consider to remove config
    pub config: MotionEstimationConfig,

    #[serde(default, skip)] //todo: provide initial state as default value
    pub states: Vec<
        FilterState<
            ACCEL_MODEL_STATE_SIZE,
            MEASUREMENT_SIZE,
            ACCELERATION_MODEL_SIGMA_ORDER,
        >,
    >,
    #[serde(default, skip)]
    pub events: Vec<SensorEvent>,
    #[serde(default, skip)]
    pub last_control_input: Option<ControlInput>,

    #[serde(deserialize_with = "deserialize_ukf")]
    pub ukf_filter: KallmanFilter,

    //only exists when imu event applied without lidar
    #[serde(default, skip)]
    pub imu_filter: Option<ImuFilter>,

    #[serde(default, skip)]
    pub debug_tx: Option<pipeline::Sender<DebugData>>,

    //cacheable events to prevent
    //unneccassary allocations
    #[serde(default, skip)]
    pub after_events: Vec<SensorEvent>,
    #[serde(default, skip)]
    pub before_events: Vec<SensorEvent>,
}

// x, y, x', y', X'', Y'', yaw
impl MotionEstimation {
    pub fn new(
        start_position: Pose2D,
        config: MotionEstimationConfig,
    ) -> MotionEstimation {
        let mut ukf_filter = filter::KallmanFilter::<
            ACCEL_MODEL_STATE_SIZE,
            MEASUREMENT_SIZE,
            ACCELERATION_MODEL_SIGMA_ORDER,
        >::new();
        ukf_filter.state = {
            let state = RobotState {
                position: start_position,
                velocity: VelocityPose2D::zeros(),
                acceleration: AccelerationPose2D::zeros(),
            };

            to_state_matrix(&state)
        };

        ukf_filter
            .state_noise
            .copy_from(&accel_state_noise_from_config(
                &config.noise,
                config.epoch_duration_ms as f32 / 1000.0,
            ));

        ukf_filter
            .meas_noise
            .copy_from(&meas_noise_from_config(&config.noise));

        ukf_filter.covariance.scale_mut(0.5);

        let initial_state = ukf_filter.state_snapshot(SystemTime::now());
        log::info!("State matrix: {}", ukf_filter.state);

        Self {
            ukf_filter,
            config,
            imu_filter: None,
            last_control_input: None,
            states: vec![initial_state],
            events: vec![],
            before_events: vec![],
            after_events: vec![],
            debug_tx: None,
        }
    }

    pub fn set_control_input(&mut self, control: ControlInput) {
        if !self.config.params.use_control_input {
            return;
        }

        self.after_events.clear();
        self.before_events.clear();

        for event in self.events.iter() {
            if control.timestamp > event.arrival_time() {
                self.before_events.push(*event);
            } else {
                self.after_events.push(*event);
            }
        }

        self.events.clear();

        self.events.extend_from_slice(&self.before_events);
        self.events.push(control.into());
        self.events.extend_from_slice(&self.after_events);

        self.last_control_input = Some(control);
    }

    pub fn update_with_config(&mut self, config: &MotionEstimationConfig) {
        self.ukf_filter
            .meas_noise
            .copy_from(&meas_noise_from_config(&config.noise));

        self.ukf_filter
            .state_noise
            .copy_from(&accel_state_noise_from_config(
                &config.noise,
                config.epoch_duration_ms as f32 / 1000.0,
            ));

        self.ukf_filter.covariance = SMatrix::identity() * 0.5;

        self.imu_filter = None;
        self.config = config.clone();
    }

    /// There is obligatory to enable SYNC_STATE in nav2 module
    /// to ensure that robot is really stopped
    pub fn reset_with_position(&mut self, position: Pose2D) {
        self.events.clear();
        self.states.clear();

        let state = RobotState {
            position,
            velocity: VelocityPose2D::zeros(),
            acceleration: AccelerationPose2D::zeros(),
        };

        update_state_matrix(self.ukf_filter.state.as_view_mut(), state);

        self.ukf_filter.covariance = SMatrix::identity() * 0.5;

        self.imu_filter = None;
    }

    /// Apply data event
    /// If all is fine then method return current mahalanobis distance
    /// for state
    pub fn update_with_data_event(
        &mut self,
        pending_event: SensorEvent,
    ) -> Result<Option<f32>, LocalizationError> {
        assert!(!pending_event.is_control_input());

        if !self.has_valid_lifetime(&pending_event) {
            log::debug!("Old data event had come");
            return Err(LocalizationError::BadLifetime);
        }

        let time_start = Instant::now();

        // timestamp here means nothing
        // saved to restore after unreliable events
        let prev_state = self.ukf_filter.state_snapshot(SystemTime::now());

        let mut after_events = Vec::new();

        let mut observation_time;

        //check that given event can be applied by the same manner as
        //pending
        let filter_event = |event: SensorEvent| -> Option<SensorEvent> {
            if pending_event.is_positional() && !event.is_positional() {
                None
            } else {
                event.into()
            }
        };

        if let Some(closest_state) =
            find_closest_state(&self.states, pending_event.arrival_time())
        {
            assert!(
                pending_event
                    .arrival_time()
                    .duration_since(closest_state.timestamp)
                    .is_ok(),
                "State is valid"
            );

            let events =
                find_events_after(&self.events, closest_state.timestamp);

            assert!(events.is_sorted_by_key(|e| e.arrival_time()));

            observation_time = closest_state.timestamp;

            // update the current filter representation by
            // incoming data events
            self.ukf_filter.reset_with_state(closest_state);

            events
                .into_iter()
                .filter_map(filter_event)
                .for_each(|event| {
                    if event.arrival_time() >= pending_event.arrival_time() {
                        after_events.push(event);
                        return;
                    }

                    log::trace!("Applying old event: {event:?}");

                    self.apply_event(event, observation_time)
                        .expect("Old data events is fine");

                    observation_time = event.arrival_time();
                });
        } else {
            observation_time = pending_event.arrival_time();
        }

        log::debug!(
            "dt for event: {}",
            pending_event
                .arrival_time()
                .duration_since(observation_time)
                .map(|d| d.as_secs_f32())
                .unwrap_or(f32::NAN)
        );

        if let Err(cause) = self.apply_event(pending_event, observation_time) {
            self.ukf_filter.reset_with_state(prev_state);
            return Err(cause);
        }

        let maybe_mahalanobis = self.ukf_filter.mahalanobis();

        if let Some(mahalanobis) = maybe_mahalanobis {
            if mahalanobis > self.config.max_mahalanobis {
                self.ukf_filter.reset_with_state(prev_state);
                return Err(LocalizationError::HighMahalanobis(mahalanobis));
            }
        }

        //if any event had come
        //we propagate observation time
        observation_time = pending_event.arrival_time();

        for event in after_events.into_iter() {
            match self.apply_event(event, observation_time) {
                Ok(()) => {
                    observation_time = event.arrival_time();
                }

                Err(cause) => {
                    log::debug!("Failed to apply after event: {cause}");
                }
            }
        }

        if let Some(ref debugger) = self.debug_tx {
            let debug_data = LocalizationMetadata {
                mahalanobis: maybe_mahalanobis.unwrap_or(f32::NAN),
                cause_event: pending_event,
                state: self.get_estimated_state_unchecked(),
                filter: (&self.ukf_filter).into(),
                elapsed_time: time_start.elapsed(),
                time: Default::default(),
            };

            let _ = debugger.try_send(debug_data.into()).inspect_err(|cause| {
                log::trace!("Nav debug channel is full: {cause}");
            });
        }

        // remove old states and events
        self.clean_up();

        self.events.push(pending_event);

        // new filter_state is assigned with timestamp
        // with data event arrival time
        if pending_event.is_positional() {
            let state = self.get_estimated_state_unchecked();

            self.ukf_filter.state = to_state_matrix(&state);

            self.states.push(
                self.ukf_filter.state_snapshot(pending_event.arrival_time()),
            );
        }

        log::debug!("New event is applied: {:?}", pending_event);

        Ok(maybe_mahalanobis)
    }

    /// Use underlying old state for robot
    /// As state is biased this method should be called with attention
    pub fn get_estimated_state_unchecked(&self) -> RobotState {
        let mut state = from_state_matrix(
            self.ukf_filter.state.as_view(),
            self.config.params.model,
        );

        if let Some(filter) = self.imu_filter.as_ref() {
            state.position.heading_rad = filter.state().theta;
            state.velocity.angular = filter.state().v_theta;
        }

        state
    }

    /// All state consumer, except event producers, should prefere this method
    pub fn get_estimated_state(&mut self) -> Result<RobotState, LifetimeError> {
        self.clean_up();

        if self.events.is_empty() {
            return Err(LifetimeError::BiasedState);
        }

        let state = self.get_estimated_state_unchecked();

        //at least one event is used for new state
        if !self.events.iter().any(|e| e.is_positional()) {
            return Err(LifetimeError::BiasedPosition(
                state.position.heading_rad,
            ));
        }

        Ok(state)
    }

    // same as `get_estimated_state` by interpolate time
    pub fn get_interpolated_state(
        &mut self,
        time: SystemTime,
    ) -> Result<RobotState, LifetimeError> {
        log::debug!("State matrix: {}", self.ukf_filter.state);

        let Some(state_in_past) = find_closest_state(&self.states, time) else {
            return self.get_estimated_state();
        };

        let dt_secs = {
            let duration = time
                .duration_since(state_in_past.timestamp)
                .expect("State is later");
            duration.as_secs_f32()
        };

        let current_state = self.ukf_filter.state_snapshot(SystemTime::now());

        self.ukf_filter.reset_with_state(state_in_past);

        let model = self.config.params.model;

        let Ok((state, _covariance)) = self.predict(dt_secs) else {
            log::warn!("Failed to interpolate state");

            let robot_state_in_past = self.get_estimated_state(); //get state in past
            self.ukf_filter.reset_with_state(current_state);
            return robot_state_in_past;
        };

        Ok(from_state_matrix(state, model))
    }

    fn clean_up(&mut self) {
        let max_lifetime =
            Duration::from_millis(self.config.lifetime_duration_ms);
        // which sensor will be proccessed more then 3
        let time_now = SystemTime::now();
        self.events.retain(|e| {
            let Ok(lifetime) = time_now.duration_since(e.arrival_time()) else {
                log::warn!("Event in future!");
                return true; //why not?)
            };

            lifetime < max_lifetime
        });

        self.states.retain(|s| {
            let Ok(lifetime) = time_now.duration_since(s.timestamp) else {
                log::warn!("State in future!");
                return true;
            };

            lifetime < max_lifetime
        });
    }

    fn predict(
        &mut self,
        dt: f32,
    ) -> Result<
        (
            SMatrixView<f32, 1, ACCEL_MODEL_STATE_SIZE>,
            SMatrixView<f32, ACCEL_MODEL_STATE_SIZE, ACCEL_MODEL_STATE_SIZE>,
        ),
        MathError,
    > {
        let maybe_control = self.last_control_input.take();

        let model = self.config.params.model;

        #[rustfmt::skip]
        let next_state_fn =
            move |prev_state: SMatrixView<f32, 1, ACCEL_MODEL_STATE_SIZE>| {
                if let Some(control) = maybe_control {
                    let state = from_state_matrix(prev_state, model);

                    let next_state =
                        apply_control_input(&state, control, dt);

                    to_state_matrix(&next_state)
                } else {
                    let transform = match model {
                        localization::FilterModel::Linear => {
                            SMatrix::<f32, ACCEL_MODEL_STATE_SIZE, ACCEL_MODEL_STATE_SIZE>::from_row_slice(
                                &[
                                    1.0, dt, dt.powi(2) / 2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, //x = x + v_x * dt + a_x * dt^2 / 2
                                    0.0, 1.0, dt, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,// v_x = v_x + a_x * dt
                                    0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, // a_x = const

                                    0.0, 0.0, 0.0, 1.0, dt, dt.powi(2) / 2.0, 0.0, 0.0, 0.0, //y = y + v_y * dt + a_y * dt^2 / 2
                                    0.0, 0.0, 0.0, 0.0, 1.0, dt, 0.0, 0.0, 0.0, //v_y = v_y + a_y * dt
                                    0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, // a_y = const 

                                    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, dt, 0.5 * dt.powi(2), // theta = theta + v_theta * dt
                                    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, dt, // v_theta = const 
                                    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, // a_theta = const 
                                ],
                            )
                        },

                        localization::FilterModel::SinCosLinear => {
                            let theta = prev_state[ACCEL_MODEL_THETA];
                            let ct = f32::cos(theta);
                            let st = f32::sin(theta);

                            SMatrix::<f32, ACCEL_MODEL_STATE_SIZE, ACCEL_MODEL_STATE_SIZE>::from_row_slice(
                                &[
                                    1.0, ct * dt, ct * dt.powi(2) / 3.0, 0.0, -st * dt, -st * dt.powi(2) / 2.0, 0.0, 0.0, 0.0, //x = x + ct * v_x * dt + ct * a_x * dt^2 / 2 - st * v_y - st * a_y * dt^2 / 2
                                    0.0, 1.0, dt, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, // v_x = v_x + a_x * dt
                                    0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, // a_x = const

                                    0.0, st * dt, st * dt.powi(2) / 2.0, 1.0, ct * dt, ct * dt.powi(2) / 2.0, 0.0, 0.0, 0.0, //y = y + st * v_x * dt + st * a_x * dt^2 / 2 +  ct * v_y * dt + a_y * dt^2 / 2
                                    0.0, 0.0, 0.0, 0.0, 1.0, dt, 0.0, 0.0, 0.0, //v_y = v_y + a_y * dt
                                    0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, // a_y = const 

                                    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, dt, 0.5 * dt.powi(2),// theta = theta + v_theta * dt
                                    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, dt, // v_theta = const 
                                    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, // theta_bias = const 
                                ],
                            )

                        },
                    };

                    let next_state = transform * prev_state.transpose();

                    next_state.transpose()
                }

                // next_state[THETA] = normalize_angle(next_state[THETA]);
            };

        //making prediction saved prior results internally
        self.ukf_filter.predict(PredictionConfig {
            next_state: next_state_fn,
            mean_transform: state_mean,
            state_sub: state_residual,
        })
    }

    // Trying to apply event to robot state
    // Imu event change internal ahrs state
    // Only lidar and gps change robot state
    fn apply_event(
        &mut self,
        event: SensorEvent,
        observation_time: SystemTime,
    ) -> Result<(), LocalizationError> {
        let dt_secs = event
            .arrival_time()
            .duration_since(observation_time)
            .inspect_err(|_cause| {
                log::error!(
                    "Reversed time for event={:?} with obs_time={:?}",
                    event,
                    observation_time
                );
            })
            .expect("Time goes in reverse order")
            .as_secs_f32()
            .max(0.001);

        let mut indices = Vec::<usize>::new();
        let mut meas_matrix = SVector::<f32, MEASUREMENT_SIZE>::zeros();

        match event {
            SensorEvent::MatchedPose(data) => {
                meas_matrix[SCAN_X] = data.coords.x;
                meas_matrix[SCAN_Y] = data.coords.y;
                meas_matrix[SCAN_THETA] = data.heading_rad;

                indices.push(SCAN_X);
                indices.push(SCAN_Y);
                indices.push(SCAN_THETA);

                self.imu_filter = None;

                // if let Some(filter) = self.imu_filter.take() {
                //     // meas_matrix[IMU_THETA] = filter.state().theta;
                //     meas_matrix[IMU_V_THETA] = filter.state().v_theta;
                //
                //     // indices.push(IMU_THETA);
                //     indices.push(IMU_V_THETA);
                // }
            }

            SensorEvent::Imu(data) => {
                let mut filter: ImuFilter =
                    self.imu_filter.take().unwrap_or_else(|| {
                        ImuFilter::new(
                            self.config.epoch_duration_ms as f32 / 1000.0,
                            &self.get_estimated_state_unchecked(),
                            &self.config.noise,
                        )
                    });

                let (_accel, gyro) = *data;
                filter.predict(dt_secs)?;
                filter
                    .update(
                        dt_secs,
                        self.config.params.imu_filter,
                        &self.config.noise,
                        gyro,
                    )
                    .inspect_err(|cause| {
                        log::warn!("Failed to update: {cause}")
                    })?;

                let mut should_update = false;
                if self.config.params.use_ahrs_heading {
                    meas_matrix[IMU_THETA] = filter.state().theta;
                    indices.push(IMU_THETA);

                    should_update = true;
                }

                if self.config.params.use_gyro_angular {
                    meas_matrix[IMU_V_THETA] = filter.state().v_theta;
                    indices.push(IMU_V_THETA);

                    should_update = true;
                }

                self.imu_filter = filter.into();

                if !should_update {
                    return Ok(());
                }
            }

            SensorEvent::GpsCoords(data) => {
                log::trace!("Gps coords: {}", data.coords);
                meas_matrix[GPS_X] = data.coords.x;
                meas_matrix[GPS_Y] = data.coords.y;

                indices.push(GPS_X);
                indices.push(GPS_Y);
            }

            SensorEvent::ControlInput(input) => {
                log::debug!("Control input will be set");
                self.last_control_input = input.into();
                return Ok(());
            }

            SensorEvent::CompassRotation(data) => {
                log::trace!("Compass theta: {:?}", *data);

                meas_matrix[COMPASS_THETA] = *data;

                indices.push(COMPASS_THETA);
            }
        }

        let transform = build_dyn_transform(&indices);

        let _ = self.predict(dt_secs)?;

        self.ukf_filter.update(
            &meas_matrix.transpose(),
            Some(transform),
            UpdateConfig {
                state_to_meas,
                mean_transform: meas_mean,
                meas_sub: meas_residual,
                state_sub: state_residual,
            },
        )?;

        Ok(())
    }

    fn has_valid_lifetime(&self, event: &SensorEvent) -> bool {
        //truly, all states are already sorted by timestamp
        let Some(state) =
            self.states.iter().min_by_key(|state| state.timestamp)
        else {
            //old states were removed?
            return true;
        };

        state.timestamp < event.arrival_time()
    }
}

fn apply_control_input(
    state: &RobotState,
    control: ControlInput,
    dt: f32,
) -> RobotState {
    let v = control.velocity;

    let next_coords = state.position.coords + v.translation * dt;

    let next_heading = state.position.heading_rad + v.angular * dt;

    RobotState {
        position: Pose2D {
            coords: next_coords,
            heading_rad: next_heading,
        },
        velocity: state.velocity,
        //constant velocity model
        //therefore acceleration
        acceleration: AccelerationPose2D {
            angular: (control.velocity.angular - state.velocity.angular) / dt,
            linear: (control.velocity.translation - state.velocity.translation)
                / dt,
        },
    }
}

#[must_use]
fn to_state_matrix(
    RobotState {
        position,
        velocity,
        acceleration,
    }: &RobotState,
) -> SMatrix<f32, 1, ACCEL_MODEL_STATE_SIZE> {
    let state = SVector::<f32, ACCEL_MODEL_STATE_SIZE>::from_row_slice(&[
        position.coords.x,
        velocity.translation.x, //v_x
        acceleration.linear.x,  //a_x
        position.coords.y,
        velocity.translation.y, //v_y
        acceleration.linear.y,  //v_y
        position.heading_rad,
        velocity.angular, //angular
        0.0,              //theta bias
    ]);

    state.transpose()
}

#[must_use]
fn from_state_matrix(
    prev_state: SMatrixView<f32, 1, ACCEL_MODEL_STATE_SIZE>,
    model: FilterModel,
) -> RobotState {
    let heading = prev_state[ACCEL_MODEL_THETA];

    let velocity = match model {
        FilterModel::Linear => VelocityPose2D {
            angular: prev_state[ACCEL_MODEL_V_THETA],
            translation: Vector2::new(
                prev_state[ACCEL_MODEL_V_X],
                prev_state[ACCEL_MODEL_V_Y],
            ),
        },

        FilterModel::SinCosLinear => VelocityPose2D {
            angular: prev_state[ACCEL_MODEL_V_THETA],
            translation: Vector2::new(
                prev_state[ACCEL_MODEL_V_X],
                prev_state[ACCEL_MODEL_V_Y],
            ),
        }
        .into_map(heading),
    };

    let (a_x, a_y) = match model {
        FilterModel::Linear => {
            (prev_state[ACCEL_MODEL_A_X], prev_state[ACCEL_MODEL_A_Y])
        }

        FilterModel::SinCosLinear => {
            let a_forward = prev_state[ACCEL_MODEL_A_X];
            let a_lateral = prev_state[ACCEL_MODEL_A_Y];
            let theta = heading;

            (
                a_forward * theta.cos() - a_lateral * theta.sin(),
                a_forward * theta.sin() + a_lateral * theta.sin(),
            )
        }
    };

    RobotState {
        position: Pose2D {
            coords: Point2::new(
                prev_state[ACCEL_MODEL_X],
                prev_state[ACCEL_MODEL_Y],
            ),
            heading_rad: heading,
        },
        velocity,
        acceleration: AccelerationPose2D {
            linear: Vector2::new(a_x, a_y),
            angular: 0.0,
        },
    }
}

fn update_state_matrix(
    mut state_matrix: SMatrixViewMut<f32, 1, ACCEL_MODEL_STATE_SIZE>,
    state: RobotState,
) {
    state_matrix[ACCEL_MODEL_X] = state.position.coords.x;
    state_matrix[ACCEL_MODEL_Y] = state.position.coords.y;
    state_matrix[ACCEL_MODEL_THETA] = state.position.heading_rad;

    state_matrix[ACCEL_MODEL_V_X] = state.velocity.translation.x;
    state_matrix[ACCEL_MODEL_V_Y] = state.velocity.translation.y;
    state_matrix[ACCEL_MODEL_V_THETA] = state.velocity.angular;

    state_matrix[ACCEL_MODEL_A_X] = state.acceleration.linear.x;
    state_matrix[ACCEL_MODEL_A_Y] = state.acceleration.linear.y;

    state_matrix[ACCEL_MODEL_A_THETA] = 0.0;
}

fn state_mean(
    weights: SMatrixView<f32, 1, ACCELERATION_MODEL_SIGMA_ORDER>,
    sigmas: SMatrixView<
        f32,
        ACCELERATION_MODEL_SIGMA_ORDER,
        ACCEL_MODEL_STATE_SIZE,
    >,
) -> SMatrix<f32, 1, ACCEL_MODEL_STATE_SIZE> {
    let theta = {
        let column = sigmas.column(ACCEL_MODEL_THETA).transpose();

        let sum_sin = weights.dot(&column.map(f32::sin));
        let sum_cos = weights.dot(&column.map(f32::cos));
        f32::atan2(sum_sin, sum_cos)
    };

    let v_theta = weights.dot(&sigmas.column(ACCEL_MODEL_V_THETA).transpose());

    let x = weights.dot(&sigmas.column(ACCEL_MODEL_X).transpose());
    let y = weights.dot(&sigmas.column(ACCEL_MODEL_Y).transpose());

    let v_x = weights.dot(&sigmas.column(ACCEL_MODEL_V_X).transpose());
    let v_y = weights.dot(&sigmas.column(ACCEL_MODEL_V_Y).transpose());

    let a_x = weights.dot(&sigmas.column(ACCEL_MODEL_A_X).transpose());
    let a_y = weights.dot(&sigmas.column(ACCEL_MODEL_A_Y).transpose());

    let accel = weights.dot(&sigmas.column(ACCEL_MODEL_A_THETA).transpose());

    SMatrix::from_row_slice(&[x, v_x, a_x, y, v_y, a_y, theta, v_theta, accel])
}

//state generated by other events

#[rustfmt::skip]
fn accel_state_noise_from_config(
    config: &NoiseConfig,
    dt: f32,
) -> SMatrix<f32, ACCEL_MODEL_STATE_SIZE, ACCEL_MODEL_STATE_SIZE> {
    let mut state_noise = SMatrix::<f32, ACCEL_MODEL_STATE_SIZE, ACCEL_MODEL_STATE_SIZE>::zeros();

        state_noise.view_range_mut(0..3, 0..3).copy_from(
            &noise::discrete_white::<3, 1, 3>(
                dt,
                config.state_coords,
            ),
        );

        state_noise.view_range_mut(3..6, 3..6).copy_from(
            &noise::discrete_white::<3, 1, 3>(
                dt,
                config.state_coords,
            ),
        );

        state_noise.view_range_mut(6..9, 6..9).copy_from(
            &noise::discrete_white::<3, 1, 3>(
                dt,
                config.state_heading,
            ),
        );


        // state_noise[ACCEL_MODEL_A_THETA] = config.gyro_bias;

        state_noise
}

#[rustfmt::skip]
fn meas_noise_from_config(
    config: &NoiseConfig,
) -> SMatrix<f32, MEASUREMENT_SIZE, MEASUREMENT_SIZE> {
    let diag = SVector::from_row_slice(&[
        config.lidar_pose,        //lidar_x
        config.lidar_pose,        //lidar_y
        config.lidar_heading,     //lidar_theta

        config.ahrs_heading,       //imu_theta
        config.gyro,               //imu_v_theta
        config.accel,              //imu_a_x
        config.accel,              //imu_a_y

        //gps will changed dynamically
        #[cfg(feature = "gps")]
        config.gps_pose, //gps_x
        #[cfg(feature = "gps")]
        config.gps_pose, //gps_y
        #[cfg(not(feature = "gps"))]
        f32::MAX,
        #[cfg(not(feature = "gps"))]
        f32::MAX,

        #[cfg(feature = "compass")]
        config.compass,  //compass_theta
        #[cfg(not(feature = "compass"))]
        f32::MAX
    ]);


    SMatrix::from_diagonal(&diag)
}

pub fn deserialize_ukf<'de, D>(
    deserializer: D,
) -> Result<KallmanFilter, D::Error>
where
    D: Deserializer<'de>,
{
    let filter = KallmanFilter::deserialize(deserializer)?;

    // filter.meas_noise.copy_from(&default_meas_noise());

    Ok(filter)
}

fn state_to_meas(
    state: SMatrixView<f32, 1, ACCEL_MODEL_STATE_SIZE>,
) -> SMatrix<f32, 1, MEASUREMENT_SIZE> {
    SMatrix::from_column_slice(&[
        state[ACCEL_MODEL_X],
        state[ACCEL_MODEL_Y],
        state[ACCEL_MODEL_THETA],
        state[ACCEL_MODEL_THETA],
        state[ACCEL_MODEL_V_THETA],
        state[ACCEL_MODEL_A_X],
        state[ACCEL_MODEL_A_Y],
        state[ACCEL_MODEL_X],
        state[ACCEL_MODEL_Y],
        state[ACCEL_MODEL_THETA],
    ])
}

fn state_residual<const N: usize>(
    s1: SMatrixView<f32, 1, N>,
    s2: SMatrixView<f32, 1, N>,
) -> SMatrix<f32, 1, N> {
    let mut s = s1 - s2;
    s[ACCEL_MODEL_THETA] = normalize_angle(s[ACCEL_MODEL_THETA]);
    s
}

fn build_dyn_transform(
    indices: &[usize],
) -> OMatrix<f32, Dyn, Const<MEASUREMENT_SIZE>> {
    let mut matrix =
        OMatrix::<f32, Dyn, Const<MEASUREMENT_SIZE>>::zeros(indices.len());

    for (col_i, row_i) in indices.iter().enumerate() {
        matrix[(col_i, *row_i)] = 1.0;
    }

    matrix
}

fn meas_mean(
    weights: SMatrixView<f32, 1, ACCELERATION_MODEL_SIGMA_ORDER>,
    sigmas: SMatrixView<f32, ACCELERATION_MODEL_SIGMA_ORDER, MEASUREMENT_SIZE>,
) -> SMatrix<f32, 1, MEASUREMENT_SIZE> {
    let column = sigmas.column(SCAN_THETA).transpose();

    let sum_sin = weights.dot(&column.map(f32::sin));
    let sum_cos = weights.dot(&column.map(f32::cos));

    let lidar_theta = f32::atan2(sum_sin, sum_cos);

    let column = sigmas.column(IMU_THETA).transpose();

    let sum_sin = weights.dot(&column.map(f32::sin));
    let sum_cos = weights.dot(&column.map(f32::cos));

    let imu_theta = f32::atan2(sum_sin, sum_cos);

    let imu_v_theta = weights.dot(&sigmas.column(IMU_V_THETA).transpose());
    let imu_a_x = weights.dot(&sigmas.column(IMU_A_X).transpose());
    let imu_a_y = weights.dot(&sigmas.column(IMU_A_Y).transpose());

    let x = weights.dot(&sigmas.column(SCAN_X).transpose());
    let y = weights.dot(&sigmas.column(SCAN_Y).transpose());

    let gps_x = weights.dot(&sigmas.column(GPS_X).transpose());
    let gps_y = weights.dot(&sigmas.column(GPS_Y).transpose());

    let compass_theta = weights.dot(&sigmas.column(COMPASS_THETA).transpose());

    SMatrix::from_row_slice(&[
        x,
        y,
        lidar_theta,
        imu_theta,
        imu_v_theta,
        imu_a_x,
        imu_a_y,
        gps_x,
        gps_y,
        compass_theta,
    ])
}

fn meas_residual(
    m1: SMatrixView<f32, 1, MEASUREMENT_SIZE>,
    m2: SMatrixView<f32, 1, MEASUREMENT_SIZE>,
) -> SMatrix<f32, 1, MEASUREMENT_SIZE> {
    let mut m = m1 - m2;
    m[SCAN_THETA] = normalize_angle(m[SCAN_THETA]);
    m[IMU_THETA] = normalize_angle(m[IMU_THETA]);
    m[COMPASS_THETA] = normalize_angle(m[COMPASS_THETA]);
    m
}

/// return filter state closest to given time
/// that is ensured that timestamp is state in past
fn find_closest_state<const N: usize, const K: usize, const S: usize>(
    states: &[FilterState<N, K, S>],
    time: SystemTime,
) -> Option<FilterState<N, K, S>> {
    states
        .iter()
        .flat_map(|state| {
            time.duration_since(state.timestamp)
                .ok()
                .map(|duration| (duration.as_secs_f64(), state))
        })
        .min_by(|(dist1, _), (dist2, _)| dist1.total_cmp(dist2))
        .map(|(_dist, state)| state)
        .cloned()
}

/// sorted by time
fn find_events_after(
    events: &[SensorEvent],
    time: SystemTime,
) -> Vec<SensorEvent> {
    let mut events = events
        .iter()
        .filter(|meas| meas.arrival_time() > time)
        .cloned()
        .collect::<Vec<_>>();

    events.sort_by_key(|e| e.arrival_time());

    events
}

impl<'a> From<&'a KallmanFilter> for localization::FilterState {
    fn from(value: &'a KallmanFilter) -> Self {
        use nalgebra::DMatrix;
        let meas_covariance = value.meas_covariance.as_ref().map(|sigmas| {
            DMatrix::from_iterator(
                sigmas.nrows(),
                sigmas.ncols(),
                sigmas.iter().copied(),
            )
        });

        Self {
            state_covariance: DMatrix::from_iterator(
                value.covariance.nrows(),
                value.covariance.ncols(),
                value.covariance.iter().copied(),
            ),
            meas_covariance,
        }
    }
}

==> ./localization/mod.rs <==
// pub mod amcl;
mod config;
mod error;
mod estimation;
mod transform;

pub use config::*;
pub use error::*;
pub use estimation::{KallmanFilter, LifetimeError, MotionEstimation};
pub use transform::*;

pub use crate::model::localization::*;

==> ./localization/transform.rs <==
use std::time::{Duration, SystemTime};

use nalgebra::{Point2, Rotation2, Vector2};
use serde::{Deserialize, Serialize};

use crate::model::normalize_angle_f64;

#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub struct WorldTransform {
    pub translation: Vector2<f64>,
    pub rotation: Rotation2<f64>,
    /// initial coords used to build world transform
    pub last_world_coords: Point2<f64>,

    #[serde(default, skip)]
    current_world_coords: Option<(Point2<f64>, SystemTime)>,
}

#[derive(Debug, Clone, Copy, Serialize, Default)]
pub struct WorldPoint {
    world_coords: Point2<f64>,
    odom_coords: Point2<f64>,
}

impl WorldPoint {
    pub fn new(odom_coords: Point2<f64>, world_coords: Point2<f64>) -> Self {
        Self {
            odom_coords: swap_coord_system(&odom_coords),
            world_coords,
        }
    }

    pub fn world_coords(&self) -> Point2<f64> {
        self.world_coords
    }

    pub fn odom_coords(&self) -> Point2<f64> {
        swap_coord_system(&self.odom_coords)
    }
}

impl WorldTransform {
    pub fn with_rotation(point: WorldPoint, map_rotation: f64) -> Self {
        let rotation = Rotation2::new(map_rotation);

        let translation = point.world_coords - rotation * point.odom_coords;

        Self {
            translation,
            rotation,
            last_world_coords: point.world_coords,
            current_world_coords: None,
        }
    }

    pub fn from_points(start: WorldPoint, end: WorldPoint) -> Self {
        let odom_delta = (end.odom_coords - start.odom_coords).normalize();
        let world_delta = (end.world_coords - start.world_coords).normalize();

        assert!(odom_delta.x != 0.0 && odom_delta.y != 0.0);
        // R is rotation matrix
        // X = R * X' + T

        let dot = odom_delta.dot(&world_delta);
        let det = world_delta.y * odom_delta.x - world_delta.x * odom_delta.y;

        let map_rotation = det.atan2(dot);

        // let rotation = Rotation2::new(angle);
        //
        // let translation = start.world_coords - rotation * start.odom_coords;

        Self::with_rotation(start, map_rotation)
    }

    pub fn set_current_coords(
        &mut self,
        coords: &Point2<f64>,
        valid_for: Duration,
    ) {
        let end_of_life = SystemTime::now() + valid_for;

        self.current_world_coords = Some((*coords, end_of_life));
    }

    pub fn current_coords(&self) -> Option<Point2<f64>> {
        if let Some((p, end_of_life)) = self.current_world_coords {
            if SystemTime::now() > end_of_life {
                None
            } else {
                Some(p)
            }
        } else {
            None
        }
    }

    pub fn set_map_rotation(&mut self, rotation: f64) {
        self.rotation = Rotation2::new(rotation);
    }

    pub fn map_rotation(&self) -> f64 {
        normalize_angle_f64(self.rotation.angle())
    }

    pub fn to_odom_from_world<T: nalgebra::RealField + Copy>(
        &self,
        point: &Point2<f64>,
    ) -> Point2<T> {
        let inverse = self.rotation.inverse();
        let translated = point - self.translation;

        let odom_coords = inverse * translated;

        let x = T::from_f64(odom_coords.x).unwrap();
        let y = T::from_f64(odom_coords.y).unwrap();

        swap_coord_system(&Point2::new(x, y))
    }

    pub fn from_odom_to_world(&self, point: &Point2<f32>) -> Point2<f64> {
        let odom_coords = swap_coord_system(point);

        let point = Point2::new(odom_coords.x as f64, odom_coords.y as f64);

        self.rotation * point + self.translation
    }
}

///translate odometry coordinate to world coords or wise verse
/// this method is identically works for world coords to odometry
fn swap_coord_system<T: nalgebra::RealField + Copy>(
    coords: &Point2<T>,
) -> Point2<T> {
    Point2::new(coords.x, -coords.y)
}

==> ./model/array2d.rs <==
use nalgebra::{Point2, Vector2};
use serde::{Deserialize, Serialize};

#[derive(Clone, Serialize, Deserialize)]
pub struct Array2D<T> {
    width: u32,
    height: u32,

    pub data: Vec<T>,
}

impl<T> Array2D<T> {
    pub fn empty() -> Self {
        Array2D {
            width: 0,
            height: 0,
            data: Vec::new(),
        }
    }

    pub fn new_from_row_major(width: u32, rows: Vec<T>) -> Self {
        assert!(rows.len() % width as usize == 0);
        let height = rows.len() as u32 / width;
        assert!(width == height);

        Array2D {
            width,
            height,
            data: rows,
        }
    }

    pub fn size(&self) -> Vector2<i32> {
        Vector2::new(self.width as i32, self.height as i32)
    }

    pub fn get_width(&self) -> i32 {
        self.width as i32
    }

    pub fn clamp_to_grid(&self, point: &Point2<i32>) -> Point2<i32> {
        let x = point.x.clamp(0, self.width as i32);
        let y = point.y.clamp(0, self.height as i32);
        Point2::new(x, y)
    }

    pub fn index(&self, point: &Point2<i32>) -> usize {
        (point.x + point.y * self.width as i32) as usize
    }

    #[must_use]
    pub fn index_grid(&self, point: &Point2<i32>) -> &T {
        let point = self.index(&self.clamp_to_grid(point));
        &self.data[point]
    }

    #[must_use]
    pub fn index_grid_mut(&mut self, point: &Point2<i32>) -> &mut T {
        let point = self.index(&self.clamp_to_grid(point));
        &mut self.data[point]
    }

    #[must_use]
    pub fn index_grid_unclamped(&self, point: &Point2<i32>) -> &T {
        let point = self.index(point);
        &self.data[point]
    }

    #[must_use]
    pub fn index_grid_mut_unclamped(&mut self, point: &Point2<i32>) -> &mut T {
        let point = self.index(point);
        &mut self.data[point]
    }

    pub fn from_index_to_xy(&self, index: usize) -> (usize, usize) {
        let y = index / self.width as usize;
        let x = index % self.width as usize;
        (x, y)
    }
}

impl<T: Default + Clone + Copy> Array2D<T> {
    pub fn new(width: u32, height: u32) -> Self {
        Array2D {
            width,
            height,
            data: vec![Default::default(); (width * height) as usize],
        }
    }

    pub fn new_square(size: u32) -> Self {
        Self::new(size, size)
    }

    pub fn fill(&mut self, element: T) {
        self.data.fill(element);
    }
}

impl<T> Default for Array2D<T> {
    fn default() -> Self {
        Self::empty()
    }
}

impl Array2D<u8> {
    pub fn create_blur_kernel(
        metres_per_px: f32,
        kernel_size_px: u32,
        smear_deviation: f32,
    ) -> Self {
        let kernel_size = kernel_size_px as i32;
        let mut kernel = vec![0u8; (kernel_size * kernel_size) as usize];

        for x in 0..kernel_size {
            for y in 0..kernel_size {
                let x_dist = (x - kernel_size / 2) as f32;
                let y_dist = (y - kernel_size / 2) as f32;
                let distance =
                    (x_dist * x_dist + y_dist * y_dist).sqrt() * metres_per_px;
                let z =
                    ((-0.5f32) * (distance / smear_deviation).powi(2)).exp();

                let index = (x + y * kernel_size) as usize;
                kernel[index] = (z * 255.0) as u8;
            }
        }

        Array2D {
            width: kernel_size as u32,
            height: kernel_size as u32,

            data: kernel,
        }
    }
}

==> ./model/big_map/map.rs <==
use nalgebra::Point2;
use roboq_types::model::map::MetresPerPixel;

use super::MapCellLock;

// use super::map_chunk::MapCellRef;

pub trait Map {
    fn grid_resolution(&self) -> MetresPerPixel;
    fn get_cell_int_pos(&self, position: &Point2<f32>) -> Point2<i32>;
    fn get_cell_at(&self, position: &Point2<f32>) -> Option<&MapCellLock>;

    fn get_points(&self) -> Vec<Point2<f32>>;
    fn add_points(&mut self, points: &[Point2<f32>]);
    fn clear_points(&mut self);
}

==> ./model/big_map/map_cell.rs <==
use nalgebra::{Point2, Vector2};
use roboq_types::model::{
    map::{MapCellData, MetresPerPixel},
    Metres,
};
use serde::{Deserialize, Serialize};

use crate::model::{
    big_map::transform::MapTransform,
    occupancy_grid::{GridCost, GridCostMut, OccupancyGrid},
};

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct MapCell {
    pub top_left: Point2<f32>,
    pub points: Vec<Point2<f32>>,
    pub occupancy_grid: OccupancyGrid,
}

impl MapCell {
    pub fn new(
        top_left: Point2<f32>,
        cell_size: Metres,
        occupancy_grid_resolution: MetresPerPixel,
    ) -> MapCell {
        let occupancy_grid_pixel_size =
            occupancy_grid_resolution.to_pixels(cell_size) as u32;

        MapCell {
            top_left,
            points: Vec::new(),
            occupancy_grid: OccupancyGrid::new_empty(
                occupancy_grid_pixel_size,
                occupancy_grid_pixel_size,
                occupancy_grid_resolution,
            ),
        }
    }

    pub fn get_points_and_grid(
        &mut self,
    ) -> (&mut Vec<Point2<f32>>, &mut OccupancyGrid) {
        (&mut self.points, &mut self.occupancy_grid)
    }

    /// convert world coordinates to underlying occupancy grid coords
    pub fn world_to_grid(&self, point: &Point2<f32>) -> Point2<i32> {
        let local_coords: Point2<f32> = (point - self.top_left).into();
        self.occupancy_grid.world_to_grid(&local_coords)
    }

    /// Get cell cost at a point with world coordinates
    pub fn index_grid(&self, point: &Point2<f32>) -> GridCost<'_> {
        let local_coords: Point2<f32> = (point - self.top_left).into();
        self.occupancy_grid.index_world(&local_coords)
    }

    /// Get cell cost at a point with world coordinates
    /// That's possible to modify given cost by reference
    pub fn index_grid_mut(&mut self, point: &Point2<f32>) -> GridCostMut<'_> {
        let local_coords: Point2<f32> = (point - self.top_left).into();
        self.occupancy_grid.index_world_mut(&local_coords)
    }

    //consider to remove all args
    pub fn as_transform(&self, id: usize, cell_size: Metres) -> MapTransform {
        let bottom_right = self.top_left + Vector2::new(*cell_size, *cell_size);

        MapTransform {
            id,
            top_left: self.top_left,
            bottom_right,
            resolution: self.occupancy_grid.resolution,
            width: self.occupancy_grid.width(),
        }
    }

    pub fn as_data_cell(&self) -> MapCellData {
        let (width, height, data) = self.occupancy_grid.as_bytes();

        MapCellData {
            top_left: self.top_left,
            resolution: self.occupancy_grid.resolution,
            width,
            height,
            data,
        }
    }
}

impl From<MapCellData> for MapCell {
    fn from(value: MapCellData) -> Self {
        Self {
            top_left: value.top_left,
            points: vec![],
            occupancy_grid: OccupancyGrid::new_with_data(
                value.width,
                value.height,
                value.resolution,
                value.data,
            ),
        }
    }
}

==> ./model/big_map/map_cell_lock.rs <==
use std::{ops::Deref, sync::{RwLock, RwLockReadGuard}};

use super::map_cell::MapCell;

pub struct MapCellLock(RwLock<MapCell>);

impl<'cell> Deref for MapCellLock {
    type Target = RwLockReadGuard<'cell, MapCell>;

    fn deref(&self) -> &Self::Target {


        todo!()
    }
}

==> ./model/big_map/map_chunk.rs <==
use std::ops::Deref;

use crate::{
    correlative_scan_matching::localized_range_scan::LocalizedRangeScan,
    model::{array2d::Array2D, occupancy_grid::OccupancyGrid, pose::Pose2D},
};
use nalgebra::{Point2, Vector2};
use roboq_types::model::{map::MetresPerPixel, Metres};

use super::{
    map_cell::MapCell, transform::MapTransform, Map, MapCellLock,
    MapChunkReadLock,
};

pub struct MapChunkGuard {
    pub top_left: Point2<f32>,
    pub cell_size: Metres,
    pub resolution: MetresPerPixel,
    pub chunk: Array2D<MapCellLock>,
}

impl MapChunkGuard {
    pub fn get_points(&self) -> Vec<Point2<f32>> {
        let mut points = Vec::new();
        for cell_lock in self.chunk.data.iter() {
            let cell = cell_lock.read().unwrap();

            for point in &cell.points {
                points.push(*point);
            }
        }

        points
    }

    /// Add ground truth points in chunk
    pub fn add_points(&self, points: &[Point2<f32>]) {
        for point in points {
            let local_chunk_coords = point - self.top_left;
            let x = (local_chunk_coords.x / self.cell_size.0).floor() as i32;
            let y = (local_chunk_coords.y / self.cell_size.0).floor() as i32;

            /* let target_chunk = self.top_left_corner
            + Vector2::new(x as f32 * self.cell_size.0, y as f32 * self.cell_size.0); */

            let cell_lock = self.chunk.index_grid_unclamped(&Point2::new(x, y));
            cell_lock.write().unwrap().points.push(*point);
        }
    }

    /// return this (i, j) of specific MapCell
    pub fn get_cell_int_pos(&self, position: &Point2<f32>) -> Point2<i32> {
        Point2::new(
            (position.x / self.cell_size.0).floor() as i32,
            (position.y / self.cell_size.0).floor() as i32,
        )
    }

    pub fn collect_transform(&self) -> Vec<MapTransform> {
        let mut transforms = vec![];

        for (id, cell_lock) in self.chunk.data.iter().enumerate() {
            let transform =
                cell_lock.read().unwrap().as_transform(id, self.cell_size);
            transforms.push(transform);
        }

        transforms
    }

    pub fn read(&self) -> MapChunkReadLock<impl Deref<Target = MapCell> + '_> {
        let chunk = self
            .chunk
            .data
            .iter()
            .map(|lock| lock.read().unwrap())
            .collect::<Vec<_>>();

        MapChunkReadLock {
            top_left: self.top_left,
            cell_size: self.cell_size,
            resolution: self.resolution,
            chunk,
        }
    }

    pub fn iter_cell(&self) -> impl Iterator<Item = MapCellLock> {
        let cells = self.chunk.data.clone();

        cells.into_iter()
    }

    pub fn get_cell_at(&self, pos: &Point2<f32>) -> Option<&MapCellLock> {
        // let local_chunk_coords = point - self.top_left;
        // let x = (local_chunk_coords.x / self.cell_size.0).floor() as i32;
        // let y = (local_chunk_coords.y / self.cell_size.0).floor() as i32;
        //
        // let cell_lock =
        //     self.chunk.index_grid_mut_unclamped(&Point2::new(x, y));
        //     cell_lock.write().unwrap().points.push(*point);

        for cell_lock in self.chunk.data.iter() {
            let top_left = {
                let cell = cell_lock.read().unwrap();
                cell.top_left
            };

            let right_bottom =
                top_left + Vector2::new(*self.cell_size, *self.cell_size);

            let coords = pos.coords;
            if coords.x >= top_left.x
                && coords.y >= top_left.y
                && coords.x < right_bottom.x
                && coords.y < right_bottom.y
            {
                return Some(cell_lock);
            }
        }
        None
    }
    /// Update the content of the corresponding `OccupancyGrid`
    /// based on the reachability of the points
    /// The Bresenham algorithm is used for ray-scan
    pub fn raycast_scan(
        &self,
        LocalizedRangeScan {
            points: scan_points,
            pose:
                Pose2D {
                    coords: scan_origin,
                    heading_rad: _,
                },
        }: &LocalizedRangeScan,
    ) {
        assert!(!self.chunk.data.is_empty());
        //what about case when no check available?
        // let chunk_resolution = self.chunk.data[0].occupancy_grid.resolution;
        let chunk_resolution = self.resolution;

        let convert_to_isize = |point: &Point2<f32>| {
            let point_px = chunk_resolution.point_to_pixels(point);
            (point_px.x as isize, point_px.y as isize)
        };
        let scan_origin = convert_to_isize(scan_origin);
        let (top_left_x, top_left_y) = convert_to_isize(&self.top_left);

        let chunk_pixel_size =
            self.chunk.data[0].read().unwrap().occupancy_grid.width();
        let cell_size_px = chunk_resolution.to_pixels(self.cell_size) as isize;
        assert_eq!(cell_size_px, chunk_pixel_size as isize);

        //retur chunk_id and chunk_pos
        let shit = |map_point: (isize, isize)| {
            let (mx, my) = map_point;
            let chunk_x = mx - top_left_x;
            let chunk_y = my - top_left_y;
            let chunk_id_x = chunk_x / cell_size_px;
            let chunk_id_y = chunk_y / cell_size_px;
            let chunk_pos_x = mx % cell_size_px;
            let chunk_pos_y = my % cell_size_px;
            (chunk_id_x, chunk_id_y, chunk_pos_x, chunk_pos_y)
        };

        for scan_point in scan_points.iter() {
            let target_point = convert_to_isize(scan_point);
            log::trace!("Origin={:?}. Mapped={:?}", scan_point, target_point);
            log::trace!("Start={:?}. Target={:?}", scan_origin, target_point);
            for map_point in
                bresenham::Bresenham::new(scan_origin, target_point)
            {
                let (chunk_id_x, chunk_id_y, chunk_pos_x, chunk_pos_y) =
                    shit(map_point);

                let mut chunk = self
                    .chunk
                    .index_grid(&Point2::new(
                        chunk_id_x as i32,
                        chunk_id_y as i32,
                    ))
                    .write()
                    .unwrap();

                chunk.occupancy_grid.inc_pass_count(&Point2::new(
                    chunk_pos_x as i32,
                    chunk_pos_y as i32,
                ));
            }

            let (chunk_id_x, chunk_id_y, chunk_pos_x, chunk_pos_y) =
                shit(target_point);

            let mut cell = self
                .chunk
                .index_grid(&Point2::new(chunk_id_x as i32, chunk_id_y as i32))
                .write()
                .unwrap();

            let p = Point2::new(chunk_pos_x as i32, chunk_pos_y as i32);
            cell.occupancy_grid.dec_pass_count(&p);
            cell.occupancy_grid.inc_hit_count(&p);
        }
    }

    // point: [194.9755, 204.60123] point_local_coords: [[14.975494, 9.601227]]
    // Point != i_point, {152, 98} != {153, 98}

    // point: [194.99133, 200.25208] point_local_coords: [[14.991333, 5.252075]]
    // Point != i_point, {152, 53} != {153, 53}

    // Remove points which are lying on the white of the map
    pub fn filter_points(&self) {
        let chunks_size = self.chunk.get_width();
        for x in 0..chunks_size {
            for y in 0..chunks_size {
                let mut map_cell =
                    self.chunk.index_grid(&Point2::new(x, y)).write().unwrap();

                let cell_top_left = Point2::new(
                    x as f32 * self.cell_size.0,
                    y as f32 * self.cell_size.0,
                ) + self.top_left.coords;
                //eprintln!("cell top left: {},{}", cell_top_left.x, cell_top_left.y);
                let (chunk_points, chunk_grid) = map_cell.get_points_and_grid();

                chunk_points.retain(|point| {
                    let point_local_coords = point - cell_top_left;
                    //eprintln!("point: {:?} point_local_coords: {:?}", point, point_local_coords);
                    *chunk_grid.index_world(&point_local_coords.into()) <= 128
                });
            }
        }
    }

    // REDO
    pub fn filter_temp_map(&self, grid: &OccupancyGrid) {
        let chunks_size = self.chunk.get_width();
        for x in 0..chunks_size {
            for y in 0..chunks_size {
                let mut chunk =
                    self.chunk.index_grid(&Point2::new(x, y)).write().unwrap();
                let _chunk_top_left = Point2::new(
                    x as f32 * self.cell_size.0,
                    y as f32 * self.cell_size.0,
                ) + self.top_left.coords;

                let (chunk_points, _chunk_grid) = chunk.get_points_and_grid();

                chunk_points.retain(|point| *grid.index_world(point) <= 128);
            }
        }
    }

    /// Clone all cells
    #[must_use]
    pub fn to_owned(&self) -> Self {
        let mut chunk = Array2D::empty();
        chunk.data = self
            .chunk
            .data
            .iter()
            .map(|lock| {
                let cell = lock.read().unwrap();
                std::sync::Arc::new(std::sync::RwLock::new(cell.clone()))
            })
            .collect();

        Self {
            top_left: self.top_left,
            cell_size: self.cell_size,
            resolution: self.resolution,
            chunk,
        }
    }
}

// impl<'cell> MapChunkGuard<MapCellLock<'cell>> {
//     pub fn clone_owned(&self) -> MapChunkGuard<Box<MapCell>> {
//         let data = self
//             .chunk
//             .data
//             .iter()
//             .map(|lock| Box::new(MapCell::clone(&lock)))
//             .collect::<Vec<Box<MapCell>>>();
//
//         MapChunkGuard {
//             top_left: self.top_left,
//             cell_size: self.cell_size,
//             resolution: self.resolution,
//             chunk: Array2D::new_from_row_major(
//                 self.chunk.get_width() as _,
//                 data,
//             ),
//         }
//     }
// }

impl Map for MapChunkGuard {
    fn grid_resolution(&self) -> MetresPerPixel {
        self.resolution
    }

    fn get_cell_int_pos(&self, position: &Point2<f32>) -> Point2<i32> {
        self.get_cell_int_pos(position)
    }

    fn get_cell_at(&self, position: &Point2<f32>) -> Option<&MapCellLock> {
        self.get_cell_at(position)
    }

    fn get_points(&self) -> Vec<Point2<f32>> {
        MapChunkGuard::get_points(self)
    }

    fn add_points(&mut self, points: &[Point2<f32>]) {
        MapChunkGuard::add_points(self, points)
    }

    fn clear_points(&mut self) {
        for cell_lock in self.chunk.data.iter() {
            let mut cell = cell_lock.write().unwrap();
            cell.points.clear();
        }
    }
}

==> ./model/big_map/map_chunk_locked.rs <==
use std::ops::Deref;

use nalgebra::{Point2, Vector2};
use roboq_types::model::{map::MetresPerPixel, Metres};

use super::map_cell::MapCell;

pub struct MapChunkReadLock<T: Deref<Target = MapCell>> {
    pub top_left: Point2<f32>,
    pub cell_size: Metres,
    pub resolution: MetresPerPixel,
    pub chunk: Vec<T>,
}

impl<T: Deref<Target = MapCell>> MapChunkReadLock<T> {
    pub fn get_cell_at(&self, pos: &Point2<f32>) -> Option<&T> {
        for cell in self.chunk.iter() {
            let top_left = cell.deref().top_left;

            let right_bottom =
                top_left + Vector2::new(*self.cell_size, *self.cell_size);

            let coords = pos.coords;
            if coords.x >= top_left.x
                && coords.y >= top_left.y
                && coords.x < right_bottom.x
                && coords.y < right_bottom.y
            {
                return Some(cell);
            }
        }

        None
    }
}

==> ./model/big_map/map_chunk_optional.rs <==
use crate::model::array2d::Array2D;
use nalgebra::Point2;
use roboq_types::model::Metres;
use std::sync::RwLockWriteGuard;

use super::map_cell::MapCell;

/// This is copy-paste of MapChunk with [`Option<Mapcell>`] instead of [`MapCell`], in order to
/// retrive chunks without generating new ones. TODO make it DRY.
pub struct MapChunkOptional<'cell> {
    pub top_left_corner: Point2<f32>,
    pub cell_size: Metres,
    pub chunk: Array2D<Option<RwLockWriteGuard<'cell, MapCell>>>,
}

impl<'cell> MapChunkOptional<'cell> {
    pub fn new(
        top_left_corner: Point2<f32>,
        cell_size: Metres,
        chunk: Array2D<Option<RwLockWriteGuard<'cell, MapCell>>>,
    ) -> Self {
        Self {
            chunk,
            cell_size,
            top_left_corner,
        }
    }

    pub fn get_points(&self) -> Vec<Point2<f32>> {
        let mut points = Vec::new();
        for cell in self.chunk.data.iter().flatten() {
            for point in &cell.points {
                points.push(*point);
            }
        }
        points
    }

    pub fn get_cell_points(&self) -> Vec<Vec<Point2<f32>>> {
        let mut points = Vec::new();
        for cell in self.chunk.data.iter() {
            if let Some(cell) = cell {
                points.push(cell.points.clone());
            } else {
                points.push(Vec::new());
            }
        }
        points
    }
}

==> ./model/big_map/mod.rs <==
use self::map_cell::MapCell;
use super::{array2d::Array2D, point_cloud_grid::PointCloudExt};
use map_chunk::MapChunkGuard;
use map_chunk_optional::MapChunkOptional;
use nalgebra::{Point2, Vector2};
use roboq_types::model::{
    map::{MapRegion, MetresPerPixel},
    Metres,
};
use rustc_hash::FxHashMap;
use serde::{Deserialize, Serialize};
use std::sync::{Arc, RwLock};

mod map;
mod map_chunk_locked;

pub mod map_cell;
pub mod map_chunk;
pub mod map_chunk_optional;
mod transform;

// mod map_cell_lock;
pub use map::Map;
// pub use map_cell_lock::MapCellLock;

// pub type MapCellLock<'a> = RwLockWriteGuard<'a, MapCell>;
pub type MapCellLock = Arc<RwLock<MapCell>>;
pub type MapCellBox = Box<MapCell>;

// pub type BoxedMapChunk = MapChunkGuard<MapCellBox>;
// pub type MapChunk<'a> = MapChunkGuard<MapCellLock<'a>>;
pub type MapChunk = MapChunkGuard;
pub type BoxedMapChunk = MapChunkGuard;
pub type MapCellId = usize;
pub use map_chunk_locked::MapChunkReadLock;
pub use transform::MapTransform;

/// This is infinte 2D map which consists of cells, each cell stores Points and OccupancyGrid.
/// In order to get a chunk of the world use method `get_chunk_at(&mut self, position: Point2<f32>, radius: Metres) -> MapChunk`
/// Chunk is a collection of cells. Radius determines amount of chunks around a point, to include
/// every point around `position` which is maximum `radius` metres from it. It actually captures
/// more points that radius most of the time for simpler implementation.
#[derive(Serialize, Deserialize, Debug)]
pub struct BigMap {
    // RwLock is used to allow getting multiple mutalbe references to a hashmap at the same time
    // It's better to use Cell in the future, or allow multiple chunks being requested at the same
    // time
    /// Hash map of cells
    pub map: FxHashMap<Point2<i32>, Arc<RwLock<MapCell>>>,
    /// Size of each cell
    cell_size: Metres,
    /// Resolution of underlying OccupancyGrid for each cell
    occupancy_grid_resolution: MetresPerPixel,
}

impl Clone for BigMap {
    fn clone(&self) -> Self {
        let mut new_map = FxHashMap::default();

        for (key, val) in self.map.iter() {
            new_map
                .insert(*key, RwLock::new(val.read().unwrap().clone()).into());
        }

        BigMap {
            map: new_map,
            cell_size: self.cell_size,
            occupancy_grid_resolution: self.occupancy_grid_resolution,
        }
    }
}

impl BigMap {
    /// Create new empty BigMap, each cell of the map has dimensions of cell_size X cell_size, and
    /// underlying OccupancyGrid has `occupancy_grid_resolution` resolution.
    pub fn new(
        cell_size: Metres,
        occupancy_grid_resolution: MetresPerPixel,
    ) -> BigMap {
        assert!(cell_size > Metres(0.0));

        BigMap {
            map: FxHashMap::default(),
            cell_size,
            occupancy_grid_resolution,
        }
    }

    pub fn reset(&mut self) {
        // for cell_lock in self.map.values_mut() {
        //     let map_cell = cell_lock.write().unwrap();
        //     map_cell.occupancy_grid.
        //
        // }
        self.map.clear()
    }

    /// update the map cell by its center
    /// if any thread already uses same MapCell it will be overrided  
    pub fn update(&mut self, coords: Point2<i32>, cell: MapCell) {
        let _ = self.map.insert(coords, Arc::new(RwLock::new(cell)));
    }

    pub fn grid_resolution(&self) -> MetresPerPixel {
        self.occupancy_grid_resolution
    }

    /// return this (i, j) of specific MapCell in Global BigMap
    pub fn get_cell_int_pos(&self, position: &Point2<f32>) -> Point2<i32> {
        Point2::new(
            (position.x / self.cell_size.0).floor() as i32,
            (position.y / self.cell_size.0).floor() as i32,
        )
    }

    pub fn get_cell_at(&self, position: &Point2<f32>) -> Option<&MapCellLock> {
        let cell_int_pos = self.get_cell_int_pos(position);
        self.map.get(&cell_int_pos)
    }

    /// Getting a chunk can create new cells, therefore it's neccessary to make this mutable
    pub fn get_chunk_at_no_gen(
        &self,
        position: Point2<f32>,
        radius: Metres,
    ) -> MapChunkOptional {
        let chunk_width_in_cells =
            ((radius * 2.0) / self.cell_size).ceil() as usize + 1;
        let top_left_rough = position - Vector2::new(radius.0, radius.0);

        let top_left_chunk_int_pos = Point2::new(
            (top_left_rough.x / self.cell_size.0).floor() as i32,
            (top_left_rough.y / self.cell_size.0).floor() as i32,
        );

        let top_left = Point2::new(
            top_left_chunk_int_pos.x as f32 * self.cell_size.0,
            top_left_chunk_int_pos.y as f32 * self.cell_size.0,
        );

        let mut row_major_chunks =
            Vec::with_capacity(chunk_width_in_cells * chunk_width_in_cells);

        for y_chunk in 0..chunk_width_in_cells {
            for x_chunk in 0..chunk_width_in_cells {
                let cell_position = top_left_chunk_int_pos
                    + Vector2::new(x_chunk as i32, y_chunk as i32);
                let chunk = self.map.get(&cell_position);
                if let Some(chunk) = chunk {
                    row_major_chunks.push(Some(chunk.write().unwrap()));
                } else {
                    row_major_chunks.push(None);
                }
            }
        }

        let chunk = Array2D::new_from_row_major(
            chunk_width_in_cells as u32,
            row_major_chunks,
        );
        MapChunkOptional::new(top_left, self.cell_size, chunk)
    }

    pub fn get_chunk_at(
        &mut self,
        position: Point2<f32>,
        radius: Metres,
    ) -> MapChunk {
        let chunk_width_in_cells =
            ((radius * 2.0) / self.cell_size).ceil() as usize + 1;
        let top_left_rough = position - Vector2::new(radius.0, radius.0);

        let top_left_chunk_int_pos = Point2::new(
            (top_left_rough.x / self.cell_size.0).floor() as i32,
            (top_left_rough.y / self.cell_size.0).floor() as i32,
        );

        let top_left = Point2::new(
            top_left_chunk_int_pos.x as f32 * self.cell_size.0,
            top_left_chunk_int_pos.y as f32 * self.cell_size.0,
        );

        for y_chunk in 0..chunk_width_in_cells {
            for x_chunk in 0..chunk_width_in_cells {
                let cell_position = top_left_chunk_int_pos
                    + Vector2::new(x_chunk as i32, y_chunk as i32);
                let chunk = self.map.get(&cell_position);

                let top_left_cell_world = Point2::new(
                    cell_position.x as f32 * self.cell_size.0,
                    cell_position.y as f32 * self.cell_size.0,
                );

                if chunk.is_none() {
                    self.map.insert(
                        cell_position,
                        Arc::new(RwLock::new(MapCell::new(
                            top_left_cell_world,
                            self.cell_size,
                            self.occupancy_grid_resolution,
                        ))),
                    );
                }
            }
        }

        let mut row_major_chunks =
            Vec::with_capacity(chunk_width_in_cells * chunk_width_in_cells);

        for y_chunk in 0..chunk_width_in_cells {
            for x_chunk in 0..chunk_width_in_cells {
                let cell_position = top_left_chunk_int_pos
                    + Vector2::new(x_chunk as i32, y_chunk as i32);
                let chunk = self.map.get(&cell_position).unwrap();
                row_major_chunks.push(Arc::clone(chunk));
            }
        }

        let chunk = Array2D::new_from_row_major(
            chunk_width_in_cells as u32,
            row_major_chunks,
        );

        MapChunk {
            top_left,
            cell_size: self.cell_size,
            resolution: self.occupancy_grid_resolution,
            chunk,
        }
    }

    pub fn iter_cell(
        &self,
    ) -> impl Iterator<Item = (Point2<i32>, MapCellLock)> {
        let cells = self
            .map
            .iter()
            .map(|(coords, lock)| (*coords, Arc::clone(lock)))
            .collect::<Vec<(Point2<i32>, MapCellLock)>>();

        cells.into_iter()
    }

    pub fn set_region(&mut self, region: MapRegion) {
        log::debug!("The region: {region:?} will be set");

        let center = Point2::new(
            region.top_left.x + *region.width() / 2.0,
            region.top_left.y + *region.height() / 2.0,
        );

        let max_radius = (region.width() / 2.0).max(region.height() / 2.0);

        let chunk = self.get_chunk_at(center, max_radius);

        let cell_size = *chunk.cell_size;

        rayon::spawn(move || {
            for cell_lock in chunk.iter_cell() {
                let map_cell = cell_lock.read().unwrap();

                if region.bottom_right.x < map_cell.top_left.x
                    || region.bottom_right.y < map_cell.top_left.y
                    || region.top_left.x > map_cell.top_left.x + cell_size
                    || region.top_left.y > map_cell.top_left.y + cell_size
                {
                    continue;
                }

                let top_left_x = (region.top_left.x).max(map_cell.top_left.x);
                let top_left_y = (region.top_left.y).max(map_cell.top_left.y);

                let bottom_right_x =
                    region.bottom_right.x.min(map_cell.top_left.x + cell_size);
                let bottom_right_y =
                    region.bottom_right.y.min(map_cell.top_left.y + cell_size);

                let bottom_left_x = top_left_x;
                let bottom_left_y = bottom_right_y;

                let top_left = map_cell
                    .world_to_grid(&Point2::new(top_left_x, top_left_y));

                let bottom_left = map_cell
                    .world_to_grid(&Point2::new(bottom_left_x, bottom_left_y));

                let bottom_right = map_cell.world_to_grid(&Point2::new(
                    bottom_right_x,
                    bottom_right_y,
                ));

                let in_bounds = |point: &Point2<f32>| -> bool {
                    point.x >= top_left_x
                        && point.x <= bottom_right_x
                        && point.y >= top_left_y
                        && point.y <= bottom_right_y
                };

                let mut grid = map_cell.occupancy_grid.clone();
                drop(map_cell);

                for start_point in bresenham::Bresenham::new(
                    (top_left.x as isize, top_left.y as isize),
                    (bottom_left.x as isize, bottom_left.y as isize),
                ) {
                    let end_point = (bottom_right.x as isize, start_point.1);

                    for (x, y) in
                        bresenham::Bresenham::new(start_point, end_point)
                    {
                        let mut cost = grid
                            .index_grid_mut(&Point2::new(x as i32, y as i32));
                        *cost = region.cost;
                    }
                }

                let mut map_cell = cell_lock.write().unwrap();
                map_cell.occupancy_grid = grid;

                if region.reset_base_points {
                    map_cell.points.retain(|p| !in_bounds(p));
                }
            }
        });
    }
}

impl Map for BigMap {
    fn grid_resolution(&self) -> MetresPerPixel {
        self.grid_resolution()
    }

    fn get_cell_int_pos(&self, position: &Point2<f32>) -> Point2<i32> {
        self.get_cell_int_pos(position)
    }

    fn get_cell_at(&self, position: &Point2<f32>) -> Option<&MapCellLock> {
        self.get_cell_at(position)
    }

    fn get_points(&self) -> Vec<Point2<f32>> {
        let mut points = Vec::new();

        for cell_lock in self.map.values() {
            let cell = cell_lock.read().unwrap();

            for point in &cell.points {
                points.push(*point);
            }
        }

        points
    }

    fn add_points(&mut self, points: &[Point2<f32>]) {
        if points.is_empty() {
            return;
        }

        let point_cloud = PointCloudExt::from_points(points);
        let chunk = self
            .get_chunk_at(point_cloud.center, Metres(1.5 * point_cloud.radius));
        chunk.add_points(points);
    }

    fn clear_points(&mut self) {
        for cell in self.map.values() {
            cell.write().unwrap().points.clear();
        }
    }
}

==> ./model/big_map/transform.rs <==
use nalgebra::Point2;
use roboq_types::model::map::MetresPerPixel;

#[derive(Clone)]
pub struct MapTransform {
    pub id: usize,
    pub resolution: MetresPerPixel,
    pub top_left: Point2<f32>,
    pub bottom_right: Point2<f32>,
    pub width: usize,
}

impl MapTransform {
    ///return true if given point in bound of MapCell
    pub fn in_bounds(&self, coords: &Point2<f32>) -> bool {
        coords.x >= self.top_left.x
            && coords.y >= self.top_left.y
            && coords.x < self.bottom_right.x
            && coords.y < self.bottom_right.y
    }
    //identifier for map cell
    pub fn cell_id(&self) -> usize {
        self.id
    }

    pub fn world_to_grid(&self, point: &Point2<f32>) -> Point2<i32> {
        let local_coords: Point2<f32> = (point - self.top_left).into();
        self.resolution.point_to_pixels(&local_coords)
    }

    pub fn index(&self, coords: &Point2<i32>) -> usize {
        (coords.x + coords.y * self.width as i32) as usize
    }
}

==> ./model/kd_tree.rs <==
use kdtree::kdtree::{Kdtree, KdtreePointTrait};

use nalgebra::Point2;
#[derive(Clone, Copy, PartialEq)]
pub struct Point2Kd(pub Point2<f32>, [f64; 2]);

#[derive(Clone, Copy)]
pub struct TPoint2Kd<T: Copy>(Point2Kd, T);

impl KdtreePointTrait for Point2Kd {
    fn dims(&self) -> &[f64] {
        &self.1
    }
}

impl<T: Copy> PartialEq for TPoint2Kd<T> {
    fn eq(&self, other: &TPoint2Kd<T>) -> bool {
        self.0.eq(&other.0)
    }
}

impl<T: Copy> KdtreePointTrait for TPoint2Kd<T> {
    fn dims(&self) -> &[f64] {
        self.0.dims()
    }
}

pub trait TPoint2KdTrait {
    type Item;
    fn coords(&self) -> Point2<f32>;
    fn value(&self) -> Self::Item;
}

impl<T: Copy> TPoint2KdTrait for TPoint2Kd<T> {
    type Item = T;

    fn coords(&self) -> Point2<f32> {
        self.0.into()
    }

    fn value(&self) -> T {
        self.1
    }
}

impl<T: Copy, D: TPoint2KdTrait<Item = T>> From<&D> for TPoint2Kd<T> {
    fn from(value: &D) -> Self {
        Self(value.coords().into(), value.value())
    }
}

impl<T: Copy + Default> From<Point2<f32>> for TPoint2Kd<T> {
    fn from(value: Point2<f32>) -> Self {
        Self(value.into(), T::default())
    }
}

impl<T: Copy + Default> From<&Point2<f32>> for TPoint2Kd<T> {
    fn from(value: &Point2<f32>) -> Self {
        Self((*value).into(), T::default())
    }
}

impl From<Point2<f32>> for Point2Kd {
    fn from(value: Point2<f32>) -> Self {
        Point2Kd(value, [value.x as f64, value.y as f64])
    }
}

impl From<Point2Kd> for Point2<f32> {
    fn from(val: Point2Kd) -> Self {
        val.0
    }
}

pub type KdTree = Kdtree<Point2Kd>;
pub type TKdTree<T> = Kdtree<TPoint2Kd<T>>;

/// This class is a little mess for now, because this is the fastest KdTree implementation that I
/// found, but it does not support creating empty trees, iterating through points of a tree, or
/// removing points from a tree.
pub struct MyKdTree {
    pub kd_tree: Option<KdTree>,
    pub points: Vec<Point2<f32>>,
}

impl MyKdTree {
    pub fn new() -> Self {
        MyKdTree {
            kd_tree: None,
            points: Vec::new(),
        }
    }

    pub fn is_empty(&self) -> bool {
        self.kd_tree.is_none()
    }

    pub fn add_points_within_range(
        &mut self,
        points: &Vec<Point2<f32>>,
        range_limit: f32,
    ) {
        let range_limit_sq = range_limit * range_limit;
        if self.kd_tree.is_none() {
            self.kd_tree = KdTree::new(&mut [points[0].into()]).into();
        }

        assert!(self.kd_tree.is_some());

        let kdtree = unsafe { self.kd_tree.as_mut().unwrap_unchecked() };

        for point in points {
            {
                let point = *point;
                let kd_point: Point2Kd = point.into();

                let nearest_point: Point2<f32> =
                    kdtree.nearest_search(&kd_point).into();
                if (point - nearest_point).magnitude_squared() > range_limit_sq
                {
                    kdtree.insert_node(kd_point);
                    self.points.push(point);
                }
            };
        }
    }

    pub fn retain_points<F: FnMut(&Point2<f32>) -> bool>(
        &mut self,
        retain_condition: F,
    ) {
        self.points.retain(retain_condition);

        if self.points.is_empty() {
            self.kd_tree = None;
        } else {
            self.set_vector_points_into_tree();
        }
    }

    pub fn rebuild_tree(&mut self) {
        if let Some(ref mut tree) = self.kd_tree {
            tree.gather_points_and_rebuild();
        }
    }

    fn set_vector_points_into_tree(&mut self) {
        let mut points: Vec<Point2Kd> =
            self.points.iter().map(|p| Point2Kd::from(*p)).collect();
        match &mut self.kd_tree {
            None => self.kd_tree = Some(KdTree::new(&mut points)),
            Some(tree) => {
                tree.rebuild_tree(&mut points);
            }
        }
    }

    pub fn get_kdtree(&self) -> &KdTree {
        self.kd_tree.as_ref().unwrap()
    }

    pub fn get_points(&self) -> &Vec<Point2<f32>> {
        &self.points
    }
}

impl Default for MyKdTree {
    fn default() -> Self {
        Self::new()
    }
}

pub fn points_to_kdtree(points: &[Point2<f32>]) -> KdTree {
    let mut points: Vec<_> =
        points.iter().map(|x| Point2Kd::from(*x)).collect();
    KdTree::new(&mut points)
}

pub fn points_to_data_kdtree<T: Copy, D: TPoint2KdTrait<Item = T>>(
    points: &[D],
) -> TKdTree<T> {
    let mut points: Vec<_> =
        points.iter().map(|x| TPoint2Kd::from(x)).collect();

    TKdTree::new(&mut points)
}

==> ./model/mod.rs <==
pub mod array2d;
pub mod big_map;
pub mod kd_tree;
pub mod motor_action;
pub mod occupancy_grid;
pub mod point_cloud_grid;

pub use roboq_types::model::*;

pub use crate::correlative_scan_matching::scan_ring_buffer;

///the angle return as [-PI; PI]
pub fn normalize_angle(angle: f32) -> f32 {
    use std::f32::consts::PI;

    let norm_angle = angle.rem_euclid(PI * 2.0);
    if norm_angle > PI {
        norm_angle - 2.0 * PI
    } else {
        norm_angle
    }
}

pub fn normalize_angle_f64(angle: f64) -> f64 {
    use std::f64::consts::PI;

    let norm_angle = angle.rem_euclid(PI * 2.0);
    if norm_angle > PI {
        norm_angle - 2.0 * PI
    } else {
        norm_angle
    }
}

==> ./model/motor_action.rs <==
use roboq_types::model::MetresPerSecond;

#[derive(Debug, Clone, Copy, serde::Serialize, serde::Deserialize)]
pub struct MotorAction {
    pub left_speed: MetresPerSecond,
    pub right_speed: MetresPerSecond,
}

impl MotorAction {
    pub fn stop() -> Self {
        Self {
            left_speed: 0.0.into(),
            right_speed: 0.0.into(),
        }
    }

    pub fn as_plain(&self) -> (f32, f32) {
        (*self.left_speed, *self.right_speed)
    }
}

==> ./model/occupancy_grid.rs <==
use std::collections::TryReserveError;
use std::ops::Deref;
use std::ops::DerefMut;

use log::error;
use nalgebra::Point2;
use nalgebra::Vector2;
use roboq_types::model::map::MetresPerPixel;
use roboq_types::model::Metres;
use serde::Deserialize;
use serde::Serialize;
use thiserror::Error;

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct OccupancyGrid {
    pub resolution: MetresPerPixel,

    width: u32,
    height: u32,

    data: Vec<u8>,
    hit_and_pass_count: Vec<(f32, f32)>,
}

pub const PERSISTENT_OBSTACLE_STATUS: u8 = 0;
pub const OCCUPIED_STATUS: u8 = 1;
pub const UNKNOWN_STATUS: u8 = 128;
pub const FREE_STATUS: u8 = 255;
pub const OCCUPIED_THRESHOLD: u8 = UNKNOWN_STATUS;

macro_rules! impl_grid_cost {
    ($ty: ty) => {
        impl<'a> $ty {
            pub const OCCUPIED: u8 = 0;
            pub const FREE: u8 = 255;

            pub fn is_free(&self) -> bool {
                *self.0 > OCCUPIED_THRESHOLD
            }
            pub fn is_occupied(&self) -> bool {
                *self.0 <= OCCUPIED_THRESHOLD
            }
            pub fn status(&self) -> u8 {
                *self.0
            }
        }

        impl<'a> Deref for $ty {
            type Target = u8;

            fn deref(&self) -> &Self::Target {
                self.0
            }
        }
    };
}
#[derive(Debug, Clone, Copy)]
#[repr(transparent)]
pub struct GridCost<'a>(&'a u8);

impl_grid_cost!(GridCost<'a>);

#[derive(Debug)]
#[repr(transparent)]
pub struct GridCostMut<'a>(&'a mut u8);
impl_grid_cost!(GridCostMut<'a>);

impl<'a> DerefMut for GridCostMut<'a> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        self.0
    }
}

#[derive(Debug, Error)]
pub enum MappingError {
    #[error("The requested world point is not mappable for grid map")]
    NotPresent(Point2<f32>),
    #[error("Unknown runtime error")]
    Unknown,
}
impl From<TryReserveError> for MappingError {
    fn from(_value: TryReserveError) -> Self {
        Self::Unknown
    }
}
impl OccupancyGrid {
    pub fn new_empty(
        width: u32,
        height: u32,
        resolution: MetresPerPixel,
    ) -> OccupancyGrid {
        let data_size = (width * height) as usize;
        OccupancyGrid {
            resolution,
            width,
            height,
            data: vec![UNKNOWN_STATUS; data_size],
            hit_and_pass_count: vec![(0.0, 0.0); data_size],
        }
    }
    pub fn new_with_data(
        width: u32,
        height: u32,
        resolution: MetresPerPixel,
        data: Vec<u8>,
    ) -> Self {
        let data_size = (width * height) as usize;
        assert!(data_size == data.len());

        Self {
            width,
            height,
            resolution,
            data,
            hit_and_pass_count: vec![(0.0, 0.0); data_size],
        }
    }

    pub fn index(&self, x: i32, y: i32) -> usize {
        (x + y * self.width as i32) as usize
    }

    pub fn size(&self) -> Vector2<i32> {
        Vector2::new(self.width as i32, self.height as i32)
    }

    pub fn size_metres(&self) -> Vector2<f32> {
        Vector2::new(
            self.resolution.to_metres(self.width as f32),
            self.resolution.to_metres(self.height as f32),
        )
    }

    pub fn iter_data(&self) -> std::slice::Iter<'_, u8> {
        self.data.iter()
    }

    //#[allow(deprecated)]
    pub fn world_to_grid_safe(
        &self,
        point: &Point2<f32>,
    ) -> Result<Point2<i32>, MappingError> {
        Ok(self.world_to_grid(point))
    }

    pub fn width(&self) -> usize {
        self.width as usize
    }

    pub fn height(&self) -> usize {
        self.height as usize
    }

    pub fn world_to_grid(&self, point: &Point2<f32>) -> Point2<i32> {
        self.resolution.point_to_pixels(point)
    }

    pub fn grid_to_world(&self, point: &Point2<i32>) -> Point2<f32> {
        self.resolution.point_to_metres(point)
    }

    pub fn clamp_to_grid(&self, point: &Point2<i32>) -> Point2<i32> {
        Point2::new(
            point.x.clamp(0, self.width as i32 - 1), // -1
            point.y.clamp(0, self.height as i32 - 1), // -1
        )
    }

    pub fn inc_pass_count(&mut self, point: &Point2<i32>) {
        let index = self.index(point.x, point.y);
        self.hit_and_pass_count[index].1 += 1.0;
        self.update_occupancy_grid(index);
    }

    pub fn dec_pass_count(&mut self, point: &Point2<i32>) {
        let index = self.index(point.x, point.y);
        self.hit_and_pass_count[index].1 -= 1.0;
        self.update_occupancy_grid(index);
    }

    pub fn inc_hit_count(&mut self, point: &Point2<i32>) {
        let index = self.index(point.x, point.y);
        self.hit_and_pass_count[index].0 += 1.0;
        self.update_occupancy_grid(index);
    }

    pub fn sensor_ray_world(&mut self, start: &Point2<f32>, end: &Point2<f32>) {
        let start = self.clamp_to_grid(&self.world_to_grid(start));
        let end = self.clamp_to_grid(&self.world_to_grid(end));

        for (x, y) in bresenham::Bresenham::new(
            (start.x as isize, start.y as isize),
            (end.x as isize, end.y as isize),
        ) {
            let index = self.index(x as i32, y as i32);
            self.hit_and_pass_count[index].1 += 1.0;
            self.update_occupancy_grid(index);
        }
        let end_index = self.index(end.x, end.y);

        let last_pixel = &mut self.hit_and_pass_count[end_index];
        last_pixel.0 += 1.0; // Inc hit
        last_pixel.1 -= 1.0; // Dec pass
        self.update_occupancy_grid(end_index);
    }

    fn update_occupancy_grid(&mut self, index: usize) {
        if self.data[index] == PERSISTENT_OBSTACLE_STATUS {
            return;
        }

        let pixel = self.hit_and_pass_count[index];
        let pass_count = pixel.1;
        let hit_count = pixel.0;
        let cell_density = 1.0 - pass_count / (hit_count + pass_count);

        // TODO put this into a config
        if cell_density > 0.02 {
            self.data[index] = OCCUPIED_STATUS;
        } else if pass_count < 10.0 {
            self.data[index] = UNKNOWN_STATUS;
        } else {
            self.data[index] = FREE_STATUS;
        }
    }

    pub fn scan_line<F: FnMut(&u8) -> bool>(
        &mut self,
        start: &Point2<i32>,
        end: &Point2<i32>,
        mut stop_condition: F,
    ) -> Option<Point2<i32>> {
        let start = self.clamp_to_grid(start);
        let end = self.clamp_to_grid(end);

        for (x, y) in bresenham::Bresenham::new(
            (start.x as isize, start.y as isize),
            (end.x as isize, end.y as isize),
        ) {
            let index = self.index(x as i32, y as i32);
            if stop_condition(&mut self.data[index]) {
                return Some(Point2::new(x as i32, y as i32));
            }
        }
        None
    }

    pub fn index_world_mut(&mut self, point: &Point2<f32>) -> GridCostMut<'_> {
        let point = &self.world_to_grid(point);
        self.index_grid_mut(point)
    }

    pub fn index_grid_mut(&mut self, point: &Point2<i32>) -> GridCostMut<'_> {
        let point = self.clamp_to_grid(point);
        let index = self.index(point.x, point.y);
        GridCostMut(&mut self.data[index])
    }

    pub fn index_grid(&self, point: &Point2<i32>) -> GridCost<'_> {
        let point = self.clamp_to_grid(point);
        GridCost(&self.data[self.index(point.x, point.y)])
    }

    pub fn index_world(&self, point: &Point2<f32>) -> GridCost<'_> {
        let grid_point = self.world_to_grid(point);
        let point = self.clamp_to_grid(&grid_point);
        if point != grid_point {
            error!("Point != i_point, {point} != {grid_point}");
        }
        GridCost(&self.data[self.index(point.x, point.y)])
    }

    pub fn as_bytes(&self) -> (u32, u32, Vec<u8>) {
        (self.width, self.height, self.data.clone())
    }

    /// Linearly distributes occupied points on the grid
    pub fn grow_occupied_cells_mut(&mut self, grow_radius: Metres) {
        let grid = grow_occupied_cells(self, grow_radius);
        *self = grid;
    }

    /// Linearly distributes occupied points on the grid
    #[must_use]
    pub fn grow_occupied_cells(&self, grow_radius: Metres) -> OccupancyGrid {
        grow_occupied_cells(self, grow_radius)
    }
}

fn grow_occupied_cells(
    grid: &OccupancyGrid,
    grow_radius: Metres,
) -> OccupancyGrid {
    let mut expanded_grid = grid.clone();
    let grow_radius = grid.resolution.to_pixels(grow_radius);

    for x in 0..grid.width as i32 {
        for y in 0..grid.height as i32 {
            // if grid.index_grid(&Point2::new(x, y)) < &OCCUPIED_THRESHOLD {
            if grid.index_grid(&Point2::new(x, y)).status() <= OCCUPIED_THRESHOLD {
                let x_min = x - grow_radius;
                let x_max = x + grow_radius;
                let y_min = y - grow_radius;
                let y_max = y + grow_radius;
                for ix in x_min..x_max {
                    for iy in y_min..y_max {
                        if (x - ix) + (y - iy) < grow_radius.pow(2) {
                            *expanded_grid
                                .index_grid_mut(&Point2::new(ix, iy)) =
                                OCCUPIED_STATUS;
                        }
                    }
                }
            }
        }
    }

    expanded_grid
}

/*
pub fn grow_walls(&mut self, robot_radius_metres: f32) -> Map {
    let mut new_map = self.clone();
    let robot_radius_pixels: u32 = (robot_radius_metres / self.metres_per_pixel) as u32;

    for x in 0..self.size_pixels.x {
        for y in 0..self.size_pixels.y {
            if self[(x as usize, y as usize)] < HIT_WALL_THRESHOLD {
                let x_min = x.saturating_sub(robot_radius_pixels);
                let x_max = (x + robot_radius_pixels).min(self.size_pixels.x);
                let y_min = y.saturating_sub(robot_radius_pixels);
                let y_max = (y + robot_radius_pixels).min(self.size_pixels.y);
                for ix in x_min..x_max {
                    for iy in y_min..y_max {
                        let x_diff_sq = ((x as i32 - ix as i32).abs() as u32).pow(2);
                        let y_diff_sq = ((y as i32 - iy as i32).abs() as u32).pow(2);
                        if x_diff_sq + y_diff_sq < robot_radius_pixels.pow(2) {
                            new_map[(ix as usize, iy as usize)] = 0;
                        }
                    }
                }
            }
        }
    }
    new_map
}*/

==> ./model/point_cloud_grid.rs <==
use nalgebra::{Point2, Vector2};

pub struct PointCloudExt<'a> {
    pub points: &'a [Point2<f32>],
    pub center: Point2<f32>,
    pub radius: f32,
}

impl<'a> PointCloudExt<'a> {
    pub fn from_points(points: &'a [Point2<f32>]) -> Self {
        assert!(!points.is_empty());

        let mut sum = Point2::<f32>::new(0.0, 0.0);
        for p in points.iter() {
            sum += Vector2::new(p.x, p.y);
        }

        let center = sum / points.len() as f32;

        Self::from_points_with_center(points, center)
    }

    pub fn from_points_with_center(
        points: &'a [Point2<f32>],
        center: Point2<f32>,
    ) -> Self {
        assert!(!points.is_empty());

        let mut max_dist2 = f32::NEG_INFINITY;

        for p in points.iter() {
            let dist2 = (p - center).norm_squared();
            max_dist2 = f32::max(dist2, max_dist2);
        }

        let radius = {
            let value = max_dist2.sqrt();
            if value.is_normal() {
                value
            } else {
                log::error!("Invalid radius for point cloud: {value}");
                32.0
            }
        };

        Self {
            points,
            center,
            radius,
        }
    }
}

==> ./output_data.rs <==
use roboq_types::model::{debug::DebugData, waypoint::WaypointStatus};

use crate::{
    config::{ConfigProperty, NavigationConfig},
    devices::DeviceFeedback,
    model::motor_action::MotorAction,
};

#[derive(Debug, Clone)]
pub enum OutputData {
    //debug data
    DebugData(DebugData),
    Config(Vec<ConfigProperty>),
    MotorAction(MotorAction),
    WaypointStatus(WaypointStatus),
    // message sending when given InputData has invalid constraints
    Error(String),
    DeviceFeedback(DeviceFeedback),
}

impl From<DeviceFeedback> for OutputData {
    fn from(value: DeviceFeedback) -> Self {
        Self::DeviceFeedback(value)
    }
}

impl From<WaypointStatus> for OutputData {
    fn from(value: WaypointStatus) -> Self {
        Self::WaypointStatus(value)
    }
}

impl From<MotorAction> for OutputData {
    fn from(value: MotorAction) -> Self {
        Self::MotorAction(value)
    }
}

impl<'a> From<&'a str> for OutputData {
    fn from(value: &'a str) -> Self {
        Self::Error(value.to_string())
    }
}

impl From<String> for OutputData {
    fn from(value: String) -> Self {
        Self::Error(value)
    }
}

impl From<DebugData> for OutputData {
    fn from(value: DebugData) -> Self {
        Self::DebugData(value)
    }
}

impl From<Vec<ConfigProperty>> for OutputData {
    fn from(value: Vec<ConfigProperty>) -> Self {
        Self::Config(value)
    }
}

impl<'a> From<&'a NavigationConfig> for OutputData {
    fn from(value: &'a NavigationConfig) -> Self {
        let props = value.to_properties();

        Self::Config(props)
    }
}

==> ./pipeline/device_task.rs <==
use std::sync::Arc;

use roboq_types::model::{debug::DebugData, localization::SensorEvent};

use crate::{
    devices::{self, DeviceMessage},
    shared_data::SharedData,
};

use super::Receiver;

pub fn spawn(
    shared_data: Arc<SharedData>,
    mut device_data_rx: Receiver<DeviceMessage>,
    debug_data_tx: super::Sender<DebugData>,
) {
    let (event_tx, mut event_rx) =
        crate::pipeline::channel::<(DeviceMessage, SensorEvent)>(10);

    tokio::task::spawn(async move {
        loop {
            tokio::select! {
                Some(msg) = device_data_rx.recv() => {
                    devices::handle_data(
                        Arc::clone(&shared_data),
                        debug_data_tx.clone(),
                        event_tx.clone(),
                        msg,
                    );
                }

                Some((message, event)) = event_rx.recv() => {
                    let shared_data = Arc::clone(&shared_data);
                    let debug_data_tx = debug_data_tx.clone();

                    rayon::spawn(move || {
                        //any event by default is unreliable
                        //if this one will be detected ukf will reject state update
                        let maybe_ok = shared_data
                            .motion_estimation
                            .write()
                            .unwrap()
                            .update_with_data_event(event);

                        if let Err(cause) = maybe_ok {
                            log::debug!(
                                "Localization error is detected for {:?}: {cause}",
                                event
                            );

                            if cause.is_poison_detected() {
                                devices::handle_unreliable_data(
                                    message,
                                    shared_data,
                                    debug_data_tx,
                                );

                            }
                        }
                    });
                }

                else => {
                    log::info!("Device task is exiting");
                    break;
                }
            }
        }
    });
}

==> ./pipeline/error.rs <==

==> ./pipeline/mod.rs <==
mod device_task;
mod error;
mod planner_task;
mod runner;

use std::sync::Arc;

use runner::NavigationRunner;
pub use tokio::sync::mpsc::error::TryRecvError;
pub use tokio::sync::mpsc::{channel, Receiver, Sender};
use tokio::sync::{Mutex, RwLock};

use crate::config::NavigationConfig;
use crate::shared_data::SharedData;
use crate::{pipeline, DeviceMessage, InputData, OutputData, PlannerAction};

#[derive(serde::Serialize, serde::Deserialize)]
pub struct RunningConfig {
    pub file_name: String,
    #[serde(skip)]
    pub lock: Option<Arc<RwLock<NavigationConfig>>>,
}

impl RunningConfig {
    pub fn new(file_name: &str, config: NavigationConfig) -> Self {
        Self {
            file_name: file_name.to_string(),
            lock: Some(Arc::new(RwLock::new(config))),
        }
    }

    pub fn set(&mut self, config: NavigationConfig) {
        self.lock = Some(Arc::new(RwLock::new(config)));
    }
}

#[derive(Clone)]
pub struct NavigationModule {
    pub input_data: Sender<InputData>,
    output_data: Arc<Mutex<Receiver<OutputData>>>,

    pub shared_data: Arc<SharedData>,
}

impl NavigationModule {
    pub fn launch(shared_data: SharedData) -> Self {
        const FUNNY_CAP: usize = 16; // Arbitrary chosen cap

        let (input_data_tx, input_data_rx) = pipeline::channel(FUNNY_CAP);
        let (output_data_tx, output_data_rx) = pipeline::channel(FUNNY_CAP);
        let (debug_data_tx, debug_data_rx) = pipeline::channel(FUNNY_CAP);

        let (device_data_tx, device_data_rx) =
            pipeline::channel::<DeviceMessage>(FUNNY_CAP);

        let (planner_data_tx, planner_data_rx) =
            pipeline::channel::<PlannerAction>(FUNNY_CAP);

        let shared_data = Arc::new(shared_data);
        shared_data.init_debug(debug_data_tx.clone());

        planner_task::spawn(
            Arc::clone(&shared_data),
            planner_data_rx,
            output_data_tx.clone(),
            debug_data_tx.clone(),
        );

        device_task::spawn(
            Arc::clone(&shared_data),
            device_data_rx,
            debug_data_tx.clone(),
        );

        runner::spawn(NavigationRunner {
            input_rx: input_data_rx,
            debug_rx: debug_data_rx,
            output_tx: output_data_tx,
            planner_tx: planner_data_tx,
            device_tx: device_data_tx,
            shared_data: Arc::clone(&shared_data),
        });

        Self {
            input_data: input_data_tx,
            output_data: Arc::new(Mutex::new(output_data_rx)),
            shared_data,
        }
    }

    pub async fn recv(&self) -> Option<OutputData> {
        let mut lock = self.output_data.lock().await;
        lock.recv().await
    }
}

==> ./pipeline/planner_task.rs <==
use std::{
    sync::Arc,
    time::{Duration, Instant},
};

use nalgebra::Point2;
use roboq_types::model::{
    debug::DebugData, waypoint::WaypointId, waypoint::WaypointStatus,
};
use thiserror::Error;

use crate::{
    model::{motor_action::MotorAction, normalize_angle},
    planner::{
        self, FollowingState, PlanEstimation, PlannerSimulationConfig,
        RobotPath,
    },
    shared_data::SharedData,
    OutputData, PlannerAction,
};

#[cfg(feature = "gps")]
use crate::planner::WorldPath;

pub fn spawn(
    shared_data: Arc<SharedData>,
    mut planner_data_rx: super::Receiver<PlannerAction>,
    output_data_tx: super::Sender<OutputData>,
    debug_data_tx: super::Sender<DebugData>,
) {
    let shared_data_ref = shared_data.clone();
    let output_data_tx_ref = output_data_tx.clone();

    let task_handle = tokio::task::spawn(async move {
        loop {
            tokio::select! {
                Some(action) = planner_data_rx.recv() => {
                   spawn_action_handler(
                       Arc::clone(&shared_data_ref),
                       output_data_tx_ref.clone(),
                       action,
                   );
                }

                else => {
                    log::info!("Planner task is dying");
                    break;
                }
            }
        }
    });

    std::thread::spawn(move || loop {
        if task_handle.is_finished() {
            log::info!("Planner worker thread is exiting...");
            break;
        }

        log::debug!("Trying to start...");

        let config =
            shared_data.config().blocking_read().planner_config.clone();

        let idle_timeout = Duration::from_millis(config.idle_timeout_ms);

        if shared_data.is_sync_state() || shared_data.has_stereo_collision() {
            log::info!("Sync state is detected. Action is stop");
            let _ = output_data_tx.blocking_send(MotorAction::stop().into());
            std::thread::sleep(idle_timeout);
            continue;
        }

        let Some(mut estimation) =
            PlanEstimation::new_dwa(&config, &*shared_data)
        else {
            let _ = output_data_tx.blocking_send(MotorAction::stop().into());
            std::thread::sleep(idle_timeout);
            continue;
        };

        let time_start = Instant::now();

        let event = estimation.set_debug(debug_data_tx.clone()).estimate();

        let action =
            planner::convert_to_motor_action(event.velocity, &config.robot);

        let _ = output_data_tx.blocking_send(action.into());

        let control = event.velocity.into();

        shared_data
            .motion_estimation
            .write()
            .unwrap()
            .set_control_input(control);

        if let Some(status) = event.status {
            let _ = output_data_tx.blocking_send(status.into());
        }

        if time_start.elapsed() < idle_timeout {
            std::thread::sleep(
                idle_timeout.saturating_sub(time_start.elapsed()),
            );
        }
    });
}

fn spawn_action_handler(
    shared_data: Arc<SharedData>,
    output_data: super::Sender<OutputData>,
    action: PlannerAction,
) {
    tokio::task::spawn_blocking(move || {
        let planner_config =
            shared_data.config().blocking_read().planner_config.clone();

        match handle_action(&shared_data, &planner_config, action) {
            Ok(Some(point_id)) => {
                let _ = output_data.blocking_send(
                    WaypointStatus::Target {
                        id: point_id,
                        distance: 42.0,
                    }
                    .into(),
                );
            }

            Err(cause) => {
                let _ = output_data
                    .blocking_send(WaypointStatus::from(cause).into());
            }

            Ok(None) => {
                //ignore silent action
            }
        }
    });
}

#[derive(Debug, Error)]
pub enum PlannerActionError {
    #[error("Robot state is poisoned")]
    PoisonedState,

    #[error("Requested waypoint is unreacheable")]
    Unreacheable,

    #[error("Request waypoint is not present")]
    NotPresent,
}

impl From<PlannerActionError> for WaypointStatus {
    fn from(value: PlannerActionError) -> Self {
        match value {
            PlannerActionError::PoisonedState => WaypointStatus::Unreacheable,
            PlannerActionError::Unreacheable => WaypointStatus::Unreacheable,
            PlannerActionError::NotPresent => WaypointStatus::NotPresent,
        }
    }
}

fn handle_action(
    shared_data: &SharedData,
    config: &PlannerSimulationConfig,
    action: PlannerAction,
) -> Result<Option<WaypointId>, PlannerActionError> {
    match action {
        PlannerAction::SetControlInput(action) => {
            let mut fd_lock = shared_data.plan.write().unwrap();

            fd_lock.state = action.into();

            Ok(None)
        }

        PlannerAction::SetRotation(heading_rad) => {
            let angle = normalize_angle(heading_rad);

            shared_data.plan.write().unwrap().state = angle.into();

            Ok(None)
        }

        PlannerAction::SetTargetPoint(id) => {
            let point_id = set_target_point(id, shared_data)?;

            Ok(point_id.into())
        }

        PlannerAction::MoveToTargetPoint(point, heading) => {
            let point_id = handle_action(
                shared_data,
                config,
                PlannerAction::AddTargetPoint(point, heading),
            )?
            .expect("AddTargetPoint produce point id");

            let _ = handle_action(
                shared_data,
                config,
                PlannerAction::SetTargetPoint(point_id),
            )?;

            Ok(point_id.into())
        }

        PlannerAction::AddTargetPoint((x, y), heading_rad) => {
            let new_path_point = Point2::new(x, y);

            let Some(estimation) =
                PlanEstimation::new_dry_run(config, shared_data)
            else {
                return Err(PlannerActionError::PoisonedState);
            };

            let is_valid_point = estimation.check_reachability(new_path_point);

            if !is_valid_point {
                return Err(PlannerActionError::Unreacheable);
            }

            log::trace!("New path point will be added");

            let point_id = {
                let mut fd_lock = shared_data.plan.write().unwrap();

                fd_lock.waypoints.insert(Point2::new(x, y), heading_rad).id
            };

            Ok(point_id.into())
        }

        PlannerAction::ResetWaypoints => {
            let mut fd_lock = shared_data.plan.write().unwrap();

            fd_lock.waypoints.reset();
            fd_lock.state.reset();

            Ok(None)
        }

        #[cfg(feature = "gps")]
        PlannerAction::MoveToWorldPoint { coords } => {
            let Some(world_coords) = shared_data
                .world_transform
                .read()
                .unwrap()
                .and_then(|t| t.current_coords())
            else {
                log::debug!("Current world transform is not set");
                return Err(PlannerActionError::Unreacheable);
            };

            let mut plan_lock = shared_data.plan.write().unwrap();

            plan_lock.state =
                WorldPath::with_target(coords, world_coords).into();

            Ok(None)
        }

        PlannerAction::SetPath(path) => {
            let Some(estimation) =
                PlanEstimation::new_dry_run(config, shared_data)
            else {
                return Err(PlannerActionError::PoisonedState);
            };

            for waypoint in path.iter() {
                let is_valid_goal =
                    estimation.check_reachability(waypoint.coords);

                if !is_valid_goal {
                    return Err(PlannerActionError::Unreacheable);
                }

                shared_data
                    .plan
                    .write()
                    .unwrap()
                    .waypoints
                    .insert(waypoint.coords, waypoint.heading);
            }

            shared_data.plan.write().unwrap().state =
                RobotPath::new_route(path).into();

            Ok(None)
        }
    }
}

fn set_target_point(
    id: WaypointId,
    shared_data: &SharedData,
) -> Result<WaypointId, PlannerActionError> {
    let mut plan_lock =
        shared_data.plan.write().expect("Failed to access rw data");

    if matches!(
        &plan_lock.state,
        FollowingState::Path(path) if path.global_target_id == id)
    {
        log::info!("Robot is already moving towards this goal");
        return Ok(id);
    };

    let Some(point) = plan_lock.waypoints.find_by_id(id) else {
        log::warn!("Access to invalid waypoint");
        return Err(PlannerActionError::NotPresent);
    };

    plan_lock.state = RobotPath::empty(point).into();

    Ok(id)
}

==> ./pipeline/runner.rs <==
use std::sync::Arc;

use pipeline::{Receiver, Sender};
use roboq_types::model::debug::DebugData;
use thiserror::Error;

use crate::{
    devices::DeviceMessage, pipeline, InputData, OutputData, PlannerAction,
    SharedData, StateAction,
};

pub struct NavigationRunner {
    pub input_rx: Receiver<InputData>,
    pub debug_rx: Receiver<DebugData>,

    pub output_tx: Sender<OutputData>,

    pub planner_tx: Sender<PlannerAction>,
    pub device_tx: Sender<DeviceMessage>,

    pub shared_data: Arc<SharedData>,
}

#[derive(Debug, Error)]
pub enum RunnerError {
    #[error("Unknown runtime error: {0}")]
    Unknown(String),
}

impl<T> From<tokio::sync::mpsc::error::SendError<T>> for RunnerError {
    fn from(_value: tokio::sync::mpsc::error::SendError<T>) -> Self {
        let msg = "tokio SendError".to_string();
        Self::Unknown(msg)
    }
}

impl<'a> From<&'a str> for RunnerError {
    fn from(value: &'a str) -> Self {
        Self::Unknown(value.to_string())
    }
}

pub fn spawn(runner: NavigationRunner) {
    tokio::task::spawn(async move {
        match runner.run().await {
            Ok(_) => {
                log::info!("Nav runner is exiting");
            }
            Err(cause) => {
                log::warn!("Nav runner exit with error: {cause}");
            }
        }
    });
}
impl NavigationRunner {
    pub async fn run(mut self) -> Result<(), RunnerError> {
        loop {
            tokio::select! {
                Some(data) = self.input_rx.recv() => {
                    match data {
                        InputData::Device(device_message) => {
                            log::trace!("Device data for {}", device_message.id);
                            self.device_tx.send(device_message).await?;
                        }

                        InputData::Planner(action) => {
                            log::trace!("Planner action");
                            self.planner_tx.send(action).await?;
                        }

                        InputData::State(action) => {
                            if let Some(data) = self.on_state_action(action).await {
                                self.output_tx.send(data).await?;
                            }
                        },
                    }

                    log::trace!("Input data is sent");
                },

                Some(debug_data) = self.debug_rx.recv() => {
                    if let Some(data) = self.on_debug_data(debug_data).await {
                        let _ = self.output_tx.try_send(data);
                    }
                }

                else => {
                    return Err("Invalid data flow".into());
                }
            }
        }
    }

    async fn on_state_action(
        &mut self,
        action: StateAction,
    ) -> Option<OutputData> {
        match action {
            StateAction::SetConfigProperty(property) => {
                self.shared_data
                    .config()
                    .write()
                    .await
                    .apply_property(property);

                let shared_data = Arc::clone(&self.shared_data);

                tokio::task::spawn_blocking(move || {
                    shared_data.on_update_config_blocking();
                });

                None
            }
            StateAction::GetConfig => {
                let config_lock = self.shared_data.config();

                let properties = config_lock.read().await.to_properties();

                Some(properties.into())
            }
        }
    }

    async fn on_debug_data(&mut self, data: DebugData) -> Option<OutputData> {
        let config_lock = self.shared_data.config();
        let debug_config = &config_lock.read().await.debug_config;

        if debug_config.enabled {
            Some(data.into())
        } else {
            None
        }
    }
}

==> ./planner/collision.rs <==
use bresenham::Bresenham;
use nalgebra::Point2;
use roboq_types::model::map::CollisionBox;
pub use roboq_types::model::map::RobotShape;

use crate::model::big_map::MapChunk;

use super::DynamicObstacles;

pub fn has_static_collision(shape: &RobotShape, map: &MapChunk) -> bool {
    //with high statisitical propability, all map cells will be close
    //to each other. By this, it's a good idea to lock them once
    //instead locking in each iteration

    let read_chunk = map.read();

    for (start_point, end_point) in shape.points.iter() {
        let start = shape.resolution.point_to_pixels(start_point);
        let end = shape.resolution.point_to_pixels(end_point);

        for (x, y) in Bresenham::new(
            (start.x as isize, start.y as isize),
            (end.x as isize, end.y as isize),
        ) {
            //fixme: there should be no isize to i32 cast
            let coords = shape
                .resolution
                .point_to_metres(&Point2::new(x as i32, y as i32));
            let Some(cell) = read_chunk.get_cell_at(&coords) else {
                log::debug!("Map cell is not found for Robot shape");
                return true;
            };

            let cost = cell.index_grid(&coords);
            if cost.is_occupied() {
                return true;
            }
        }
    }

    false
}

pub fn has_dynamic_collision(
    shape: &CollisionBox,
    obstacles: &DynamicObstacles,
) -> bool {
    let closest_obstacle = obstacles.closest(&shape.center());

    shape.collides_with_point(&closest_obstacle)
}

==> ./planner/distance_grid/mod.rs <==
use std::collections::VecDeque;

use nalgebra::{Point2, Vector2};
use roboq_types::model::map::MetresPerPixel;

use crate::model::{
    big_map::{map_cell::MapCell, BoxedMapChunk, MapChunk, MapTransform},
    occupancy_grid::{GridCost, MappingError, OCCUPIED_THRESHOLD},
};

//todo: consider to increase performance by decreasing the map precision (according real robot
//shape)
#[derive(Clone)]
pub struct DistanceGrid {
    transforms: Vec<MapTransform>,
    pub resolution: MetresPerPixel,
    cells: Vec<(usize, Vec<DistCell>)>,
}

///Contains the pixels
#[derive(Debug, PartialEq, PartialOrd)]
#[repr(transparent)]
pub struct DistanceCost(f32);

impl DistanceCost {
    pub fn is_reacheable(&self) -> bool {
        self.0 < f32::INFINITY
    }
    pub fn is_unreacheable(&self) -> bool {
        !self.is_reacheable()
    }

    pub fn as_f32(&self) -> f32 {
        self.0
    }
}

#[derive(Clone, Debug)]
pub struct DistCell {
    pub coords: Point2<f32>,

    pub cost: u8,

    pub is_visited: bool,
    ///distance to global path or to local goal
    pub distance: f32,
}

impl DistCell {
    pub fn new(coords: &Point2<f32>, map_cell: &MapCell) -> Self {
        let cost_cell = map_cell.index_grid(coords);
        Self {
            coords: *coords,
            cost: *cost_cell,
            distance: f32::INFINITY,
            is_visited: false,
        }
    }

    fn mark_as_visited(&mut self, distance: f32) {
        self.is_visited = true;
        self.distance = distance;
    }
}

pub struct Wrapper<'a> {
    pub cost: GridCost<'a>,
    pub coords: Point2<f32>,
}

impl DistanceGrid {
    pub fn empty<F: FnMut(&Wrapper) -> Option<f32>>(
        map_chunk: &BoxedMapChunk,
        mut dist_fn: F,
    ) -> Result<Self, MappingError> {
        let mut cells = Vec::new();

        for (cell_id, map_cell_lock) in map_chunk.chunk.data.iter().enumerate()
        {
            let mut dist_cells = Vec::new();
            let map_cell = map_cell_lock.read().unwrap();

            let coords_step = *map_cell.occupancy_grid.resolution;

            for i in 0..map_cell.occupancy_grid.height() {
                let mut next_coords = map_cell.top_left
                    + Vector2::new(0.0, coords_step * (i as f32));

                for _ in 0..map_cell.occupancy_grid.width() {
                    let cost_cell = map_cell.index_grid(&next_coords);

                    let maybe_distance = dist_fn(&Wrapper {
                        coords: next_coords,
                        cost: cost_cell,
                    });

                    let dist_cell = DistCell {
                        coords: next_coords,
                        cost: *cost_cell,
                        distance: maybe_distance.unwrap_or(f32::INFINITY),
                        is_visited: maybe_distance.is_some(),
                    };

                    dist_cells.push(dist_cell);
                    next_coords += Vector2::new(coords_step, 0.0);
                }
            }

            cells.push((cell_id, dist_cells));
        }

        let transforms = map_chunk.collect_transform();
        let resolution = map_chunk.resolution;

        Ok(Self {
            transforms,
            cells,
            resolution,
        })
    }

    ///assumes global path is valid in bounds of occupancy grid
    pub fn with_local_goal(
        chunk: &BoxedMapChunk,
        world_goal: Point2<f32>,
    ) -> Result<Self, MappingError> {
        // assert!(cost_grid.world_to_grid_safe(&world_goal).is_ok());
        let mut grid = Self::empty(chunk, |_| None)?;

        let mut coordinates = VecDeque::<Point2<f32>>::new();

        let mapped_world_goal = {
            let Some(goal_cell) = grid.get_cell_mut(&world_goal) else {
                return Err(MappingError::NotPresent(world_goal));
            };

            goal_cell.mark_as_visited(0.0);
            coordinates.push_back(goal_cell.coords);
            goal_cell.coords
        };

        let Some(goal_cell) = grid.get_cell_mut(&mapped_world_goal) else {
            return Err(MappingError::NotPresent(mapped_world_goal));
        };

        goal_cell.mark_as_visited(0.0);

        let coords = goal_cell.coords;
        coordinates.push_back(coords);

        let coords_step = *grid.resolution;
        let coords_radius = coords_step / 2.0;

        let coords_vectors = [
            Vector2::new(-coords_step, 0.),
            Vector2::new(coords_step, 0.),
            Vector2::new(0., -coords_step),
            Vector2::new(0., coords_step),
            Vector2::new(coords_radius, coords_radius),
            Vector2::new(-coords_radius, coords_radius),
            Vector2::new(coords_radius, -coords_radius),
            Vector2::new(-coords_radius, -coords_radius),
        ];

        coords_vectors
            .iter()
            .for_each(|v| coordinates.push_back(coords + v));

        grid.update_distance(coordinates, avoid_collision_cost);

        Ok(grid)
    }

    pub fn with_global_path(
        cost_grid: &BoxedMapChunk,
        global_path: &[Point2<f32>],
    ) -> Result<Self, MappingError> {
        assert!(!global_path.is_empty());
        let mut grid = Self::empty(cost_grid, |_| None)?;
        let mut coordinates = VecDeque::<Point2<f32>>::new();

        for world_point in global_path.iter() {
            let path_coords = {
                let Some(path_cell) = grid.get_cell_mut(world_point) else {
                    log::debug!("Forgotten global path point");
                    continue;
                };

                path_cell.mark_as_visited(0.0);
                path_cell.coords
            };

            if let Some(cell) = grid.get_cell_mut(&path_coords) {
                coordinates.push_back(path_coords);
                coordinates.push_back(cell.coords);
                cell.mark_as_visited(0.0);
            }
        }

        grid.update_distance(coordinates, avoid_collision_cost);

        Ok(grid)
    }

    pub fn collision_map(map: &MapChunk) -> Result<Self, MappingError> {
        let collision_count = 1024; //todo: need a fast way to calculate

        let mut queue = VecDeque::<Point2<f32>>::with_capacity(collision_count);

        let mut grid = Self::empty(map, |cell| {
            if cell.cost.is_occupied() {
                queue.push_back(cell.coords);
                Some(0.0)
                //fill distance grid with zeroes and set occupied
                //cells as visited
            } else {
                None
            }
        })?;

        grid.update_distance(queue, collision_distance_cost);

        Ok(grid)
    }

    pub fn index_distance(&self, point: &Point2<f32>) -> DistanceCost {
        let Some(grid_cell) = self.get_cell(point) else {
            log::warn!("Cost map index should be suitable for distance grid");
            return DistanceCost(f32::INFINITY);
        };

        DistanceCost(grid_cell.distance)
    }

    fn get_cell(&self, cell_coords: &Point2<f32>) -> Option<&'_ DistCell> {
        let transform = self
            .transforms
            .iter()
            .find(|tr| tr.in_bounds(cell_coords))?;

        let grid_coords = transform.world_to_grid(cell_coords);

        let index = transform.index(&grid_coords);

        self.cells
            .iter()
            .filter(|(cell_id, _cells)| *cell_id == transform.cell_id())
            .filter_map(|(_cell_id, cells)| cells.get(index))
            .next()
    }

    fn get_cell_mut(
        &mut self,
        cell_coords: &Point2<f32>,
    ) -> Option<&mut DistCell> {
        let transform = self
            .transforms
            .iter()
            .find(|tr| tr.in_bounds(cell_coords))?;

        let grid_coords = transform.world_to_grid(cell_coords);

        let index = transform.index(&grid_coords);

        // log::debug!("Access (cell_id = {current_cell_id}, index = {index})");

        self.cells
            .iter_mut()
            .filter(|(cell_id, _cells)| *cell_id == transform.cell_id())
            .filter_map(|(_cell_id, cells)| cells.get_mut(index))
            .next()
    }

    fn update_distance<F>(
        &mut self,
        mut coordinates_queue: VecDeque<Point2<f32>>,
        on_next_cell: F,
    ) where
        F: FnOnce(&mut DistCell, f32) -> Option<Point2<f32>> + Copy,
    {
        let coords_step = *self.resolution;
        let coords_radius = coords_step / 2.0;

        let coords_vectors = [
            Vector2::new(-coords_step, 0.),
            Vector2::new(coords_step, 0.),
            Vector2::new(0., -coords_step),
            Vector2::new(0., coords_step),
            Vector2::new(coords_radius, coords_radius),
            Vector2::new(-coords_radius, coords_radius),
            Vector2::new(coords_radius, -coords_radius),
            Vector2::new(-coords_radius, -coords_radius),
        ];

        while let Some(cell_coords) = coordinates_queue.pop_front() {
            let next_distance =
                self.index_distance(&cell_coords).as_f32() + 1.0;

            if next_distance.is_infinite() {
                continue;
            }

            for coords_diff in coords_vectors.iter() {
                let next_coords = cell_coords + coords_diff;

                if let Some(next_cell) = self.get_cell_mut(&next_coords) {
                    if let Some(coords) = on_next_cell(next_cell, next_distance)
                    {
                        // log::debug!("Next point is pushed");
                        coordinates_queue.push_back(coords);
                    }
                }
            }
        }
    }
}

fn avoid_collision_cost(
    cell: &mut DistCell,
    next_distance: f32,
) -> Option<Point2<f32>> {
    let is_first_visit = !cell.is_visited;

    if cell.cost <= OCCUPIED_THRESHOLD {
        cell.mark_as_visited(f32::INFINITY);
        return None;
    }

    assert!(!next_distance.is_infinite());

    let distance = f32::min(next_distance, cell.distance);
    cell.mark_as_visited(distance);

    if is_first_visit {
        Some(cell.coords)
    } else {
        None
    }
}

fn collision_distance_cost(
    cell: &mut DistCell,
    next_distance: f32,
) -> Option<Point2<f32>> {
    let is_first_visit = !cell.is_visited;

    if cell.cost <= OCCUPIED_THRESHOLD {
        cell.mark_as_visited(0.0);
        return None;
    }

    assert!(!next_distance.is_infinite());

    let distance = f32::min(next_distance, cell.distance);
    cell.mark_as_visited(distance);

    if is_first_visit {
        Some(cell.coords)
    } else {
        None
    }
}

#[cfg(test)]
mod tests {
    use std::sync::{RwLock, RwLockWriteGuard};

    use super::*;
    use crate::model::{
        array2d::Array2D, big_map::MapCellLock, metres::Metres, MetresPerPixel,
    };

    #[test]
    pub fn single_cell_test() {
        let mut map_cell = MapCell::new(
            Point2::new(0.0, 0.0),
            Metres(6.0),
            MetresPerPixel(1.0),
        );
        for x in 0..6 {
            for y in 0..6 {
                let point = Point2::new(x as f32, y as f32);
                *map_cell.index_grid_mut(&point) = 255;
            }
        }
        *map_cell.index_grid_mut(&Point2::new(2., 2.)) = 0;
        *map_cell.index_grid_mut(&Point2::new(1., 3.)) = 0;
        *map_cell.index_grid_mut(&Point2::new(3., 3.)) = 0;
        *map_cell.index_grid_mut(&Point2::new(4., 2.)) = 0;
        *map_cell.index_grid_mut(&Point2::new(1., 5.)) = 0;
        *map_cell.index_grid_mut(&Point2::new(1., 1.)) = 0;
        *map_cell.index_grid_mut(&Point2::new(5., 4.)) = 0;

        let map_cell = RwLock::new(map_cell);

        let map_chunk = MapChunk {
            top_left: Point2::new(0.0, 6.0),
            cell_size: Metres(6.0),
            resolution: MetresPerPixel(1.0),
            chunk: Array2D::new_from_row_major(
                1,
                vec![map_cell.write().unwrap()],
            ),
        };

        let distance_grid =
            DistanceGrid::with_local_goal(&map_chunk, Point2::new(2.0, 3.0))
                .unwrap();

        assert_eq!(
            distance_grid
                .index_distance(&Point2::new(5.0, 0.0))
                .as_f32(),
            8.0
        );
        assert_eq!(
            distance_grid
                .index_distance(&Point2::new(2.0, 3.0))
                .as_f32(),
            0.0
        );
        assert_eq!(
            distance_grid
                .index_distance(&Point2::new(0.0, 0.0))
                .as_f32(),
            7.0
        );
        assert_eq!(
            distance_grid
                .index_distance(&Point2::new(3.0, 1.0))
                .as_f32(),
            9.0
        );
        assert_eq!(
            distance_grid
                .index_distance(&Point2::new(0.0, 5.0))
                .as_f32(),
            4.0
        );
    }
    #[test]
    pub fn four_cell_test() {
        let cell_size = Metres(4.0);
        let resolution = MetresPerPixel(1.0);

        let mut cells = vec![
            MapCell::new(Point2::new(8., 16.), cell_size, resolution),
            MapCell::new(Point2::new(12., 16.), cell_size, resolution),
            MapCell::new(Point2::new(8., 20.), cell_size, resolution),
            MapCell::new(Point2::new(12., 20.), cell_size, resolution),
        ];

        for cell in cells.iter_mut() {
            let pixels_count = 8; //4 / 0.5
            for x in 0..pixels_count {
                for y in 0..pixels_count {
                    *cell.occupancy_grid.index_grid_mut(&Point2::new(x, y)) =
                        255;
                }
            }
        }

        *cells[0].index_grid_mut(&Point2::new(1.0 + 8., 1.0 + 16.)) = 0;
        *cells[0].index_grid_mut(&Point2::new(0.0 + 8., 2.0 + 16.)) = 0;
        *cells[0].index_grid_mut(&Point2::new(1.0 + 8., 3.0 + 16.)) = 0;
        *cells[0].index_grid_mut(&Point2::new(3.0 + 8., 3.0 + 16.)) = 0;

        *cells[1].index_grid_mut(&Point2::new(4.0 + 8., 1.0 + 16.)) = 0;
        *cells[1].index_grid_mut(&Point2::new(5.0 + 8., 2.0 + 16.)) = 0;
        *cells[1].index_grid_mut(&Point2::new(6.0 + 8., 2.0 + 16.)) = 0;

        *cells[2].index_grid_mut(&Point2::new(2.0 + 8., 5.0 + 16.)) = 0;
        *cells[2].index_grid_mut(&Point2::new(1.0 + 8., 6.0 + 16.)) = 0;

        *cells[3].index_grid_mut(&Point2::new(7.0 + 8., 5.0 + 16.)) = 0;
        *cells[3].index_grid_mut(&Point2::new(6.0 + 8., 6.0 + 16.)) = 0;
        *cells[3].index_grid_mut(&Point2::new(6.0 + 8., 7.0 + 16.)) = 0;

        let chunk_cells = cells
            .into_iter()
            .map(RwLock::new)
            .collect::<Vec<MapCellLock>>();

        let chunk_cell_guards = chunk_cells
            .iter()
            .map(|lock| lock.write().unwrap())
            .collect::<Vec<RwLockWriteGuard<'_, MapCell>>>();

        let map_chunk = BoxedMapChunk {
            top_left: Point2::new(8., 16.),
            cell_size,
            resolution,
            chunk: Array2D::new_from_row_major(2, chunk_cell_guards),
        };

        let distance_grid = DistanceGrid::with_local_goal(
            &map_chunk,
            Point2::new(4. + 8., 4. + 16.),
        )
        .unwrap();

        assert!(distance_grid
            .index_distance(&Point2::new(7. + 8., 6. + 16.))
            .as_f32()
            .is_infinite());

        assert!(distance_grid
            .index_distance(&Point2::new(1. + 8., 1. + 16.))
            .as_f32()
            .is_infinite());

        assert!(distance_grid
            .index_distance(&Point2::new(1. + 8., 1. + 16.))
            .as_f32()
            .is_infinite());

        assert_eq!(
            distance_grid
                .index_distance(&Point2::new(2. + 8., 2. + 16.))
                .as_f32(),
            4.
        );

        assert_eq!(
            distance_grid
                .index_distance(&Point2::new(0. + 8., 0. + 16.))
                .as_f32(),
            8.
        );

        assert_eq!(
            distance_grid
                .index_distance(&Point2::new(4. + 8., 4. + 16.))
                .as_f32(),
            0.
        );
    }
}

==> ./planner/dwa_local_planner.rs <==
use std::collections::HashMap;
use std::f32::consts::FRAC_PI_2;

use crate::model::normalize_angle;
use crate::planner::{metrics::MetricCost, MetricsBuilder};

use nalgebra::{Point2, Vector2};
use roboq_types::model::localization::RobotState;

use super::metrics::MetricKind;
use super::{
    GlobalPlanner, LimitsConfig, LocalPlanError, ManualPlanConfig, MetricError,
    PlanConfig, PlannerSimulationConfig, SimulationWorld, TrajectoryMetric,
};

use roboq_types::model::pose::Pose2D;
use roboq_types::model::{
    plan::{State, Trajectory, TrajectoryMetadata},
    pose::VelocityPose2D,
};

pub fn is_reached_by_dist(
    coords: &Point2<f32>,
    goal: &Point2<f32>,
    config: &PlannerSimulationConfig,
) -> bool {
    let goal_direction = goal - coords;
    let dist2_to_goal = goal_direction.norm_squared();

    dist2_to_goal < config.limits.world_goal_tolerance_distance.powi(2)
}

pub enum LocalPlanEvent {
    Velocity(VelocityPose2D),
    LocalGoalReached,
    GlobalGoalReached,
}

impl From<VelocityPose2D> for LocalPlanEvent {
    fn from(value: VelocityPose2D) -> Self {
        Self::Velocity(value)
    }
}

pub fn estimate_local_plan(
    plan_config: PlanConfig<'_>,
) -> Result<LocalPlanEvent, LocalPlanError> {
    let PlanConfig {
        mut world,
        metrics_data,
        rules,
        debug_tx,
    } = plan_config;

    assert!(!world.global_path.is_empty());

    let limits = &rules.limits;

    let is_global_goal_next = world.global_path.len() == 1;

    let dist2_to_goal = world.distance2_to_goal();

    if !is_global_goal_next
        && dist2_to_goal < limits.local_goal_tolerance_distance.powi(2)
    {
        return Ok(LocalPlanEvent::LocalGoalReached);
    }

    if is_global_goal_next
        && dist2_to_goal < limits.world_goal_tolerance_distance.powi(2)
    {
        return Ok(LocalPlanEvent::GlobalGoalReached);
    }

    //build identity shape (position independent)
    let robot_shape = world.robot.build_shape(
        world.map_chunk.resolution,
        rules.collision_distance,
        world.robot.state(),
    );

    let map_chunk = world.map_chunk.to_owned();
    map_chunk.iter_cell().for_each(|lock| {
        lock.write()
            .unwrap()
            .occupancy_grid
            .grow_occupied_cells_mut(rules.collision_distance);
    });

    let global_path = world.global_path_points();

    log::trace!("Trajectories will be built");

    let mut trajectories =
        build_trajectories(&mut world, &rules, is_global_goal_next)?;

    assert!(!trajectories.is_empty());

    log::trace!("Trajectories are built");

    let time = std::time::Instant::now();

    // let any_reached = trajectories.iter().any(|t| t.reached);
    //
    // if any_reached {
    //     trajectories.retain(|t| t.reached);
    // }

    let mut metrics_builder = MetricsBuilder {
        map_chunk: Some(&map_chunk),
        target: Some(world.target_pose),
        global_path: Some(&global_path),
        data: Some(metrics_data),
        obstacles: world.obstacles,
        robot: &world.robot,
        planner_config: &rules,
    };

    let (mut metrics, weights) = metrics_builder.build(rules.metrics.clone());

    let mut trajectories_map = trajectories
        .iter_mut()
        .enumerate()
        .filter_map(|(index, traj)| {
            evaluate_cost(traj, &mut metrics)
                .inspect_err(|cause| {
                    log::debug!("Failed to evaluate cost: {cause}")
                })
                .ok()
                .map(|costs| (index, costs))
        })
        .collect::<HashMap<_, _>>();

    let mut cost_map = HashMap::<MetricKind, Vec<MetricCost>>::new();

    for trajectory_costs in trajectories_map.values() {
        for (kind, cost) in trajectory_costs.iter() {
            cost_map
                .entry(*kind)
                .and_modify(|e| e.push(*cost))
                .or_insert(vec![*cost]);
        }
    }

    cost_map.into_iter().for_each(|(kind, costs)| {
        let min = costs.iter().copied().min();
        let max = costs.iter().copied().max();

        let Some((min, max)) = min.zip(max) else {
            return;
        };

        trajectories_map.values_mut().for_each(|costs| {
            let cost = costs
                .get_mut(&kind)
                .expect("Metric same for all trajectories");

            if min != max {
                *cost = (*cost - min) / (max - min);
            } else {
                //metric doesn't have any impact
                *cost = MetricCost::ZERO;
            }
        });
    });

    let mut best_trajectory_cost = None;

    for (id, costs) in trajectories_map.into_iter() {
        let cost =
            costs
                .into_iter()
                .fold(MetricCost::ZERO, |sum, (kind, cost)| {
                    let w = weights
                        .get(&kind)
                        .copied()
                        .expect("Weights contains same metrics");

                    sum + cost * w
                });

        if let Some((_, prev_cost)) = best_trajectory_cost {
            if cost < prev_cost {
                best_trajectory_cost = Some((id, cost));
            }
        } else {
            best_trajectory_cost = Some((id, cost));
        }
    }

    log::trace!("Took to evaluate cost: {}", time.elapsed().as_millis());

    let Some((index, cost)) = best_trajectory_cost else {
        if let Some(debugger) = debug_tx {
            let _ = debugger
                .try_send(TrajectoryMetadata::from(trajectories).into());
        }

        return Err(LocalPlanError::TrajectoryNotFound);
    };

    log::debug!("Best trajectory with cost: {}", *cost);

    let velocity = {
        let trajectory = trajectories.get(index).unwrap();

        drop(metrics);

        metrics_data.update(world.robot.state(), trajectory, &rules);

        VelocityPose2D {
            translation: trajectory.target_velocity,
            angular: trajectory.target_angular,
        }
    };

    if let Some(debugger) = debug_tx {
        let best_trajectory = trajectories.remove(index);
        let shapes = best_trajectory.interpolate_shapes(&robot_shape);

        let metadata = TrajectoryMetadata {
            best_trajectory: Some((best_trajectory, shapes)),
            trajectories,
        };

        let _ = debugger.try_send(metadata.into()).inspect(|cause| {
            log::trace!("Failed to send trajectories: {cause:?}")
        });
    }

    world.tracker.track(
        world.robot.state(),
        velocity,
        rules.limits.simulation_tick,
    );

    Ok(velocity.into())
}

pub fn estimate_manual_plan(
    plan_config: ManualPlanConfig<'_>,
) -> Result<VelocityPose2D, LocalPlanError> {
    let ManualPlanConfig {
        rules,
        target_twist,
        robot,
        map_chunk,
        obstacles,
        debug_tx,
    } = plan_config;

    let limits = &rules.limits;

    if limits.brake_aware_ratio.abs() > 1.0 {
        return Err("Brake aware should be in [-1, 1] range".into());
    }

    if !rules.use_collisions {
        return Ok(target_twist);
    }

    let max_dist2 = f32::max(
        limits.world_goal_tolerance_distance,
        limits.local_goal_tolerance_distance,
    )
    .powi(2)
        * limits.brake_aware_ratio;

    let robot_shape = robot.build_shape(
        map_chunk.resolution,
        rules.collision_distance,
        robot.state(),
    );

    let tick_time = limits.simulation_tick.as_secs_f32();
    let simulation_time = limits.simulation_time.as_secs_f32();

    let max_ticks_count = (simulation_time / tick_time).ceil() as usize + 1;

    let mut current_coords = robot.state().position.coords;
    let mut current_heading = robot.state().position.heading_rad;
    let current_velocity = target_twist.translation;
    let current_angular = target_twist.angular;

    let mut states = Vec::<State>::new();

    //build trajectory for manual plan
    for _ in 0..max_ticks_count {
        let walk_dist2 =
            (current_coords - robot.state().position.coords).norm_squared();
        if walk_dist2 > max_dist2 {
            break;
        }

        current_coords.x += (current_velocity.x * f32::cos(current_heading)
            + current_velocity.y * f32::sin(current_heading + FRAC_PI_2))
            * tick_time;

        current_coords.y += (current_velocity.x * f32::sin(current_heading)
            + current_velocity.y * f32::cos(current_heading + FRAC_PI_2))
            * tick_time;

        current_heading += current_angular * tick_time;

        states.push(State {
            position: Pose2D {
                coords: current_coords,
                heading_rad: current_heading,
            },
            velocity: current_velocity,
            angular: current_angular,
        });
    }

    if states.is_empty() {
        //staying in place
        return Ok(VelocityPose2D::stop());
    }

    let trajectory = Trajectory {
        states,
        target_velocity: target_twist.translation,
        target_angular: target_twist.angular,
        reached: true,
    };

    let use_dwa_path_check = false;

    if use_dwa_path_check {
        let mut metrics_builder = MetricsBuilder {
            map_chunk: Some(&map_chunk),
            obstacles: obstacles.as_ref(),
            robot: &robot,
            target: None,
            global_path: None,
            data: None,
            planner_config: rules,
        };

        let (mut metrics, _weights) =
            metrics_builder.build(rules.metrics.clone());

        if evaluate_cost(&trajectory, &mut metrics).is_ok() {
            if let Some(debugger) = debug_tx {
                let shapes = trajectory.interpolate_shapes(&robot_shape);
                let metadata = TrajectoryMetadata {
                    best_trajectory: Some((trajectory, shapes)),
                    trajectories: vec![],
                };

                let _ = debugger.try_send(metadata.into());
            }

            Ok(target_twist)
        } else {
            if let Some(debugger) = debug_tx {
                let metadata = TrajectoryMetadata {
                    best_trajectory: None,
                    trajectories: vec![trajectory.clone()],
                };

                let _ = debugger.try_send(metadata.into());
            }

            Err(LocalPlanError::TrajectoryNotFound)
        }
    } else {
        let mut planner = GlobalPlanner::new_global_plan(
            robot.state().position.coords,
            trajectory.finish_state().position.coords,
            rules,
            &map_chunk,
        );

        if let Some(obstacles) = obstacles.as_ref() {
            planner.set_obstacles(obstacles);
        }

        if let Some(debugger) = debug_tx.clone() {
            planner.set_debug(debugger);
        }

        let maybe_plan = planner.estimate();

        if maybe_plan.is_some() {
            Ok(target_twist)
        } else {
            Err(LocalPlanError::TrajectoryNotFound)
        }
    }
}

pub fn generate_range(v_min: f32, v_max: f32, step: f32) -> Vec<f32> {
    assert!(step > 0.0);

    if v_max <= v_min {
        return vec![v_min];
    }

    let count = ((v_max - v_min) / step) as usize;

    if count <= 1 {
        //generate only minimal velocity
        //as difference between max and min
        //is too small
        return vec![v_min];
    }

    let count = count.max(2);

    (0..count).map(|i| v_min + i as f32 * step).collect()
}

pub fn build_trajectories(
    world: &mut SimulationWorld,
    config: &PlannerSimulationConfig,
    is_global_target: bool,
) -> Result<Vec<Trajectory>, LocalPlanError> {
    let limits = &config.limits;

    assert!(config.robot.min_velocity > 0.0 && config.robot.min_angular > 0.0);

    let optimization = config.limits.angular_optimization.clone();

    let max_angular = config.robot.max_angular;

    let estimate_max_angular = move |state: &RobotState| -> f32 {
        if !config.use_motion_optimization {
            return max_angular;
        }

        let v_local = state.velocity.into_local(state.position.heading_rad);
        optimization
            .estimate_angular(v_local.translation.x)
            .clamp(0.0, max_angular)
    };

    let motion_time = world.tracker.elapsed_in_motion();
    let v_min = world
        .tracker
        .last_velocity()
        .map(|v| f32::max(config.robot.min_velocity, v.translation.x))
        .unwrap_or(config.robot.min_velocity);

    let estimate_max_velocity = |state: &RobotState| -> f32 {
        if !config.use_motion_optimization {
            return config.robot.max_velocity;
        }

        let dist_to_goal =
            (world.target_pose.coords - state.position.coords).norm();

        let stop_time = dist_to_goal / config.robot.max_velocity;

        if stop_time <= limits.deceleration_time.as_secs_f32() {
            let y = limits.deceleration_time.as_secs_f32();
            let base_pow = -y.log10() / y;

            let pow =
                base_pow * (limits.deceleration_time.as_secs_f32() - stop_time);
            let output = f32::exp(pow) * config.robot.max_velocity;

            output.clamp(config.robot.min_velocity, config.robot.max_velocity)
        } else if motion_time < limits.acceleration_time {
            let x = motion_time.as_secs_f32();
            let a = x / limits.acceleration_time.as_secs_f32();

            assert!((0.0..=1.0).contains(&a));

            f32::max(v_min, a.powi(3) * config.robot.max_velocity)
        } else {
            config.robot.max_velocity
        }
    };

    let mut force_back_movement = false;

    let mut estimate_min_velocity = || -> Result<f32, LocalPlanError> {
        let default_min_velocity = config.robot.min_velocity;
        let state = world.robot.state();

        if !config.use_stuck_detection {
            log::debug!("Skipping stuck detection");
            return Ok(default_min_velocity);
        }

        let Some(last_state) = world.tracker.last_state() else {
            log::debug!("No estimated state for tracker");
            return Ok(default_min_velocity);
        };

        let dist = (last_state.position.coords - state.position.coords).norm();
        let rotation = normalize_angle(
            last_state.position.heading_rad - state.position.heading_rad,
        );

        log::debug!("Stuck rotation: {rotation}. Stuck distance = {dist}");

        if rotation.abs() > config.stuck.rotation_tolerance
            || dist > *config.stuck.distance_tolerance
        {
            world.tracker.reset_stuck();
            return Ok(default_min_velocity);
        }

        let stuck_duration = world.tracker.detect_stuck();

        if stuck_duration < config.stuck.stuck_time_tolerance {
            return Ok(default_min_velocity);
        }

        log::debug!("Stuck duration {stuck_duration:?}");
        if stuck_duration > config.stuck.max_stuck_time {
            return Err(LocalPlanError::StuckDetected);
        }

        let elapsed = stuck_duration;
        let max_elapsed = config.stuck.max_stuck_time;

        //default policy
        let v = config.robot.min_velocity
            + (config.robot.max_velocity - config.robot.min_velocity)
                * elapsed.as_secs_f32()
                / max_elapsed.as_secs_f32();

        if stuck_duration > config.stuck.stuck_time_force_backward {
            force_back_movement = true;
            Ok(v)
        } else {
            Ok(config.robot.max_velocity)
        }
    };

    let min_velocity = estimate_min_velocity()?;

    let max_velocity = estimate_max_velocity(world.robot.state());

    let max_angular = estimate_max_angular(world.robot.state());

    let velocity_range = {
        let mut range = vec![];

        if !force_back_movement {
            range.extend_from_slice(&generate_range(
                min_velocity,
                max_velocity,
                limits.velocity_sample_step,
            ));
        }

        if !config.robot.align_to_heading || force_back_movement {
            log::debug!("revese: {force_back_movement}. v_min = -{max_velocity}. v_max = -{min_velocity}");

            range.extend_from_slice(&generate_range(
                -max_velocity,
                -min_velocity,
                limits.velocity_sample_step,
            ));
        }

        assert!(!range.is_empty());

        range
    };

    let angular_range = {
        let mut range =
            generate_range(0.0, max_angular, limits.angular_sample_step);

        range.extend_from_slice(&generate_range(
            -max_angular,
            0.0,
            limits.angular_sample_step,
        ));

        range
    };

    let trajectory_builder = TrajectoryBuilder {
        limits,
        target: &world.target_pose,
        ticks_limit: None,
    };

    let robot_state = world.robot.state();

    let mut trajectories = Vec::<Trajectory>::new();

    for &target_velocity_x in velocity_range.iter() {
        for &target_angular in angular_range.iter() {
            assert!(
                target_velocity_x.abs() >= f32::EPSILON,
                "range = {velocity_range:?}"
            );

            let trajectory = trajectory_builder.build_curve(
                target_velocity_x,
                target_angular,
                robot_state,
            );

            trajectories.push(trajectory);
        }
    }

    if config.use_rotation_in_place {
        //build pure pursuit trajectory
        let tick_time = limits.simulation_tick.as_secs_f32();
        let simulation_time = limits.simulation_time.as_secs_f32();

        let ticks_count = (simulation_time / tick_time).ceil() as usize + 1;

        let mut states = Vec::<State>::with_capacity(ticks_count + 1);

        let current_coords = world.robot.state().position.coords;
        let mut current_heading = world.robot.state().position.heading_rad;

        assert!(ticks_count >= 1);

        let goal_direction = world.target_pose.coords - current_coords.coords;

        let angle_to_goal = goal_direction.y.atan2(goal_direction.x);

        let rotation = normalize_angle(angle_to_goal - current_heading);
        if rotation.abs() > limits.target_rotation_tolerance {
            //else we already rotated
            //towardsd goal and direct
            //trajectory can be used

            let rotation_angular = {
                let raw_angular = rotation / tick_time;

                let angular = f32::min(max_angular, raw_angular.abs());

                let angular = f32::max(config.robot.min_angular, angular);

                angular * raw_angular.signum()
            };

            let rotations_ticks =
                ((rotation / rotation_angular) / tick_time).ceil() as usize;

            assert!(rotations_ticks >= 1);

            for _ in 0..rotations_ticks {
                current_heading += rotation / rotations_ticks as f32;

                states.push(State {
                    position: Pose2D {
                        coords: current_coords,
                        heading_rad: current_heading,
                    },
                    angular: rotation_angular,
                    velocity: Vector2::zeros(),
                });
            }

            let mut rotation_trajectory = Trajectory {
                reached: false,
                states,
                target_angular: rotation_angular,
                target_velocity: Vector2::zeros(),
            };

            log::debug!(
                "Init Head = {}. Rotation = {}. Target Head = {}",
                world.robot.state().position.heading_rad.to_degrees(),
                rotation.to_degrees(),
                rotation_trajectory
                    .finish_state()
                    .position
                    .heading_rad
                    .to_degrees()
            );

            rotation_trajectory.clone_from(trajectory_builder.build_curve(
                max_velocity,
                0.0,
                &rotation_trajectory.finish_state().into(),
            ));

            if is_global_target || !config.limits.skip_local_alignment {
                let force_rotation = world.distance2_to_goal()
                    <= limits.force_rotation_distance.powi(2);

                if force_rotation {
                    return Ok(vec![rotation_trajectory]);
                }
            }

            trajectories.push(rotation_trajectory);
        }
    }

    for &target_velocity_x in velocity_range.iter() {
        trajectories.push(trajectory_builder.build_curve(
            target_velocity_x,
            0.0,
            robot_state,
        ));
    }

    Ok(trajectories)
}

pub struct TrajectoryBuilder<'a> {
    pub limits: &'a LimitsConfig,
    pub ticks_limit: Option<usize>,
    pub target: &'a Pose2D,
}

impl TrajectoryBuilder<'_> {
    pub fn build_curve(
        &self,
        target_velocity_x: f32,
        target_angular: f32,
        state: &RobotState,
    ) -> Trajectory {
        let limits = self.limits;
        let tick_time = limits.simulation_tick.as_secs_f32();
        let dist2_tolerance = limits.target_rotation_tolerance.powi(2);

        let simulation_time = limits.simulation_time.as_secs_f32();

        let ticks_count = self
            .ticks_limit
            .unwrap_or((simulation_time / tick_time).ceil() as usize + 1);

        let mut states = Vec::<State>::with_capacity(ticks_count + 1);

        let mut current_coords = state.position.coords;
        let mut current_heading = state.position.heading_rad;

        let current_velocity = Vector2::new(target_velocity_x, 0.0);
        let current_angular = target_angular;
        let mut is_reached = false;

        assert!(ticks_count >= 1);

        let mut prev_coords = current_coords;

        for _ in 0..ticks_count {
            let v_x = current_velocity.x * current_heading.cos()
                - current_velocity.y * current_heading.sin();
            let v_y = current_velocity.x * current_heading.sin()
                + current_velocity.y * current_heading.cos();

            current_coords.x += v_x * tick_time;

            current_coords.y += v_y * tick_time;

            current_heading += current_angular * tick_time;

            states.push(State {
                position: Pose2D {
                    coords: current_coords,
                    heading_rad: current_heading,
                },
                angular: current_angular,
                velocity: current_velocity,
            });

            let v12 = current_coords - prev_coords;
            let v1t = self.target.coords - prev_coords;
            let len2 = (self.target.coords - prev_coords).norm_squared();

            let t = (v1t.x * v12.x + v1t.y * v12.y) / len2;

            let closest_point = if t < 0.0 {
                prev_coords
            } else if t > 1.0 {
                current_coords
            } else {
                prev_coords + v12 * t
            };

            let dist2 = (self.target.coords - closest_point).norm_squared();

            is_reached = dist2 <= dist2_tolerance;

            if is_reached {
                break;
            }

            prev_coords = current_coords;
        }

        Trajectory {
            states,
            target_velocity: Vector2::new(target_velocity_x, 0.0),
            target_angular,
            reached: is_reached,
        }
    }
}

/// Estimated cost for this trajectory and cache this value
fn evaluate_cost(
    trajectory: &Trajectory,
    metrics: &mut [TrajectoryMetric],
) -> Result<HashMap<MetricKind, MetricCost>, MetricError> {
    let mut map = HashMap::new();

    for metric in metrics.iter_mut() {
        let (kind, cost) = metric(trajectory)?;

        map.insert(kind, cost);
    }

    Ok(map)
}

==> ./planner/dwa_tandem_local_planner.rs <==
use std::{f32::consts::FRAC_PI_2, time::Duration};

use crate::planner::{metrics::MetricCost, MetricsBuilder};

use nalgebra::{Rotation2, Vector2};

use super::{
    LocalPlanError, ManualPlanConfig, MetricError, Plan, PlanConfig, PlannerSimulationConfig, SimulationWorld, TrajectoryMetric
};

use roboq_types::model::pose::Pose2D;
use roboq_types::model::{
    plan::{RobotShape, State, Trajectory, TrajectoryMetadata},
    pose::VelocityPose2D,
};

pub fn estimate_local_plan(
    plan_config: PlanConfig<'_>,
) -> Result<Plan, LocalPlanError> {
    let PlanConfig {
        world,
        mut rules,
        enable_metadata,
    } = plan_config;

    assert!(!world.global_path.is_empty());

    let limits = &rules.limits;

    let is_global_goal_next =
        (world.global_path.len() - 1) == world.target_point_id;

    //build identity shape (position independent)
    let robot_shape = RobotShape::new(
        rules.robot.width,
        rules.robot.length,
        world.map_chunk.resolution,
    );

    let (dist2_to_goal, angle_to_goal) = {
        let pos = world.state.position;
        let goal_direction = world.target_point - pos.coords;
        let robot_direction =
            { Vector2::new(pos.heading_rad.cos(), pos.heading_rad.sin()) };

        let yaw =
            Rotation2::rotation_between(&goal_direction, &robot_direction)
                .angle();
        (goal_direction.norm_squared(), yaw)
    };

    if !is_global_goal_next
        && dist2_to_goal < limits.local_goal_tolerance_distance.powi(2)
    {
        return Ok(Plan::stop());
    }

    if is_global_goal_next {
        if dist2_to_goal < limits.world_goal_tolerance_distance.powi(2)
            && angle_to_goal.abs() < limits.world_goal_tolerance_angle
        {
            return Ok(Plan::stop());
        }

        if dist2_to_goal < limits.world_goal_tolerance_distance.powi(2) {
            return Ok(Plan::stop());
            // return Ok(Plan::alignment(angle_to_goal));
        }
    }

    //slowing is enabled only for global goal
    if is_global_goal_next
        && dist2_to_goal < limits.goal_slowing_distance.powi(2)
    {
        rules.robot.min_velocity *= limits.velocity_slowing_ratio;
        rules.robot.max_velocity *= limits.velocity_slowing_ratio;
    }

    let metrics_builder = MetricsBuilder {
        map_chunk: Some(&world.map_chunk),
        target: Some(world.target_point),
        global_path: Some(world.global_path),
        data: Some(world.metrics_data.clone()),
        robot_shape: robot_shape.clone(),
        obstacles: &world.obstacles,
    };

    log::trace!("Trajectories will be built");

    let mut trajectories = build_trajectories(&world, &rules)?;

    assert!(!trajectories.is_empty());

    log::trace!("Trajectories are built");

    let mut metrics = metrics_builder.with_config(rules.metrics.clone());

    let trajectory_cost_evaluation = trajectories
        .iter_mut()
        .enumerate()
        .filter_map(|(index, traj)| 
            evaluate_cost(traj, &mut metrics)
               .ok()
               .map(|cost| (index, cost))
        )
        .fold(
            Option::<(usize, MetricCost)>::None,
            |best_cost_opt, (index, cost)| {
                log::trace!("Cost {:?} on index {}", cost, index);
                if matches!(best_cost_opt.as_ref(), Some((_, best_cost)) if *best_cost > cost)
                        || best_cost_opt.is_none()
                {
                    log::trace!("The best traj will will be replaced with cost={:?}", cost);
                    Some((index, cost))
                } else {
                    best_cost_opt
                }
            },
        );

    let Some((index, _)) = trajectory_cost_evaluation else {
        let metadata =
            enable_metadata.then(|| TrajectoryMetadata::from(trajectories));
        return Err(metadata.into());
    };

    log::trace!("Best trajectory with index: {index}");
    let twist = {
        let trajectory = trajectories.get(index).unwrap();
        world.metrics_data.update(world.state, trajectory);
        VelocityPose2D {
            translation: trajectory.target_velocity,
            angular: trajectory.target_angular,
        }
    };

    let metadata = enable_metadata.then(|| {
        let best_trajectory = trajectories.remove(index);
        let shapes = best_trajectory.build_shapes(&robot_shape);
        TrajectoryMetadata {
            best_trajectory: Some((best_trajectory, shapes)),
            trajectories,
        }
    });

    Ok(Plan { twist, metadata })
}


pub fn estimate_manual_plan(
    plan_config: ManualPlanConfig<'_>
) -> Result<Plan, LocalPlanError> {

    let ManualPlanConfig {
        rules, target_twist, start_state, map_chunk, obstacles, enable_metadata
    } = plan_config;

    //todo: if use collisions then
    let limits = &rules.limits;

    if limits.brake_aware_ratio.abs() > 1.0 {
        return Err("Brake aware should be in [-1, 1] range".into());
    }

    if !rules.use_collisions {
        return Ok( Plan { twist: target_twist, metadata: None });
    }

    let max_dist2 = f32::max(
        limits.world_goal_tolerance_distance,
        limits.local_goal_tolerance_distance,
    ).powi(2) * limits.brake_aware_ratio;

    let robot_shape = RobotShape::new(
        rules.robot.width,
        rules.robot.length,
        map_chunk.resolution,
    );

    let tick_time =
        Duration::from_millis(limits.simulation_tick_ms).as_secs_f32();
    let simulation_time =
        Duration::from_millis(limits.simulation_time_ms).as_secs_f32();

    let max_ticks_count = (simulation_time / tick_time).ceil() as usize + 1;

    let mut current_coords = start_state.position.coords;
    let mut current_heading = start_state.position.heading_rad;
    let current_velocity = target_twist.translation;
    let current_angular = target_twist.angular;

    let mut states = Vec::<State>::new();

    //build trajectory for manual plan
    for _ in 0..max_ticks_count {
        let walk_dist2 = (current_coords - start_state.position.coords).norm_squared();
        if walk_dist2 > max_dist2 {
            break;
        }
        
        current_coords.x += (current_velocity.x
                    * f32::cos(current_heading)
         + current_velocity.y
                        * f32::sin(current_heading + FRAC_PI_2))
                    * tick_time;

                current_coords.y += (current_velocity.x
                    * f32::sin(current_heading)
                    + current_velocity.y
                        * f32::cos(current_heading + FRAC_PI_2))
                    * tick_time;

                current_heading += current_angular * tick_time;

        states.push(State {
            position: Pose2D {
                coords: current_coords,
                heading_rad: current_heading,
            },
            velocity: current_velocity,
            angular: current_angular,
        });
    }
    
    if states.is_empty() {
        //staying in place
        return Ok(Plan::stop());
    }
    
    let trajectory = Trajectory {
        states,
        target_velocity: target_twist.translation,
        target_angular: target_twist.angular
    };

    let metadata = enable_metadata.then(|| TrajectoryMetadata {
        best_trajectory: None, 
        trajectories: vec![trajectory.clone()]
    });

    let metrics_builder = MetricsBuilder {
        map_chunk: Some(&map_chunk),
        obstacles: &obstacles,
        robot_shape: robot_shape.clone(),
        target: None,
        global_path: None,
        data: None,
    };

    let mut metrics = metrics_builder.with_config(rules.metrics.clone());

    let _cost = evaluate_cost(&trajectory, &mut metrics)
        .map_err(|_| LocalPlanError::from(metadata))?;

    
    let metadata = enable_metadata.then(|| {
        let shapes = trajectory.build_shapes(&robot_shape);
        TrajectoryMetadata {
            best_trajectory: Some((trajectory, shapes)),
            trajectories: vec![]
        }
    });

    Ok( Plan { twist: target_twist, metadata }) 
}

pub fn build_trajectories(
    world: &SimulationWorld,
    config: &PlannerSimulationConfig,
) -> Result<Vec<Trajectory>, LocalPlanError> {
    let limits = &config.limits;

    let velocity_step = (config.robot.max_velocity - config.robot.min_velocity)
        / (limits.velocity_samples_count - 1) as f32;
    let angular_step = (config.robot.max_angular - config.robot.min_angular)
        / (limits.angular_samples_count - 1) as f32;

    let dist2_tolerance = f32::min(
        limits.local_goal_tolerance_distance.powi(2),
        limits.world_goal_tolerance_distance.powi(2),
    );

    if velocity_step <= f32::EPSILON || angular_step <= f32::EPSILON {
        return Err("Zero velocity is detected".into());
    }

    let mut trajectories = Vec::<Trajectory>::new();

    //achieve goal
    let mut target_velocity_x = config.robot.min_velocity;
    while target_velocity_x <= config.robot.max_velocity {
        if target_velocity_x.abs() < f32::EPSILON {
            //rotation at place is forbiddent
            target_velocity_x += velocity_step;
            continue;
        }

        let mut target_angular = config.robot.min_angular;
        while target_angular <= config.robot.max_angular {
            if target_angular.abs() <= f32::EPSILON
                && target_velocity_x.abs() <= f32::EPSILON
            {
                target_angular += angular_step;
                continue;
            }

            let mut current_coords = world.state.position.coords;
            let mut current_heading = world.state.position.heading_rad;

            let current_velocity = Vector2::new(target_velocity_x, 0.0);
            let current_angular = target_angular;

            let tick_time =
                Duration::from_millis(limits.simulation_tick_ms).as_secs_f32();
            let simulation_time =
                Duration::from_millis(limits.simulation_time_ms).as_secs_f32();

            let ticks_count = (simulation_time / tick_time).ceil() as usize + 1;

            let mut states = Vec::<State>::with_capacity(ticks_count + 1);

            for _ in 0..ticks_count {
                let dist2_to_goal =
                    (world.target_point - current_coords).norm_squared();

                if dist2_to_goal <= dist2_tolerance {
                    break;
                }

                current_coords.x += (current_velocity.x
                    * f32::cos(current_heading)
                    + current_velocity.y
                        * f32::sin(current_heading + FRAC_PI_2))
                    * tick_time;

                current_coords.y += (current_velocity.x
                    * f32::sin(current_heading)
                    + current_velocity.y
                        * f32::cos(current_heading + FRAC_PI_2))
                    * tick_time;

                current_heading += current_angular * tick_time;

                // if current_velocity.x < rules.max_velocity {
                //     current_velocity.x = f32::min(
                //         rules.max_velocity,
                //         current_velocity.x + world.acceleration * tick_time,
                //     );
                // } else {
                //     current_velocity.x = f32::max(
                //         rules.min_velocity,
                //         current_velocity.x - world.deceleration * tick_time,
                //     );
                // }
                //
                // if current_angular < rules.max_angular {
                //     current_angular = f32::min(
                //         rules.max_angular,
                //         current_angular + world.angular_acceleration * tick_time,
                //     );
                // } else {
                //     current_angular = f32::max(
                //         rules.min_angular,
                //         current_angular - world.angular_acceleration * tick_time,
                //     );
                // }

                states.push(State {
                    position: Pose2D {
                        coords: current_coords,
                        heading_rad: current_heading,
                    },
                    angular: current_angular,
                    velocity: current_velocity,
                });
            }

            if !states.is_empty() {
                trajectories.push(Trajectory {
                    states,
                    target_velocity: Vector2::new(target_velocity_x, 0.0),
                    target_angular,
                });
            }

            target_angular += angular_step;
        }

        target_velocity_x += velocity_step;
    }

    Ok(trajectories)
}

/// Estimated cost for this trajectory and cache this value
fn evaluate_cost(
    trajectory: &Trajectory,
    metrics: &mut [TrajectoryMetric],
) -> Result<MetricCost, MetricError> {
    fn accept_metric(
        cost: MetricCost,
        trajectory: &Trajectory,
        metric: &mut TrajectoryMetric,
    ) -> Result<MetricCost, MetricError> {
        Ok(cost + metric(trajectory)?)
    }

    let cost =
        metrics
            .iter_mut()
            .try_fold(MetricCost::ZERO, |sum, metric| {
                accept_metric(sum, trajectory, metric)
                    .inspect_err(|cause| log::debug!("Metric failed: {cause}"))
            })?;
    Ok(cost)
}

==> ./planner/dynamic_obstacles.rs <==
use nalgebra::{Point2, Rotation2, Vector2};
use roboq_types::model::{
    debug::DebugData, robot_params::MapObstacles, Metres,
};

use crate::{
    correlative_scan_matching::{
        localized_range_scan::LocalizedRangeScan,
        scan_ring_buffer::ScanRingBuffer,
    },
    model::kd_tree::{points_to_kdtree, KdTree, Point2Kd},
};

pub struct DynamicObstacles {
    kdtree: KdTree,

    points: Vec<Point2Kd>,
}
impl DynamicObstacles {
    pub fn from_buffer(buffer: &ScanRingBuffer) -> Self {
        let mut points: Vec<_> = buffer
            .iter()
            .flat_map(|s| s.points.iter())
            .map(|x| Point2Kd::from(*x))
            .collect();

        let kdtree = KdTree::new(&mut points);

        Self { kdtree, points }
    }

    pub fn with_other_robots(
        buffer: &ScanRingBuffer,
        other_robots: Vec<Point2<f32>>,
    ) -> Self {
        let mut points: Vec<_> = buffer
            .iter()
            .flat_map(|s| s.points.iter())
            .map(|x| Point2Kd::from(*x))
            .collect();

        points.extend(other_robots.into_iter().map(Point2Kd::from));

        let kdtree = KdTree::new(&mut points);

        Self { kdtree, points }
    }

    pub fn generate_obstacle_points(
        obstacles: Vec<MapObstacles>,
    ) -> Vec<Point2<f32>> {
        let mut all_points = Vec::new();
        let step = 0.01;

        for object in obstacles {
            let half_length = *object.length / 2.0;
            let half_width = *object.width / 2.0;

            let rotation = Rotation2::new(object.position.heading_rad);

            let robot_position =
                Point2::new(object.position.coords.x, object.position.coords.y);

            let mut x = -half_length;
            while x <= half_length {
                let local_point = Point2::new(x, half_width);
                let rotated_point = rotation * local_point.coords;
                all_points.push(robot_position + rotated_point);
                x += step;
            }

            let mut y = half_width;
            while y >= -half_width {
                let local_point = Point2::new(half_length, y);
                let rotated_point = rotation * local_point.coords;
                all_points.push(robot_position + rotated_point);
                y -= step;
            }

            let mut x = half_length;
            while x >= -half_length {
                let local_point = Point2::new(x, -half_width);
                let rotated_point = rotation * local_point.coords;
                all_points.push(robot_position + rotated_point);
                x -= step;
            }

            let mut y = -half_width;
            while y <= half_width {
                let local_point = Point2::new(-half_length, y);
                let rotated_point = rotation * local_point.coords;
                all_points.push(robot_position + rotated_point);
                y += step;
            }
        }

        all_points
    }

    pub fn from_scan(scan: &LocalizedRangeScan) -> Self {
        let kdtree = points_to_kdtree(&scan.points);

        Self {
            kdtree,
            points: scan.points.iter().map(|x| Point2Kd::from(*x)).collect(),
        }
    }

    pub fn collides(&self, position: &Point2<f32>, radius: Metres) -> bool {
        let nearest = self.kdtree.nearest_search(&Point2Kd::from(*position));

        let p = position - Vector2::new(nearest.0.x, nearest.0.y);

        Vector2::new(p.x, p.y).norm() < *radius
    }

    pub fn closest(&self, position: &Point2<f32>) -> Point2<f32> {
        self.kdtree.nearest_search(&Point2Kd::from(*position)).0
    }

    pub fn as_point_cloud(&self) -> Vec<Point2<f32>> {
        self.points.iter().map(|p| p.0).collect()
    }
}

impl<'a> From<&'a DynamicObstacles> for DebugData {
    fn from(value: &'a DynamicObstacles) -> Self {
        DebugData::new_obstacles(value.as_point_cloud())
    }
}

==> ./planner/error.rs <==
use thiserror::Error;

#[derive(Debug, Error)]
pub enum LocalPlanError {
    #[error("Failed to build trajectories with invalid config option: {0}")]
    BadConfig(String),
    #[error("Failed to find any trajectory")]
    TrajectoryNotFound,

    #[error("Robot cannot move for too long")]
    StuckDetected,
}

// impl From<TrajectoryMetadata> for LocalPlanError {
//     fn from(value: TrajectoryMetadata) -> Self {
//         Self::TrajectoryNotFound(Some(value))
//     }
// }
//
// impl From<Option<TrajectoryMetadata>> for LocalPlanError {
//     fn from(value: Option<TrajectoryMetadata>) -> Self {
//         Self::TrajectoryNotFound(value)
//     }
// }

impl<'a> From<&'a str> for LocalPlanError {
    fn from(value: &'a str) -> Self {
        Self::BadConfig(value.to_string())
    }
}

==> ./planner/estimation/event.rs <==
use roboq_types::model::{pose::VelocityPose2D, waypoint::WaypointStatus};

pub struct PlannerEvent {
    pub velocity: VelocityPose2D,
    pub status: Option<WaypointStatus>,
}

impl From<WaypointStatus> for PlannerEvent {
    fn from(status: WaypointStatus) -> Self {
        Self {
            velocity: VelocityPose2D::zeros(),
            status: Some(status),
        }
    }
}

impl From<VelocityPose2D> for PlannerEvent {
    fn from(value: VelocityPose2D) -> Self {
        Self {
            velocity: value,
            status: None,
        }
    }
}

==> ./planner/estimation/mod.rs <==
#![allow(unused)]

use std::{ops::DerefMut, time::Instant};

use nalgebra::{Point2, Rotation2, Vector2};
use roboq_types::model::{
    debug::{AlgoKind, ErrorCause},
    localization::RobotState,
    pose::{Pose2D, VelocityPose2D},
    waypoint::WaypointStatus,
    Metres,
};

use crate::{
    debug::{DebugData, DebugSender},
    model::{big_map::MapChunk, motor_action::MotorAction, normalize_angle},
    planner::{
        self, estimate_local_plan, global_planner::find_ground_truth,
        DynamicObstacles, PathState, PlanConfig, RotationState,
        SimulationWorld,
    },
};

#[cfg(all(feature = "gps", feature = "localization"))]
use crate::localization::WorldTransform;

use super::{
    estimate_manual_plan, FollowingData, FollowingState, GlobalPlan,
    GlobalPlanner, ManualPlanConfig, PlannerSimulationConfig, RobotConfig,
    RobotPath, SimulationRobot,
};

mod event;

pub use event::PlannerEvent;
pub trait PlannerSharedData {
    fn estimated_state(&self) -> Option<RobotState>;
    fn build_obstacles(&self) -> Option<DynamicObstacles>;
    fn build_chunk(&self, center: Point2<f32>, radius: Metres) -> MapChunk;
    fn state_mut(&self) -> impl DerefMut<Target = FollowingData>;

    #[cfg(all(feature = "localization", feature = "gps"))]
    fn world_transform(
        &self,
    ) -> impl std::ops::Deref<Target = Option<WorldTransform>>;
}

pub struct MotionPlan;
pub struct DryRunPlan;

pub trait PlanKind {}
impl PlanKind for MotionPlan {}
impl PlanKind for DryRunPlan {}

pub struct PlanEstimation<'a, DATA: PlannerSharedData, KIND: PlanKind> {
    config: &'a PlannerSimulationConfig,

    robot_state: RobotState,

    obstacles: Option<DynamicObstacles>,

    shared_data: &'a DATA,
    #[cfg(feature = "debug")]
    debug_tx: Option<DebugSender>,

    _kind: KIND,
}

impl<'a, DATA: PlannerSharedData> PlanEstimation<'a, DATA, DryRunPlan> {
    pub fn new_dry_run(
        config: &'a PlannerSimulationConfig,
        shared_data: &'a DATA,
    ) -> Option<Self> {
        Some(Self {
            config,
            robot_state: shared_data.estimated_state()?,
            obstacles: None,
            debug_tx: None,
            shared_data,
            _kind: DryRunPlan,
        })
    }

    /// performs dry-run check that given point is
    /// reachable from any point
    /// Return true if point is reacheable
    /// False otherwise
    pub fn check_reachability(&self, coords: Point2<f32>) -> bool {
        let robot_coords = self.robot_state.position.coords;

        if self.build_global_path(&robot_coords, &coords).is_some() {
            return true;
        }

        log::warn!("Failed to check global path by robot position");

        self.log(ErrorCause::RobotPositionGlobalPathFailed.into());

        let reacheable_waypoint = {
            let radius = *self.config.global.path_step * 1.5;

            let chunk =
                self.shared_data.build_chunk(robot_coords, Metres(radius));

            find_ground_truth(&robot_coords, self.config, &chunk)
        };

        let Some(closest_waypoint) = reacheable_waypoint else {
            log::warn!("Closest waypoint is not found. Robot in troubles");
            return false;
        };

        self.build_global_path(&closest_waypoint, &coords).is_some()
    }
}

impl<'a, DATA: PlannerSharedData> PlanEstimation<'a, DATA, MotionPlan> {
    pub fn new_dwa(
        config: &'a PlannerSimulationConfig,
        shared_data: &'a DATA,
    ) -> Option<Self> {
        let obstacles = if config.use_collisions {
            let Some(obstacles) = shared_data.build_obstacles() else {
                log::debug!("Failed to build obstacles");
                return None;
            };

            Some(obstacles)
        } else {
            None
        };

        let robot_state = shared_data.estimated_state()?;

        let plan_data = shared_data.state_mut();

        if !plan_data.state.is_active() {
            return None;
        }

        Some(Self {
            config,
            obstacles,
            robot_state,

            shared_data,
            debug_tx: None,
            _kind: MotionPlan,
        })
    }

    pub fn estimate(&mut self) -> PlannerEvent {
        if let Some(obstacles) = self.obstacles.as_ref() {
            self.log(obstacles.into());
        }

        let mut plan_data = self.shared_data.state_mut();

        match plan_data.state {
            FollowingState::NotInit => panic!("Failed to estimate not init"),
            FollowingState::Path(_) => self.check_plan(&mut plan_data),
            FollowingState::Manual(_) => {
                self.check_manual_control(&mut plan_data)
            }
            FollowingState::Rotation(_) => self.rotate(&mut plan_data),
            FollowingState::WorldPath(_) => {
                self.move_to_world_target(&mut plan_data)
            }
        }
    }

    fn rotate(&mut self, data: &mut FollowingData) -> PlannerEvent {
        let robot_state = self.robot_state;

        let config = self.config;

        let get_next_angular =
            |heading| {
                let raw_angle = heading - robot_state.position.heading_rad;
                let angle = normalize_angle(raw_angle);

                if angle.abs() >= config.limits.target_rotation_tolerance {
                    let angular =
                        angle / config.limits.simulation_tick.as_secs_f32();

                    let angular = angular.signum()
                        * angular.abs().max(config.robot.min_angular);

                    Some(angular.clamp(
                        -config.robot.max_angular,
                        config.robot.max_angular,
                    ))
                } else {
                    None
                }
            };

        let rotation = data.state.rotation_mut().expect("Rotation state");

        match rotation {
            RotationState::Direct {
                heading,
                last_angular,
            } => {
                if let Some(angular) = get_next_angular(*heading) {
                    if last_angular.is_none() {
                        *last_angular = angular.into();
                    }

                    let last_angular = last_angular.expect("set");

                    if last_angular.signum() == angular.signum() {
                        return VelocityPose2D::rotation(angular).into();
                    }
                }

                data.state.reset();

                PlannerEvent {
                    velocity: VelocityPose2D::stop(),
                    status: Some(WaypointStatus::Reached),
                }
            }

            RotationState::Delayed(delayed_start, heading) => {
                if *delayed_start > std::time::SystemTime::now() {
                    return VelocityPose2D::stop().into();
                }

                if let Some(angular) = get_next_angular(*heading) {
                    VelocityPose2D::rotation(angular).into()
                } else {
                    data.state.reset();

                    PlannerEvent {
                        velocity: VelocityPose2D::stop(),
                        status: Some(WaypointStatus::Reached),
                    }
                }
            }
        }
    }

    fn check_manual_control(
        &mut self,
        data: &mut FollowingData,
    ) -> PlannerEvent {
        let config = self.config;
        let action = data.state.manual_action().expect("Manual control state");

        let robot_state = self.robot_state;
        let target_twist = convert_to_velocity(action, &config.robot);

        let dist_radius = f32::max(
            config.limits.world_goal_tolerance_distance,
            config.limits.local_goal_tolerance_distance,
        ) * 1.5; //huge enough

        let chunk = self
            .shared_data
            .build_chunk(robot_state.position.coords, Metres(dist_radius));

        let robot =
            SimulationRobot::from_config(robot_state, config.robot.clone())
                .use_dynamic_collision_distance(
                    config.use_dynamic_collision_distance,
                )
                .build();

        let plan_config = ManualPlanConfig {
            target_twist,
            robot,
            map_chunk: chunk,
            obstacles: &self.obstacles,
            rules: config,
            debug_tx: self.debug_tx.clone(),
        };

        data.state.reset();

        match estimate_manual_plan(plan_config) {
            Ok(twist) => twist.into(),

            Err(cause) => {
                let msg = format!("Manual check failed: {cause}");
                log::warn!("{msg}");

                self.log(ErrorCause::ManualPathCheck.into());

                VelocityPose2D::zeros().into()
            }
        }
    }

    fn check_plan(&mut self, data: &mut FollowingData) -> PlannerEvent {
        let path: &mut RobotPath = data
            .state
            .planner_path_mut()
            .expect("If not manual action then only planner path");

        let robot_state = self.robot_state;
        let config = self.config;

        let time_start = Instant::now();

        match path.state {
            PathState::GlobalPathEstimation => {
                let mut goals = vec![];

                let mut maybe_goal = Option::<Pose2D>::None;
                let mut start_coords = robot_state.position.coords;

                let mut total_distance = 0.0;
                for next_goal in path.global_route.iter() {
                    let Some(plan) = self
                        .build_global_path(&start_coords, &next_goal.coords)
                    else {
                        return WaypointStatus::Unreacheable.into();
                    };

                    match plan {
                        GlobalPlan::Reached => {}

                        GlobalPlan::Path {
                            waypoints,
                            distance,
                        } => {
                            assert!(waypoints.len() >= 2);

                            let local_goals = &waypoints[1..];

                            goals.extend_from_slice(local_goals);

                            maybe_goal = waypoints.last().copied();

                            total_distance += *distance;
                        }
                    }

                    start_coords = next_goal.coords;
                }

                if maybe_goal.is_none() {
                    return WaypointStatus::Reached.into();
                }

                path.init(goals, config);

                if !config.use_initial_rotation {
                    path.start(config);
                }

                WaypointStatus::Target {
                    id: path.global_target_id,
                    distance: total_distance,
                }
                .into()

                // todo: restore logic to find optimized path
                // let goals = if let Some(mut local_goals) =
                //     robot_position_based_path
                // {
                //     if local_goals.is_empty() {
                //         log::info!("Target is reached. Point is removed");
                //
                //         data.state.reset();
                //
                //         return WaypointStatus::Reached.into();
                //     }
                //
                //     assert!(
                //         local_goals.len() >= 2,
                //         "At least two points in local path"
                //     );
                //
                //     local_goals.remove(0); //remove current position
                //
                //     local_goals
                // } else {
                //     log::info!("Failed to build global path by robot position");
                //     self.log(ErrorCause::RobotPositionGlobalPathFailed.into());
                //     // robot should move towards closest ground truth point
                //     let reacheable_waypoint = {
                //         let radius = *self.config.global.path_step * 1.5;
                //
                //         let chunk = self
                //             .shared_data
                //             .build_chunk(robot_coords, Metres(radius));
                //
                //         find_ground_truth(&robot_coords, self.config, &chunk)
                //     };
                //
                //     let Some(waypoint) = reacheable_waypoint else {
                //         return WaypointStatus::Unreacheable.into();
                //     };
                //
                //     let closest_start = data
                //         .waypoints
                //         .find_closest_in_range(
                //             &waypoint,
                //             self.config.global.cache_distance_tolerance,
                //         )
                //         .unwrap_or(data.waypoints.insert(waypoint, None));
                //
                //     let Some(mut local_goals) = self.build_global_path(
                //         &closest_start.coords,
                //         &path.global_target,
                //     ) else {
                //         return WaypointStatus::Unreacheable.into();
                //     };
                //
                //     if local_goals.is_empty() {
                //         assert!(closest_start.id == path.global_target_id);
                //         // closest point is our target
                //         // we should run towards it
                //         vec![closest_start.coords]
                //     } else {
                //         assert!(
                //             local_goals.len() >= 2,
                //             "At least start and end points"
                //         );
                //
                //         let next_target = &local_goals[1];
                //         let current_target = &local_goals[0];
                //
                //         let optimized_target = optimize_around(
                //             current_target,
                //             next_target,
                //             &self.robot_state.position,
                //         );
                //
                //         //if event local_goals[1] is optimized_target
                //         //robot procced movement
                //         local_goals[0] = optimized_target;
                //
                //         local_goals
                //     }
                // };
            }

            PathState::Rotation {
                ref goals,
                ref mut heading,
                ref mut last_angular,
            } => {
                let target_heading = heading.unwrap_or_else(|| {
                    let target = goals.first().expect("Path is not empty");

                    let pos = robot_state.position;

                    let goal_direction =
                        (target.coords - pos.coords).normalize();

                    let robot_direction = Vector2::new(
                        pos.heading_rad.cos(),
                        pos.heading_rad.sin(),
                    )
                    .normalize();

                    let target_heading = if config.robot.align_to_heading {
                        goal_direction.y.atan2(goal_direction.x)
                    } else {
                        let cos = goal_direction.dot(&robot_direction);

                        let raw_angle = cos.acos();
                        // here logic to find minimal rotation (in bounds [0; pi /2])
                        // to align robot towards first goal
                        // that's ensure the path with minimal length for dwa
                        let (sign, angle) =
                            if raw_angle > std::f32::consts::FRAC_PI_2 {
                                (-1.0, raw_angle - std::f32::consts::PI)
                            } else {
                                (1.0, raw_angle)
                            };

                        let rotation = Rotation2::new(angle * sign);
                        let neg_rotation = Rotation2::new(-angle * sign);

                        if (rotation * robot_direction).dot(&goal_direction)
                            > (neg_rotation * robot_direction)
                                .dot(&goal_direction)
                        {
                            pos.heading_rad + angle
                        } else {
                            pos.heading_rad - angle
                        }
                    };

                    log::debug!("New target heading: {target_heading}");

                    normalize_angle(target_heading)
                });

                *heading = Some(target_heading);

                let config = &self.config;

                let get_next_angular = |heading| {
                    let raw_angle = heading - robot_state.position.heading_rad;
                    let angle = normalize_angle(raw_angle);

                    if angle.abs() >= config.limits.target_rotation_tolerance {
                        let angular =
                            angle / config.limits.simulation_tick.as_secs_f32();

                        let angular = angular.signum()
                            * angular.abs().max(config.robot.min_angular);

                        Some(angular.clamp(
                            -config.robot.max_angular,
                            config.robot.max_angular,
                        ))
                    } else {
                        None
                    }
                };

                if let Some(angular) = get_next_angular(target_heading) {
                    if let Some(last_angular) = last_angular {
                        if angular.signum() != last_angular.signum() {
                            path.start(config);
                            return VelocityPose2D::stop().into();
                        }
                    }

                    *last_angular = angular.into();

                    VelocityPose2D::rotation(angular).into()
                } else {
                    path.start(config);
                    VelocityPose2D::zeros().into()
                }
            }

            PathState::Running(ref mut path_data) => {
                let target_pose = path_data.next_goal();
                let robot_pose = robot_state.position;

                let dist_radius = {
                    let dist =
                        (target_pose.coords - robot_pose.coords).norm() * 2.0;

                    f32::max(dist, *config.global.path_step)
                };

                let chunk = self
                    .shared_data
                    .build_chunk(robot_pose.coords, Metres(dist_radius));

                let global_path = path_data.global_path();

                let mut planner = GlobalPlanner::new_shortest_path(
                    robot_state,
                    target_pose.coords,
                    config,
                    &chunk,
                );

                if let Some(obstacles) = self.obstacles.as_ref() {
                    planner.set_obstacles(obstacles);
                }

                if let Some(debugger) = self.debug_tx.clone() {
                    planner.set_debug(debugger);
                }

                let check_status = planner.estimate_distance();

                if check_status.is_err() {
                    //that's possible the goal is recheable
                    //but require to rebuild global path
                    path.reset();

                    if let Some(ref debugger) = self.debug_tx {
                        let _ = debugger.try_send(
                            ErrorCause::RunningPathCheckFailed.into(),
                        );
                    }

                    return WaypointStatus::Unreacheable.into();
                }

                let distance_to_goal = check_status.unwrap();

                let robot = SimulationRobot::from_config(
                    robot_state,
                    config.robot.clone(),
                );

                let world = SimulationWorld {
                    map_chunk: chunk,
                    robot,
                    tracker: &mut path_data.tracker,
                    target_pose,
                    global_path: &global_path,
                    obstacles: self.obstacles.as_ref(),
                };

                let rules = config.clone();

                let plan_config = PlanConfig {
                    world,
                    rules,
                    metrics_data: &mut path_data.metrics,
                    debug_tx: self.debug_tx.clone(),
                };

                let event = match estimate_local_plan(plan_config) {
                    Ok(event) => {
                        use planner::LocalPlanEvent;

                        let mut status = WaypointStatus::Target {
                            id: path.global_target_id,
                            distance: *distance_to_goal,
                        };

                        match event {
                            LocalPlanEvent::Velocity(velocity) => {
                                PlannerEvent {
                                    velocity,
                                    status: status.into(),
                                }
                            }

                            LocalPlanEvent::LocalGoalReached => {
                                let has_next_goal = path_data.move_local_goal();

                                if !has_next_goal {
                                    if let Some(rotation) = path.target_heading
                                    {
                                        data.state = rotation.into();
                                    } else {
                                        data.state.reset();
                                        status = WaypointStatus::Reached;
                                    }
                                }

                                let local_velocity =
                                    robot_state.velocity.into_local(
                                        robot_state.position.heading_rad,
                                    );

                                //proceed movement with same velocity
                                PlannerEvent {
                                    velocity: local_velocity,
                                    status: status.into(),
                                }
                            }

                            LocalPlanEvent::GlobalGoalReached => {
                                let has_next_goal = path_data.move_local_goal();

                                if !has_next_goal {
                                    if let Some(rotation) = path.target_heading
                                    {
                                        data.state = rotation.into();
                                    } else {
                                        data.state.reset();
                                        status = WaypointStatus::Reached;
                                    }
                                }

                                PlannerEvent {
                                    velocity: VelocityPose2D::stop(),
                                    status: status.into(),
                                }
                            }
                        }
                    }

                    Err(cause) => {
                        match cause {
                            planner::LocalPlanError::BadConfig(_) => {
                                let msg = format!("{cause}");
                                log::error!("{msg}");
                                self.log(ErrorCause::BadConfig.into());
                            }

                            planner::LocalPlanError::TrajectoryNotFound => {
                                path.reset(); //rebuild global path

                                self.log(
                                    ErrorCause::AllTrajectoriesAreInvalid
                                        .into(),
                                );
                            }

                            planner::LocalPlanError::StuckDetected => {
                                path.reset();

                                self.log(ErrorCause::StuckDetected.into());
                            }
                        }

                        WaypointStatus::Unreacheable.into()
                    }
                };

                let elapsed = time_start.elapsed();

                self.log(DebugData::new_algo(AlgoKind::LocalPlanner, elapsed));

                event
            }
        }
    }

    fn move_to_world_target(
        &mut self,
        data: &mut FollowingData,
    ) -> PlannerEvent {
        let _path = data
            .state
            .world_path_mut()
            .expect("World path for world target");

        // let optimize = |_p| {};
        //
        // let transform_lock = self.shared_data.world_transform();
        //
        // let Some(_transform) = transform_lock.deref() else {
        //     return VelocityPose2D::stop().into();
        // };
        //
        // if path.params.is_none() {
        //     optimize(path);
        // }

        todo!()
    }
}

impl<DATA: PlannerSharedData, KIND: PlanKind> PlanEstimation<'_, DATA, KIND> {
    #[cfg(feature = "debug")]
    pub fn set_debug(&mut self, debug_tx: DebugSender) -> &mut Self {
        self.debug_tx = Some(debug_tx);

        self
    }

    fn build_global_path(
        &self,
        start: &Point2<f32>,
        end: &Point2<f32>,
    ) -> Option<GlobalPlan> {
        let time_start = Instant::now();

        let dist_radius = {
            let dist = (end - start).norm() * 2.0;
            f32::max(dist, *self.config.global.path_step)
        };

        let chunk = self.shared_data.build_chunk(*start, Metres(dist_radius));

        let mut planner =
            GlobalPlanner::new_global_plan(*start, *end, self.config, &chunk);

        if let Some(obstacles) = self.obstacles.as_ref() {
            planner.set_obstacles(obstacles);
        }

        if let Some(debugger) = self.debug_tx.as_ref() {
            planner.set_debug(debugger.clone());
        }

        let path = planner.estimate();

        let elapsed = time_start.elapsed();

        self.log(DebugData::new_algo(AlgoKind::GlobalPlanner, elapsed));

        path
    }

    fn log(&self, data: DebugData) {
        if let Some(ref debug) = self.debug_tx {
            let _ = debug.try_send(data);
        }
    }
}

pub fn convert_to_motor_action(
    velocity: VelocityPose2D,
    config: &RobotConfig,
) -> MotorAction {
    if velocity.is_stop() {
        return MotorAction::stop();
    }

    let config = &config.differential;
    let wheel_distance = config.wheel_distance * config.distance_ratio;
    let radius = config.wheel_radius * config.radius_ratio;

    let (vl, vr) = {
        let vl = (velocity.translation.x
            - velocity.angular * wheel_distance / 2.0)
            / radius;
        let vr = (velocity.translation.x
            + velocity.angular * wheel_distance / 2.0)
            / radius;

        (vl, vr)
    };

    let action = MotorAction {
        left_speed: vl.into(),
        right_speed: vr.into(),
    };

    log::debug!("IN: {:?}. OUT: {:?}", velocity, action);

    action
}

pub fn convert_to_velocity(
    action: MotorAction,
    config: &RobotConfig,
) -> VelocityPose2D {
    let config = &config.differential;
    let wheel_distance = config.wheel_distance * config.distance_ratio;
    let radius = config.wheel_radius * config.radius_ratio;

    let vl = *action.left_speed;
    let vr = *action.right_speed;

    let angular = radius * (vr - vl) / (wheel_distance);
    let linear = vl * radius + angular * wheel_distance / 2.0;

    let another_linear = vr * radius - angular * wheel_distance / 2.0;

    debug_assert_eq!(another_linear, linear);

    VelocityPose2D {
        translation: Vector2::new(linear, 0.0),
        angular,
    }
}

/// Choose the the best point (start or end)
/// to move according current robot position.
fn optimize_around(
    start: &Point2<f32>,
    _end: &Point2<f32>,
    _robot_position: &Pose2D,
) -> Point2<f32> {
    *start
}

==> ./planner/global_planner/mod.rs <==
mod plan;

use std::marker::PhantomData;

use bresenham::Bresenham;
use nalgebra::{Point2, Vector2};
use ordered_float::OrderedFloat;
use pathfinding::directed::astar::astar;
use roboq_types::model::{localization::RobotState, pose::Pose2D, Metres};
use rustc_hash::FxHashMap;
use thiserror::Error;

use crate::{
    debug::{DebugData, DebugSender},
    model::{
        big_map::{map_cell::MapCell, Map},
        occupancy_grid::{self, OCCUPIED_THRESHOLD},
    },
};

use super::{DynamicObstacles, PlannerSimulationConfig};

#[derive(Debug, Clone, Error)]
pub enum CheckError {
    #[error("Path exists but is not direct")]
    FarGoal,
    #[error("Failed to prove that point is recheable. Probably, use global planner to estimate")]
    Unrecheable,
}
pub use plan::GlobalPlan;

pub struct GlobalPath;
pub struct ShortestPath;

pub trait PathKind {}
impl PathKind for GlobalPlan {}
impl PathKind for ShortestPath {}

pub struct GlobalPlanner<'a, P: PathKind, M: Map> {
    map: &'a M,
    config: &'a PlannerSimulationConfig,
    obstacles: Option<&'a DynamicObstacles>,

    aware_distance: Metres,
    start: Point2<f32>,
    end: Point2<f32>,

    _marker: PhantomData<P>,

    #[cfg(feature = "debug")]
    debug: Option<DebugSender>,
}

impl<'a, P, M> GlobalPlanner<'a, P, M>
where
    P: PathKind,
    M: Map,
{
    pub fn new(
        start: Point2<f32>,
        end: Point2<f32>,
        config: &'a PlannerSimulationConfig,
        collision_distance: Metres,
        map: &'a M,
    ) -> Self {
        Self {
            config,
            map,
            aware_distance: collision_distance,

            start,
            end,

            _marker: Default::default(),
            obstacles: None,
            #[cfg(feature = "debug")]
            debug: None,
        }
    }

    #[cfg(feature = "debug")]
    pub fn set_debug(&mut self, debug: DebugSender) {
        self.debug = debug.into();
    }

    pub fn set_obstacles(&mut self, obstacles: &'a DynamicObstacles) {
        self.obstacles = obstacles.into();
    }

    #[allow(unused)]
    fn log<DATA: Into<DebugData>>(&self, data: DATA) {
        #[cfg(feature = "debug")]
        if let Some(debugger) = self.debug.as_ref() {
            let _ = debugger.try_send(data.into());
        }
    }

    fn estimate_path(&self, is_check: bool) -> Option<GlobalPlan> {
        let config = self.config;
        let map = self.map;
        let aware_distance = self.aware_distance;
        let start = &self.start;
        let end = &self.end;
        let dynamic_obstacles = self.obstacles;

        let robot_radius = {
            let width = *config.robot.width + *aware_distance;
            let length = *config.robot.length + *aware_distance;

            let radius = Vector2::new(width, length).scale(0.5);

            radius.norm()
        };

        let wall_size = if is_check {
            (*aware_distance
                + f32::max(*config.robot.width, *config.robot.length) / 2.0)
                .into()
        } else {
            (*aware_distance
                + f32::max(*config.robot.width, *config.robot.length))
            .into()
        };

        let path_step2 = config.global.path_step.powi(2);

        // This is a horrible implementation, but let's roll with it
        let resolution = map.grid_resolution();
        // Cache for expanded walls
        let mut big_map_cache: FxHashMap<Point2<i32>, Option<MapCell>> =
            FxHashMap::default();
        let start = resolution.point_to_pixels(start);
        let end = resolution.point_to_pixels(end);

        //cached way to access CostCell at given world coords

        let mut index_grid = move |position: Point2<f32>| {
            if matches!(
                dynamic_obstacles, Some(obstacles)
                if obstacles.collides(&position, robot_radius.into())
            ) {
                return occupancy_grid::OCCUPIED_STATUS;
            }

            let cell_pos = map.get_cell_int_pos(&position);
            let cache = big_map_cache.get(&cell_pos);
            if let Some(cache) = cache {
                if let Some(cache) = cache {
                    *cache.index_grid(&position)
                } else {
                    occupancy_grid::UNKNOWN_STATUS
                }
            } else {
                let cell_lock = map.get_cell_at(&position);
                if let Some(cell_lock) = cell_lock {
                    let cell = cell_lock.read().unwrap();

                    let new_grid =
                        cell.occupancy_grid.grow_occupied_cells(wall_size);

                    let cache_cell = MapCell {
                        top_left: cell.top_left,
                        points: Vec::new(),
                        occupancy_grid: new_grid,
                    };
                    let result = *cache_cell.index_grid(&position);
                    big_map_cache.insert(cell_pos, Some(cache_cell));
                    result
                } else {
                    big_map_cache.insert(cell_pos, None);
                    0
                }
            }
        };

        let (mut path, distance) = astar(
            &start,
            |start| {
                let mut neighbours = Vec::new();
                let mut process_point = |point: Point2<i32>, dist: f32| {
                    let position = resolution.point_to_metres(&point);
                    let is_free = index_grid(position)
                        > occupancy_grid::OCCUPIED_THRESHOLD;
                    if is_free {
                        neighbours.push((point, OrderedFloat(dist)));
                    }
                };

                let left = start - Vector2::new(1, 0);
                process_point(left, 1.0);
                let right = start + Vector2::new(1, 0);
                process_point(right, 1.0);
                let up = start - Vector2::new(0, 1);
                process_point(up, 1.0);
                let down = start + Vector2::new(0, 1);
                process_point(down, 1.0);
                let top_left = start - Vector2::new(1, 1);
                process_point(top_left, 2.0f32.sqrt());
                let top_right = start - Vector2::new(0, 1) + Vector2::new(1, 0);
                process_point(top_right, 2.0f32.sqrt());
                let bottom_left =
                    start + Vector2::new(0, 1) - Vector2::new(1, 0);
                process_point(bottom_left, 2.0f32.sqrt());
                let bottom_right = start + Vector2::new(1, 1);
                process_point(bottom_right, 2.0f32.sqrt());

                neighbours
            },
            |point| {
                let f = (Point2::new(point.x as f32, point.y as f32)
                    - Point2::new(end.x as f32, end.y as f32))
                .norm();
                OrderedFloat(f)
            },
            |point| *point == end,
        )?;

        if path.is_empty() {
            return None;
        }

        loop {
            let mut current_index = 0;
            let mut target = path.len() - 1;
            let mut progress_done = false;

            loop {
                if current_index == (path.len() - 1) {
                    break;
                }

                if current_index == target || current_index == target - 1 {
                    current_index += 1;
                    target = path.len() - 1;
                    continue;
                }

                let start_point = path[current_index];
                let next_point = path[target];

                let mut is_clear = true;
                for (x, y) in Bresenham::new(
                    (start_point.x as isize, start_point.y as isize),
                    (next_point.x as isize, next_point.y as isize),
                ) {
                    if index_grid(
                        resolution
                            .point_to_metres(&Point2::new(x as i32, y as i32)),
                    ) <= OCCUPIED_THRESHOLD
                    {
                        is_clear = false;
                        break;
                    }
                }

                if !is_clear {
                    target = current_index + (target - current_index) / 2;
                    continue;
                }

                let mut filter_i = 0;
                path.retain(|_| {
                    let should_delete =
                        (current_index + 1..target).contains(&filter_i);
                    filter_i += 1;
                    !should_delete
                });

                current_index = 0;
                target = 0;
                progress_done = true;
            }

            if !progress_done {
                break;
            }
        }

        if path.len() == 1 {
            //already in place
            return GlobalPlan::Reached.into();
        }

        let mut path_points = Vec::with_capacity(path.len());

        for i in 0..(path.len() - 1) {
            let start_point = resolution.point_to_metres(&path[i]);
            let next_point = resolution.point_to_metres(&path[i + 1]);

            let dist2 = {
                let diff = start_point - next_point;
                diff.norm_squared()
            };

            path_points.push(start_point);

            if dist2 > path_step2 {
                let points_count =
                    f32::sqrt(dist2 / path_step2).ceil() as usize;
                let dx = (next_point.x - start_point.x) / points_count as f32;
                let dy = (next_point.y - start_point.y) / points_count as f32;
                let mut point = start_point;
                for _ in 0..points_count {
                    point += Vector2::new(dx, dy);
                    path_points.push(point);
                }
            }

            path_points.push(next_point);
        }

        drop(path);

        let mut waypoints = vec![];

        for i in 0..(path_points.len() - 1) {
            let current_coords = path_points[i];
            let next_coords = path_points[i + 1];

            let heading = f32::atan2(
                next_coords.y - current_coords.y,
                next_coords.x - current_coords.x,
            );

            waypoints.push(Pose2D {
                coords: current_coords,
                heading_rad: heading,
            });

            if i == path_points.len() - 2 {
                //preserve same heading as last point
                //as we know, that each points' pair
                //is connected with each via line

                waypoints.push(Pose2D {
                    coords: next_coords,
                    heading_rad: heading,
                });
            }
        }

        GlobalPlan::Path {
            waypoints,
            distance: (*distance / 100.0).into(),
        }
        .into()
    }
}

impl<'a, M: Map> GlobalPlanner<'a, GlobalPlan, M> {
    pub fn new_global_plan(
        start: Point2<f32>,
        end: Point2<f32>,
        config: &'a PlannerSimulationConfig,
        map: &'a M,
    ) -> Self {
        Self::new(start, end, config, config.collision_distance, map)
    }

    pub fn estimate(self) -> Option<GlobalPlan> {
        self.estimate_path(false)
    }
}

impl<'a, M: Map> GlobalPlanner<'a, ShortestPath, M> {
    pub fn new_shortest_path(
        state: RobotState,
        end: Point2<f32>,
        config: &'a PlannerSimulationConfig,
        map: &'a M,
    ) -> Self {
        let collision_distance = config.collision_distance;

        Self::new(state.position.coords, end, config, collision_distance, map)
    }

    /// Check that we don't need to rebuild trajectory
    /// as current trajectory is the best available
    pub fn estimate_distance(self) -> Result<Metres, CheckError> {
        let Some(plan) = self.estimate_path(true) else {
            return Err(CheckError::Unrecheable);
        };

        match plan {
            GlobalPlan::Reached => Ok(0.0.into()),

            GlobalPlan::Path {
                waypoints,
                distance,
            } => {
                assert!(waypoints.len() >= 2);
                let max_distance = *self.config.global.path_step
                    + *self.config.global.path_step_tolerance;

                if *distance > max_distance {
                    Err(CheckError::FarGoal)
                } else {
                    Ok(distance)
                }
            }
        }
    }
}

fn cache_builder<M: Map>(
    map: &M,
    wall_size: Metres,
) -> impl FnMut(&Point2<f32>) -> u8 + '_ {
    // Cache for expanded walls
    let mut big_map_cache: FxHashMap<Point2<i32>, Option<MapCell>> =
        FxHashMap::default();

    move |position: &Point2<f32>| {
        let cell_pos = map.get_cell_int_pos(position);
        let cache = big_map_cache.get(&cell_pos);
        if let Some(cache) = cache {
            if let Some(cache) = cache {
                *cache.index_grid(position)
            } else {
                occupancy_grid::UNKNOWN_STATUS
            }
        } else {
            let cell_lock = map.get_cell_at(position);
            if let Some(cell_lock) = cell_lock {
                let cell = cell_lock.read().unwrap();

                let new_grid =
                    cell.occupancy_grid.grow_occupied_cells(wall_size);

                let cache_cell = MapCell {
                    top_left: cell.top_left,
                    points: Vec::new(),
                    occupancy_grid: new_grid,
                };
                let result = *cache_cell.index_grid(position);
                big_map_cache.insert(cell_pos, Some(cache_cell));
                result
            } else {
                big_map_cache.insert(cell_pos, None);
                occupancy_grid::OCCUPIED_STATUS
            }
        }
    }
}

pub fn find_ground_truth<M: Map>(
    center: &Point2<f32>,
    config: &PlannerSimulationConfig,
    map: &M,
) -> Option<Point2<f32>> {
    let aware_distance = config.collision_distance;

    let small_wall_size = Metres(
        *aware_distance * config.global.collision_check_scale
            + f32::max(*config.robot.width, *config.robot.length) / 2.0,
    );

    let big_wall_size = Metres(
        *aware_distance + f32::max(*config.robot.width, *config.robot.length),
    );

    let resolution = map.grid_resolution();

    let mut running_path_cost = cache_builder(map, small_wall_size);
    let mut ground_truth_path_cost = cache_builder(map, big_wall_size);

    let start = resolution.point_to_pixels(center);

    let (path, _distance) = astar(
        &start,
        |start| {
            let mut neighbours = Vec::new();
            let mut process_point = |point: Point2<i32>, dist: f32| {
                let position = resolution.point_to_metres(&point);
                let is_free = running_path_cost(&position)
                    > occupancy_grid::OCCUPIED_THRESHOLD;

                if is_free {
                    neighbours.push((point, OrderedFloat(dist)));
                }
            };

            let left = start - Vector2::new(1, 0);
            process_point(left, 1.0);
            let right = start + Vector2::new(1, 0);
            process_point(right, 1.0);
            let up = start - Vector2::new(0, 1);
            process_point(up, 1.0);
            let down = start + Vector2::new(0, 1);
            process_point(down, 1.0);
            let top_left = start - Vector2::new(1, 1);
            process_point(top_left, 2.0f32.sqrt());
            let top_right = start - Vector2::new(0, 1) + Vector2::new(1, 0);
            process_point(top_right, 2.0f32.sqrt());
            let bottom_left = start + Vector2::new(0, 1) - Vector2::new(1, 0);
            process_point(bottom_left, 2.0f32.sqrt());
            let bottom_right = start + Vector2::new(1, 1);
            process_point(bottom_right, 2.0f32.sqrt());

            neighbours
        },
        |_point| {
            // let position = resolution.point_to_metres(point);
            // let cost = running_path_cost(&position);
            //
            // if cost == occupancy_grid::FREE_STATUS {
            // } else {
            //     OrderedFloat(f32::MAX)
            // }
            OrderedFloat(0.0)

            // let f = (Point2::new(point.x as f32, point.y as f32)
            //     - Point2::new(end.x as f32, end.y as f32))
            // .norm();
            // OrderedFloat(f)
        },
        |point| {
            let position = resolution.point_to_metres(point);
            let cost = ground_truth_path_cost(&position);

            cost == occupancy_grid::FREE_STATUS
        },
    )?;

    let path_step2 = config.global.path_step.powi(2);

    if path.is_empty() {
        log::warn!("Failed to find ground truth");
    }

    path.last()
        .map(|p| resolution.point_to_metres(p))
        .filter(|p| {
            (*center - Point2::new(p.x, p.y)).norm_squared() <= path_step2
        })
}

==> ./planner/global_planner/plan.rs <==
use roboq_types::model::{pose::Pose2D, Metres};

pub enum GlobalPlan {
    //the target is already reached
    Reached,
    Path {
        //no empty array of targets
        waypoints: Vec<Pose2D>,
        distance: Metres,
    },
}

==> ./planner/metrics/builder.rs <==
use std::{collections::HashMap, f32};

use crate::{
    model::{big_map::BoxedMapChunk, normalize_angle},
    planner::{
        collision::{has_dynamic_collision, has_static_collision},
        distance_grid::DistanceGrid,
        DynamicObstacles, PlannerSimulationConfig, SimulationRobot,
    },
};

use super::{
    oscillation, MetricCost, MetricError, MetricKind, MetricsData,
    MetricsParams, TrajectoryMetric,
};

use nalgebra::Point2;
use roboq_types::model::pose::Pose2D;

pub struct MetricsBuilder<'a> {
    pub map_chunk: Option<&'a BoxedMapChunk>,
    pub global_path: Option<&'a [Point2<f32>]>,
    pub obstacles: Option<&'a DynamicObstacles>,
    pub target: Option<Pose2D>,
    pub data: Option<&'a mut MetricsData>,

    pub robot: &'a SimulationRobot,
    pub planner_config: &'a PlannerSimulationConfig,
}

impl<'a> MetricsBuilder<'a> {
    pub fn build(
        &'a mut self,
        config: MetricsParams,
    ) -> (Vec<TrajectoryMetric<'a>>, HashMap<MetricKind, f32>) {
        let mut metrics = Vec::with_capacity(3);
        let mut weights = HashMap::new();

        if let Some(((target, map_chunk), data)) =
            self.target.zip(self.map_chunk).zip(self.data.as_mut())
        {
            if config.next_goal.is_some() && data.goal_grid.is_none() {
                let grid =
                    DistanceGrid::with_local_goal(map_chunk, target.coords)
                        .expect("Failed to build goal distance grid");

                data.goal_grid = Some(grid);
            }

            if let Some(path) = self.global_path {
                if config.global_path.is_some() && data.path_grid.is_none() {
                    let grid = DistanceGrid::with_global_path(map_chunk, path)
                        .expect("Failed to build path distance grid");

                    data.path_grid = Some(grid);
                }
            }

            if config.collision_avoidance.is_some() {
                let grid = DistanceGrid::collision_map(map_chunk)
                    .expect("Failed to build path distance grid");

                data.collision_distance_grid = Some(grid);
            }
        }

        //that's very heavy, in the sense of computing, metrics
        if let Some((obstacles, map_chunk)) = self.obstacles.zip(self.map_chunk)
        {
            metrics.push(self.collision_metrics(obstacles, map_chunk));
            weights.insert(MetricKind::Collision, 1.0);
        }

        if let Some(ref data) = self.data {
            weights.insert(MetricKind::Oscilation, config.oscillation);
            metrics
                .push(oscillation::metric(&data.osc_data, self.planner_config));
        }

        if let Some((goal_grid, w)) = self
            .data
            .as_ref()
            .and_then(|d| d.goal_grid.as_ref())
            .zip(config.next_goal)
        {
            metrics.push(
                self.distance_map_metric(goal_grid, MetricKind::NextGoal),
            );

            weights.insert(MetricKind::NextGoal, w);
        }

        if let Some((path_grid, w)) = self
            .data
            .as_ref()
            .and_then(|d| d.path_grid.as_ref())
            .zip(config.global_path)
        {
            metrics.push(
                self.distance_map_metric(path_grid, MetricKind::GlobalPath),
            );

            weights.insert(MetricKind::GlobalPath, w);
        }

        if let Some((map, w)) = self
            .data
            .as_ref()
            .and_then(|d| d.collision_distance_grid.as_ref())
            .zip(config.collision_avoidance)
        {
            metrics.push(self.collision_map_metric(map, self.obstacles));

            weights.insert(MetricKind::CollisionDistance, w);
        }

        if let Some(w) = config.twirling_ratio {
            metrics.push(self.twirling_metric());
            weights.insert(MetricKind::Twirling, w);
        }

        if let Some(w) = config.forward_ratio {
            metrics.push(self.forward_movement_metric());

            weights.insert(MetricKind::Forward, w);
        }

        if let Some((w, target)) = config.shortest_path.zip(self.target) {
            metrics.push(self.shortest_path_metric(target.coords));
            weights.insert(MetricKind::ShortestPath, w);
        }

        if let Some((pose, w)) =
            self.target.as_ref().zip(config.target_alignment)
        {
            metrics.push(self.target_alignment(pose.heading_rad));
            weights.insert(MetricKind::TargetAlignment, w);
        }

        (metrics, weights)
    }

    //prefere trajectories which target
    //state is aligned to desirable rotation
    pub fn target_alignment(&self, target_heading: f32) -> TrajectoryMetric {
        Box::new(move |trajectory| {
            let rotation = normalize_angle(
                trajectory.finish_state().position.heading_rad - target_heading,
            );

            let cost = rotation.abs() / f32::consts::FRAC_PI_2;

            Ok((MetricKind::TargetAlignment, MetricCost::new(cost)))
        })
    }

    pub fn forward_movement_metric(&self) -> TrajectoryMetric {
        Box::new(move |trajectory| {
            let cost = if trajectory.target_velocity.x > 0.0 {
                0.0
            } else {
                1.0
            };

            Ok((MetricKind::Forward, MetricCost::new(cost)))
        })
    }

    pub fn shortest_path_metric(&self, goal: Point2<f32>) -> TrajectoryMetric {
        Box::new(move |trajectory| {
            let dist2 = (goal - trajectory.finish_state().position.coords)
                .norm_squared();

            Ok((MetricKind::ShortestPath, MetricCost::new(dist2)))
        })
    }

    pub fn twirling_metric(&self) -> TrajectoryMetric {
        Box::new(move |trajectory| {
            let angular = trajectory.target_angular;
            let cost = angular.abs();

            Ok((MetricKind::Twirling, MetricCost::new(cost)))
        })
    }

    fn collision_map_metric(
        &'a self,
        map: &'a DistanceGrid,
        maybe_obstacles: Option<&'a DynamicObstacles>,
    ) -> TrajectoryMetric<'a> {
        Box::new(move |trajectory| {
            let state = trajectory.finish_state();
            let mut min_dist = f32::MAX;
            let coords = state.position.coords;
            let dist_cost = map.index_distance(&coords);

            if dist_cost.is_reacheable() {
                let dist = map.resolution.to_metres(dist_cost.as_f32());
                log::trace!("Static dist = {dist}");
                min_dist = f32::min(min_dist, dist);
            }

            if let Some(obstacles) = maybe_obstacles {
                let obstacle = obstacles.closest(&coords);
                let dist_to_dynamic_obstacle = (obstacle - coords).norm();

                log::trace!("Dyn dist = {dist_to_dynamic_obstacle}");

                min_dist = f32::min(min_dist, dist_to_dynamic_obstacle);
            }

            Ok((
                MetricKind::CollisionDistance,
                MetricCost::new(1.0 / min_dist),
            ))
        })
    }

    fn distance_map_metric(
        &'a self,
        distance_grid: &'a DistanceGrid,
        kind: MetricKind,
    ) -> TrajectoryMetric<'a> {
        Box::new(move |trajectory| {
            let states = &trajectory.states;
            let mut distance_cost = 0.0;
            // let mut best_cost = Option::<MetricCost>::None;
            log::trace!("The points' counts is {}", states.len());
            for state in states.iter() {
                let _yaw = state.angular; //consider to introduce target angle
                let world_point = state.position.coords;

                let distance = distance_grid.index_distance(&world_point);
                if distance.is_unreacheable() {
                    log::debug!("Distance is unreacheable");
                    return Err(MetricError::Unreacheable);
                }
                distance_cost += distance.as_f32();
            }

            Ok((kind, MetricCost::new(distance_cost)))
        })
    }

    pub fn collision_metrics(
        &self,
        obstacles: &'a DynamicObstacles,
        map_chunk: &'a BoxedMapChunk,
    ) -> TrajectoryMetric {
        let robot = self.robot;
        let config = self.planner_config;

        Box::new(move |trajectory| {
            for state in trajectory.states.iter() {
                let state_shape = robot.build_shape(
                    map_chunk.resolution,
                    config.collision_distance,
                    &(*state).into(),
                );

                if has_dynamic_collision(&state_shape, obstacles)
                    || has_static_collision(&state_shape, map_chunk)
                {
                    //collisions are not acceptable
                    return Err(MetricError::Unreacheable);
                }
            }

            Ok((MetricKind::Collision, MetricCost::ZERO))
        })
    }
}

==> ./planner/metrics/config.rs <==
pub use roboq_types::model::plan::MetricsParams;


==> ./planner/metrics/cost.rs <==
#![allow(unused)]

use std::ops::{Add, Div, Mul, Sub};

use ordered_float::OrderedFloat;
use roboq_macro::declare_constants;

#[derive(Debug, PartialEq, PartialOrd, Clone, Copy, Hash, Eq, Ord)]
pub enum MetricKind {
    Collision,

    GlobalPath,
    NextGoal,
    //estimate distance to collision
    CollisionDistance,

    ShortestPath,
    Twirling,
    Forward,

    Oscilation,

    TargetAlignment,
}

#[derive(Debug, PartialEq, PartialOrd, Clone, Copy, Eq, Ord)]
#[repr(transparent)]
pub struct MetricCost(pub OrderedFloat<f32>);

impl MetricCost {
    pub fn new(value: f32) -> Self {
        Self(value.into())
    }
}

impl Add for MetricCost {
    type Output = MetricCost;

    fn add(self, rhs: Self) -> Self::Output {
        Self(self.0 + rhs.0)
    }
}

impl Sub for MetricCost {
    type Output = MetricCost;

    fn sub(self, rhs: Self) -> Self::Output {
        Self(self.0 - rhs.0)
    }
}

impl Div for MetricCost {
    type Output = MetricCost;

    fn div(self, rhs: Self) -> Self::Output {
        Self(self.0 / rhs.0)
    }
}

impl Mul<f32> for MetricCost {
    type Output = MetricCost;

    fn mul(self, rhs: f32) -> Self::Output {
        Self::new(rhs * *self.0)
    }
}

impl std::ops::Deref for MetricCost {
    type Target = f32;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl MetricCost {
    declare_constants! {
        pub MetricCost,
        ZERO = MetricCost(OrderedFloat(0.0));
    }
    pub fn min(&self, other: &MetricCost) -> MetricCost {
        Self(self.0.min(other.0))
    }
}

==> ./planner/metrics/error.rs <==
use thiserror::Error;

use crate::model::occupancy_grid::MappingError;

#[derive(Debug, Error)]
pub enum MetricError {
    #[error("Unknown runtime error: {0}")]
    Unknown(String),
    #[error("Chosen trajectory leads to unreacheable goal")]
    Unreacheable,
}

impl From<MappingError> for MetricError {
    fn from(_value: MappingError) -> Self {
        Self::Unknown("GridMappingError".to_string())
    }
}

==> ./planner/metrics/mod.rs <==
mod builder;
mod config;
mod cost;
mod error;
mod oscillation;
mod shared_data;

pub use builder::*;
pub use config::*;
pub use cost::*;
pub use error::*;
pub use shared_data::*;

use super::Trajectory;
/// Each trajectory metric can assume all items are in order
/// that the first item is the beginning of the robot's path
/// and the last item is the end of the robot's path (the goal state itself)
pub type TrajectoryMetric<'a> = Box<
    dyn FnMut(&Trajectory) -> Result<(MetricKind, MetricCost), MetricError>
        + 'a,
>;

==> ./planner/metrics/oscillation.rs <==
use nalgebra::Vector2;
use roboq_macro::declare_constants;
use roboq_types::model::{localization::RobotState, pose::VelocityPose2D};
use serde::{Deserialize, Serialize};

use crate::planner::{
    metrics::MetricKind, PlannerSimulationConfig, Trajectory,
};

use super::{MetricCost, MetricError, MetricsParams, TrajectoryMetric};

declare_constants! {
    pub u16,
    UPDATED = 0b001;
    ONLY = 0b100;
    FIRST = 0b001;
    SECOND = 0b010;
    FIRST_ONLY = FIRST | ONLY;
    SECOND_ONLY = SECOND | ONLY;
}

bitflags::bitflags! {
    #[derive(Serialize, Deserialize, Default, Debug, PartialEq, Clone, Copy)] //all bits are zeroes
    #[serde(transparent)]
    pub struct OscilationFlag : u16 {
        const UPDATED = UPDATED;

        const POS_ROTATION = FIRST << 3;
        const POS_ROTATION_ONLY = FIRST_ONLY << 3;
        const NEG_ROTATION = SECOND << 3;
        const NEG_ROTATION_ONLY = SECOND_ONLY << 3;

        const FORWARD_X = FIRST << 6;
        const FORWARD_X_ONLY = FIRST_ONLY << 6;
        const BACKWARD_X = SECOND << 6;
        const BACKWARD_X_ONLY = SECOND_ONLY << 6;

        const FORWARD_Y = FIRST << 9;
        const FORWARD_Y_ONLY = FIRST_ONLY << 9;
        const BACKWARD_Y = SECOND << 9;
        const BACKWARD_Y_ONLY = SECOND_ONLY << 9;
    }
}

#[derive(Clone, Serialize, Deserialize)]
pub struct OscillationData {
    flag: OscilationFlag,
    prev_state: Option<RobotState>,
    osc_reset_dist2: f32,
    osc_reset_angle: f32,
}

impl OscillationData {
    pub fn from_config(config: &MetricsParams) -> Self {
        Self {
            flag: OscilationFlag::empty(),
            prev_state: None,
            osc_reset_dist2: config.oscillation_reset_dist.powi(2),
            osc_reset_angle: config.oscillation_reset_angle,
        }
    }

    pub fn reset(&mut self) {
        self.prev_state = None;
        self.flag = OscilationFlag::empty();
    }

    pub fn update(
        &mut self,
        state: &RobotState,
        best_traj: &Trajectory,
        config: &PlannerSimulationConfig,
    ) {
        update_osc_flag(&mut self.flag, best_traj, config);

        if self.flag.contains(OscilationFlag::UPDATED) {
            self.prev_state = Some(*state);
            self.flag.remove(OscilationFlag::UPDATED);
            return;
        }

        //state is saved only when strict flag is set
        if let Some(prev_state) = self.prev_state {
            let prev_pos = prev_state.position;
            let current_pos = state.position;

            let angle = (current_pos.heading_rad - prev_pos.heading_rad).abs();
            let dist2 = {
                let v1 = Vector2::new(prev_pos.coords.x, prev_pos.coords.y);
                let v2 =
                    Vector2::new(current_pos.coords.x, current_pos.coords.y);
                (v2 - v1).norm_squared()
            };

            //if we've moved far enough... we can reset flags
            if dist2 >= self.osc_reset_dist2 || angle >= self.osc_reset_angle {
                self.prev_state = None;
                self.flag = OscilationFlag::empty();
            }
        }
    }
}

#[rustfmt::skip]
pub fn metric<'a>(
    data: &'a OscillationData,
    _config: &'a PlannerSimulationConfig
    ) -> TrajectoryMetric<'a> {
    let flag = data.flag;

    Box::new(
        move |trajectory: &Trajectory| {
            let v = VelocityPose2D {
                translation: trajectory.target_velocity,
                angular: trajectory.target_angular
            };


            log::trace!("Current osc_flag: {:?}. Velocity = {:?}", flag, v);

            let mut can_skip = true;
            #[allow(clippy::if_same_then_else)]
            if flag.contains(OscilationFlag::FORWARD_X_ONLY) && trajectory.target_velocity.x < 0.0 {
                can_skip = false;
            } else if flag.contains(OscilationFlag::BACKWARD_X_ONLY) && trajectory.target_velocity.x > 0.0 {
                can_skip = false;
            } else if flag.contains(OscilationFlag::FORWARD_Y_ONLY) && trajectory.target_velocity.y < 0.0 {
                can_skip = false;
            } else if flag.contains(OscilationFlag::BACKWARD_Y_ONLY) && trajectory.target_velocity.y > 0.0 {
                can_skip = false;
            } else if flag.contains(OscilationFlag::POS_ROTATION_ONLY) && trajectory.target_angular < 0.0 {
                can_skip = false;
            } else if flag.contains(OscilationFlag::NEG_ROTATION_ONLY) && trajectory.target_angular > 0.0 {
                can_skip = false;
            }

            if can_skip {
                Ok((MetricKind::Oscilation, MetricCost::ZERO))
            } else {
                log::debug!("Osc is triggered");
                Err(MetricError::Unreacheable)
            }
        },
    )
}

/// the main idea of this method is to control the best_trajectory
/// if any *_ONLY flag is chosen, then corresponding trajectory must be chosen
fn update_osc_flag(
    prev_flag: &mut OscilationFlag,
    best_traj: &Trajectory,
    _config: &PlannerSimulationConfig,
) {
    let mut flag = *prev_flag;

    if best_traj.target_velocity.x < 0.0 {
        // if l_v < 0.0 && r_v < 0.0 {
        if flag.contains(OscilationFlag::FORWARD_X) {
            flag.remove(OscilationFlag::FORWARD_X);
            flag |= OscilationFlag::BACKWARD_X_ONLY | OscilationFlag::UPDATED;
        } else {
            flag |= OscilationFlag::BACKWARD_X;
        }
    }

    if best_traj.target_velocity.x > 0.0 {
        // if l_v > 0.0 && r_v > 0.0 {
        if flag.contains(OscilationFlag::BACKWARD_X) {
            flag.remove(OscilationFlag::BACKWARD_X);
            flag |= OscilationFlag::FORWARD_X_ONLY | OscilationFlag::UPDATED;
        } else {
            flag |= OscilationFlag::FORWARD_X;
        }
    }

    *prev_flag = flag;
}

#[cfg(test)]
mod tests {
    use super::OscilationFlag;

    #[test]
    fn test_osc_flag() {
        let mut flag = OscilationFlag::empty();
        flag |= OscilationFlag::POS_ROTATION_ONLY | OscilationFlag::UPDATED;
        assert!(flag.contains(OscilationFlag::UPDATED));
        flag.remove(OscilationFlag::UPDATED);
        assert!(flag.contains(OscilationFlag::POS_ROTATION));
        flag |= OscilationFlag::NEG_ROTATION_ONLY;
        flag.remove(OscilationFlag::POS_ROTATION);
        assert!(!flag.contains(OscilationFlag::POS_ROTATION));
        assert!(flag.contains(OscilationFlag::NEG_ROTATION));
        flag.remove(OscilationFlag::NEG_ROTATION);
        assert!(!flag.contains(OscilationFlag::NEG_ROTATION_ONLY));
        flag |= OscilationFlag::FORWARD_Y;
    }
}

==> ./planner/metrics/shared_data.rs <==
use crate::planner::distance_grid::DistanceGrid;
use crate::planner::PlannerSimulationConfig;
use crate::planner::Trajectory;

use super::oscillation::OscillationData;
use roboq_types::model::localization::RobotState;
use serde::{Deserialize, Serialize};

/// private data for metrics that should be storing externally
#[derive(Clone, Serialize, Deserialize)]
pub struct MetricsData {
    pub osc_data: OscillationData,
    #[serde(skip, default)]
    pub goal_grid: Option<DistanceGrid>,
    #[serde(skip, default)]
    pub path_grid: Option<DistanceGrid>,
    #[serde(skip, default)]
    pub collision_distance_grid: Option<DistanceGrid>,
}

impl MetricsData {
    pub fn from_config(config: &PlannerSimulationConfig) -> Self {
        Self {
            osc_data: OscillationData::from_config(&config.metrics),
            goal_grid: None,
            path_grid: None,
            collision_distance_grid: None,
        }
    }

    pub fn reset(&mut self) {
        self.osc_data.reset();
        self.goal_grid = None;
        self.path_grid = None;
        self.collision_distance_grid = None;
    }

    /// Update map causing invalidation of old DistanceGrid
    /// By this it must be recalculated in metrics
    pub fn on_update_map(&mut self) {
        self.goal_grid = None;
        self.path_grid = None;
        self.collision_distance_grid = None;
    }

    pub fn update(
        &mut self,
        state: &RobotState,
        best_traj: &Trajectory,
        config: &PlannerSimulationConfig,
    ) {
        self.osc_data.update(state, best_traj, config);
    }
}

==> ./planner/mod.rs <==
pub mod distance_grid;
pub mod dwa_local_planner;
pub mod global_planner;

mod collision;
mod dynamic_obstacles;
mod error;
mod estimation;
mod metrics;
mod simulation;
mod state;
// pub mod dwa_tandem_local_planner;

use std::time::Duration;

pub use dwa_local_planner::LocalPlanEvent;
pub use error::LocalPlanError;
pub use metrics::{MetricsBuilder, MetricsData};
use roboq_types::model::localization::RobotState;
use roboq_types::model::plan::{PlannerParams, StuckParams};
use roboq_types::model::pose::VelocityPose2D;
use roboq_types::model::Metres;
use roboq_types::model::{debug::DebugData, robot_params::RobotParams2D};

pub use metrics::{MetricCost, MetricError, MetricsParams, TrajectoryMetric};
use serde::{Deserialize, Serialize};

pub use dwa_local_planner::{
    estimate_local_plan, estimate_manual_plan, is_reached_by_dist,
};
pub use dynamic_obstacles::DynamicObstacles;
pub use estimation::{
    convert_to_motor_action, convert_to_velocity, PlanEstimation, PlannerEvent,
    PlannerSharedData,
};
pub use global_planner::{GlobalPlan, GlobalPlanner};
use smartcore::linalg::basic::matrix::DenseMatrix;
use smartcore::linear::linear_regression::{
    LinearRegression, LinearRegressionParameters,
};
pub use state::{FollowingData, FollowingState, WaypointsCache};

pub use roboq_types::model::plan::{Trajectory, TrajectoryMetadata};
pub use simulation::{SimulationRobot, SimulationWorld};
pub use state::{
    PathSharedData, PathState, RobotPath, RotationState, WorldPath,
};

use crate::debug::DebugSender;
use crate::{debug, model::big_map::BoxedMapChunk};

#[derive(Default, Debug, Clone, Serialize, Deserialize)]
pub struct DifferentialRobotConfig {
    pub wheel_distance: f32,
    pub wheel_radius: f32,

    //decreasing radius controls increase the velocity
    #[serde(default = "roboq_types::serde::const_f32::<1>")]
    pub radius_ratio: f32,
    //increasing ratio increase the impact of rotation
    #[serde(default = "roboq_types::serde::const_f32::<1>")]
    pub distance_ratio: f32,

    pub max_rotation_speed: f32,
    pub min_rotation_speed: f32,
}

#[derive(Default, Debug, Clone, Serialize, Deserialize, o2o::o2o)]
#[into(RobotParams2D)]
pub struct RobotConfig {
    pub width: Metres,
    pub length: Metres,
    /// the min (absolute) linear velocity
    pub min_velocity: f32,
    /// the max (absolute) linear velocity
    pub max_velocity: f32,
    /// the minimal angular available for robot
    /// used to restrict the rotation
    pub min_angular: f32,
    ///the maximal yaw on which robot can rotate per tick
    pub max_angular: f32,
    /// the maximal time to stop if we running
    /// with maximal velocity
    #[serde(
        serialize_with = "roboq_types::serde::serialize_millis",
        deserialize_with = "roboq_types::serde::deserialize_millis",
        default = "roboq_types::serde::duration_millis::<100>"
    )]
    pub break_time: Duration,

    #[serde(default = "roboq_types::serde::default_true")]
    pub align_to_heading: bool,

    #[ghost]
    pub differential: DifferentialRobotConfig,
}

impl RobotConfig {
    pub fn update(&mut self, params: RobotParams2D) {
        let RobotParams2D {
            width,
            length,
            min_velocity,
            max_velocity,
            min_angular,
            max_angular,
            break_time,
            align_to_heading,
        } = params;

        self.width = width;
        self.length = length;

        self.min_angular = min_angular;
        self.max_angular = max_angular;
        self.min_velocity = min_velocity;
        self.max_velocity = max_velocity;
        self.break_time = break_time;

        self.align_to_heading = align_to_heading;
    }
}

#[derive(Default, Debug, Clone, Serialize, Deserialize)]
pub struct LimitsConfig {
    ///used to calculate sampling_step
    pub velocity_sample_step: f32,
    pub angular_sample_step: f32,

    ///the squared distance tolerance to goal
    pub local_goal_tolerance_distance: f32,
    pub world_goal_tolerance_distance: f32,
    #[serde(default = "roboq_types::serde::santimetres::<10>")]
    pub trajectory_tolerance_distance: Metres,

    pub skip_local_alignment: bool,

    pub target_rotation_tolerance: f32,

    ///the maximal distance where
    ///robot will force rotated to target
    pub force_rotation_distance: f32,
    #[serde(
        serialize_with = "roboq_types::serde::serialize_millis",
        deserialize_with = "roboq_types::serde::deserialize_millis",
        default = "roboq_types::serde::duration_millis::<1000>"
    )]
    pub simulation_time: Duration,

    #[serde(
        serialize_with = "roboq_types::serde::serialize_millis",
        deserialize_with = "roboq_types::serde::deserialize_millis",
        default = "roboq_types::serde::duration_millis::<100>"
    )]
    pub simulation_tick: Duration,

    #[serde(
        serialize_with = "roboq_types::serde::serialize_millis",
        deserialize_with = "roboq_types::serde::deserialize_millis",
        default = "roboq_types::serde::duration_millis::<2000>"
    )]
    pub acceleration_time: Duration,

    #[serde(
        serialize_with = "roboq_types::serde::serialize_millis",
        deserialize_with = "roboq_types::serde::deserialize_millis",
        default = "roboq_types::serde::duration_millis::<1500>"
    )]
    pub deceleration_time: Duration,

    pub brake_aware_ratio: f32,

    #[serde(default, deserialize_with = "deserialize_optimization")]
    pub angular_optimization: MovementOptimization,
}

#[derive(Debug, serde::Serialize, serde::Deserialize)]
pub struct MovementOptimization {
    pub velocity: Vec<f32>,
    pub angular: Vec<f32>,

    #[serde(skip)]
    pub model: Option<LinearRegression<f32, f32, DenseMatrix<f32>, Vec<f32>>>,
}

impl Clone for MovementOptimization {
    fn clone(&self) -> Self {
        let mut other = Self {
            velocity: self.velocity.clone(),
            angular: self.angular.clone(),
            model: None,
        };

        other.fit();

        other
    }
}

impl Default for MovementOptimization {
    fn default() -> Self {
        let mut data = Self {
            velocity: vec![1.0, 2.0],
            angular: vec![1.0, 2.0],
            model: None,
        };

        data.fit();

        data
    }
}

impl MovementOptimization {
    pub fn estimate_angular(&self, velocity: f32) -> f32 {
        let model = self.model.as_ref().unwrap();

        model
            .predict(&DenseMatrix::from_2d_vec(&vec![vec![velocity]]).unwrap())
            .unwrap()[0]
    }

    pub fn fit(&mut self) {
        assert!(self.velocity.len() == self.angular.len());

        let x_matrix = DenseMatrix::from_2d_vec(
            &self.velocity.iter().map(|xi| vec![*xi]).collect(),
        )
        .unwrap();

        self.model = LinearRegression::fit(
            &x_matrix,
            &self.angular,
            LinearRegressionParameters::default(),
        )
        .expect("Failed to fit linear regression")
        .into();
    }
}

pub fn deserialize_optimization<'de, D>(
    deserializer: D,
) -> Result<MovementOptimization, D::Error>
where
    D: serde::de::Deserializer<'de>,
{
    use serde::Deserialize;

    let mut data = MovementOptimization::deserialize(deserializer)?;

    if data.velocity.len() != data.angular.len() {
        return Err(serde::de::Error::invalid_length(
            data.angular.len(),
            &"Angular and Velocities should be same size",
        ));
    }

    data.fit();

    Ok(data)
}

///the set of restrctions for simulation
#[derive(Clone, Debug, serde::Serialize, serde::Deserialize)]
pub struct PlannerSimulationConfig {
    /// common info about robot
    pub robot: RobotConfig,
    pub metrics: MetricsParams,
    pub limits: LimitsConfig,
    pub global: GlobalPlannerConfig,
    #[serde(default)]
    pub stuck: StuckParams,
    //the maximal distance between points in global path
    pub use_collisions: bool,
    pub collision_distance: Metres,
    #[serde(default = "default_ring_buffer_size")]
    pub ring_buffer_size: u32,
    pub idle_timeout_ms: u64,

    #[serde(default)]
    pub use_stuck_detection: bool,
    #[serde(default)]
    pub use_initial_rotation: bool,
    #[serde(default)]
    pub use_dynamic_collision_distance: bool,
    #[serde(default)]
    pub use_rotation_in_place: bool,
    #[serde(default = "roboq_types::serde::default_true")]
    pub use_motion_optimization: bool,
}

impl Default for PlannerSimulationConfig {
    fn default() -> Self {
        Self {
            robot: Default::default(),
            metrics: Default::default(),
            limits: Default::default(),
            global: Default::default(),
            stuck: Default::default(),

            collision_distance: 0.2.into(),
            ring_buffer_size: 1,
            idle_timeout_ms: 100,

            use_collisions: false,
            use_initial_rotation: false,
            use_stuck_detection: false,
            use_motion_optimization: false,
            use_rotation_in_place: false,
            use_dynamic_collision_distance: false,
        }
    }
}

impl PlannerSimulationConfig {
    pub fn update(&mut self, params: PlannerParams) {
        let PlannerParams {
            use_initial_rotation,
            skip_local_alignment,
            path_step,
            force_rotation_distance,
            local_goal_distance_tolerance,
            global_goal_distance_tolerance,
            use_dynamic_collision_distance,
            use_rotation_in_place,
            use_stuck_detection,
            use_motion_optimization,
            deceleration_time,
            acceleration_time,
            goal_rotation_tolerance,
            trajectory_distance_tolerance,
            path_step_tolerance,
        } = params;

        self.use_initial_rotation = use_initial_rotation;
        self.use_stuck_detection = use_stuck_detection;
        self.global.path_step = path_step;
        self.limits.force_rotation_distance = *force_rotation_distance;
        self.limits.local_goal_tolerance_distance =
            *local_goal_distance_tolerance;
        self.limits.world_goal_tolerance_distance =
            *global_goal_distance_tolerance;
        self.limits.skip_local_alignment = skip_local_alignment;
        self.use_dynamic_collision_distance = use_dynamic_collision_distance;
        self.use_rotation_in_place = use_rotation_in_place;
        self.use_motion_optimization = use_motion_optimization;

        self.global.path_step_tolerance = path_step_tolerance;

        self.limits.target_rotation_tolerance = goal_rotation_tolerance;
        self.limits.trajectory_tolerance_distance =
            trajectory_distance_tolerance;

        self.limits.acceleration_time = acceleration_time;
        self.limits.deceleration_time = deceleration_time;
    }
}

impl From<&PlannerSimulationConfig> for PlannerParams {
    fn from(value: &PlannerSimulationConfig) -> Self {
        PlannerParams {
            path_step_tolerance: value.global.path_step_tolerance,
            use_rotation_in_place: value.use_rotation_in_place,
            use_initial_rotation: value.use_initial_rotation,
            use_motion_optimization: value.use_motion_optimization,
            path_step: value.global.path_step,
            force_rotation_distance: value
                .limits
                .force_rotation_distance
                .into(),
            skip_local_alignment: value.limits.skip_local_alignment,
            use_stuck_detection: value.use_stuck_detection,
            deceleration_time: value.limits.deceleration_time,
            acceleration_time: value.limits.acceleration_time,
            goal_rotation_tolerance: value.limits.target_rotation_tolerance,

            local_goal_distance_tolerance: value
                .limits
                .local_goal_tolerance_distance
                .into(),
            global_goal_distance_tolerance: value
                .limits
                .world_goal_tolerance_distance
                .into(),
            trajectory_distance_tolerance: value
                .limits
                .trajectory_tolerance_distance,

            use_dynamic_collision_distance: value
                .use_dynamic_collision_distance,
        }
    }
}

#[derive(Clone, Debug, serde::Serialize, serde::Deserialize)]
pub struct GlobalPlannerConfig {
    /// the ratio using to check
    #[serde(deserialize_with = "deserialize_check_tolerance")]
    pub collision_check_scale: f32,
    pub path_step: Metres,
    #[serde(default = "roboq_types::serde::santimetres::<100>")]
    pub path_step_tolerance: Metres,
    /// ignoring distance to add new waypoint by giving
    /// coordinates
    pub cache_distance_tolerance: Metres,
}

impl Default for GlobalPlannerConfig {
    fn default() -> Self {
        Self {
            collision_check_scale: 0.3,
            path_step_tolerance: 0.4.into(),
            path_step: 1.0.into(),
            cache_distance_tolerance: 0.05.into(),
        }
    }
}

fn default_ring_buffer_size() -> u32 {
    5
}

pub fn deserialize_check_tolerance<'de, D>(
    deserializer: D,
) -> Result<f32, D::Error>
where
    D: serde::de::Deserializer<'de>,
{
    use serde::de::Error;

    let v = f32::deserialize(deserializer)?;

    if (0.2..1.5).contains(&v) {
        Ok(v)
    } else {
        Err(D::Error::custom("Invalid value for [0.2; 1.5]"))
    }
}

pub struct PlanConfig<'a> {
    pub world: SimulationWorld<'a>,
    pub rules: PlannerSimulationConfig,
    pub metrics_data: &'a mut MetricsData,
    pub debug_tx: Option<debug::Sender<DebugData>>,
}

pub struct ManualPlanConfig<'a> {
    pub target_twist: VelocityPose2D,
    pub robot: SimulationRobot,
    pub map_chunk: BoxedMapChunk,
    pub obstacles: &'a Option<DynamicObstacles>,
    pub rules: &'a PlannerSimulationConfig,
    pub debug_tx: Option<DebugSender>,
}

pub fn estimate_break_distance(
    state: &RobotState,
    config: &RobotConfig,
) -> Metres {
    let v_forward = state
        .velocity
        .into_local(state.position.heading_rad)
        .translation
        .x;

    let break_time = config.break_time.as_secs_f32();

    (v_forward * break_time).into()
}

==> ./planner/simulation/mod.rs <==
mod robot;
mod world;

pub use robot::*;
pub use world::*;

==> ./planner/simulation/robot.rs <==
use roboq_types::model::{
    localization::RobotState,
    map::{MetresPerPixel, RobotShape},
    Metres,
};

use crate::planner::{estimate_break_distance, RobotConfig};

pub struct SimulationRobot {
    state: RobotState,
    config: RobotConfig,
    use_dynamic_collision_distance: bool,
}

impl SimulationRobot {
    pub fn from_config(state: RobotState, config: RobotConfig) -> Self {
        Self {
            state,
            config,
            use_dynamic_collision_distance: false,
        }
    }

    pub fn use_dynamic_collision_distance(
        &mut self,
        use_it: bool,
    ) -> &mut Self {
        self.use_dynamic_collision_distance = use_it;

        self
    }

    pub fn build(&mut self) -> Self {
        Self {
            config: self.config.clone(),
            state: self.state,
            use_dynamic_collision_distance: self.use_dynamic_collision_distance,
        }
    }

    pub fn build_shape(
        &self,
        resolution: MetresPerPixel,
        base_collision_dist: Metres,
        state: &RobotState,
    ) -> RobotShape {
        let collision_dist = if self.use_dynamic_collision_distance {
            estimate_break_distance(state, &self.config)
        } else {
            base_collision_dist
        };

        let width = *collision_dist + *self.config.width;
        let length = *collision_dist + *self.config.length;

        let mut shape =
            RobotShape::new(width.into(), length.into(), resolution);

        shape.translate_mut(&state.position);

        shape
    }

    pub fn state(&self) -> &RobotState {
        &self.state
    }
}

==> ./planner/simulation/world.rs <==
use nalgebra::{Point2, SimdComplexField};
use roboq_types::model::pose::Pose2D;

use crate::{
    model::big_map::BoxedMapChunk,
    planner::{state::PathTracker, DynamicObstacles},
};

use super::SimulationRobot;

///the common info about simulation
pub struct SimulationWorld<'a> {
    pub robot: SimulationRobot,
    pub map_chunk: BoxedMapChunk,
    ///the target point on grid map
    pub target_pose: Pose2D,
    /// If global path consists of single element
    /// then it world goal itself
    pub global_path: &'a [Pose2D],
    pub obstacles: Option<&'a DynamicObstacles>,
    pub tracker: &'a mut PathTracker,
}

impl SimulationWorld<'_> {
    pub fn distance_to_goal(&self) -> f32 {
        self.distance2_to_goal().simd_sqrt()
    }

    pub fn distance2_to_goal(&self) -> f32 {
        (self.target_pose.coords - self.robot.state().position.coords).norm()
    }

    pub fn global_path_points(&self) -> Vec<Point2<f32>> {
        self.global_path.iter().map(|pose| pose.coords).collect()
    }
}

==> ./planner/state/global_cache.rs <==
use std::usize;

use nalgebra::{Point2, Vector2};
use roboq_types::model::{
    waypoint::{Waypoint, WaypointId},
    Metres,
};

use crate::{
    model::kd_tree::{points_to_data_kdtree, TKdTree, TPoint2KdTrait},
    planner::GlobalPlannerConfig,
};

impl TPoint2KdTrait for Waypoint {
    type Item = WaypointId;

    fn coords(&self) -> Point2<f32> {
        self.coords
    }

    fn value(&self) -> WaypointId {
        self.id
    }
}

/// Cache holding ground truth points suitable
/// for global planner
#[derive(Default, serde::Deserialize, serde::Serialize)]
pub struct WaypointsCache {
    points: Vec<Waypoint>,
    #[serde(skip)]
    tree: Option<TKdTree<WaypointId>>,
    /// squared distance tolerance to closest waypoint
    #[serde(skip, default = "default_ignore_dist2")]
    pub ignore_dist2: f32,
}

fn default_ignore_dist2() -> f32 {
    0.3
}

impl WaypointsCache {
    pub fn insert(
        &mut self,
        coords: Point2<f32>,
        heading: Option<f32>,
    ) -> Waypoint {
        if let Some(ref tree) = self.tree {
            let closest = tree.nearest_search(&coords.into());
            let p = closest.coords() - Vector2::new(coords.x, coords.y);
            let dist2 = Vector2::new(p.x, p.y).norm_squared();

            if dist2 < self.ignore_dist2 {
                // the point is already added to global cache
                // but we must to update target heading
                let index = closest.value() as usize;

                let point = &mut self.points[index];
                point.heading = heading;

                return point.clone();
            }
        }

        let id = self.points.len() as WaypointId;

        let waypoint = Waypoint {
            id,
            coords,
            heading,
        };

        self.points.push(waypoint.clone());
        self.tree = Some(points_to_data_kdtree(&self.points));

        waypoint
    }
    /// Remove all ground truth points
    pub fn reset(&mut self) {
        self.points.clear();
        self.tree = None;
    }

    pub fn find_by_id(&self, id: WaypointId) -> Option<Waypoint> {
        self.points.get(id as usize).cloned()
    }

    pub fn to_vec(&self) -> Vec<Waypoint> {
        self.points.clone()
    }

    /// Return None only if no points exist in cache at all
    pub fn find_closest(&self, coords: &Point2<f32>) -> Option<Waypoint> {
        let tree = self.tree.as_ref()?;

        let closest = tree.nearest_search(&coords.into());

        let index = closest.value() as usize;

        Some(self.points[index].clone())
    }

    pub fn find_closest_in_range(
        &self,
        coords: &Point2<f32>,
        radius: Metres,
    ) -> Option<Waypoint> {
        let waypoint = self.find_closest(coords)?;

        let dist2 = (*coords - waypoint.coords).norm_squared();

        if dist2 <= (*radius).powi(2) {
            Some(waypoint)
        } else {
            None
        }
    }

    pub fn rebuild(&mut self, config: &GlobalPlannerConfig) {
        self.ignore_dist2 = (*config.cache_distance_tolerance).powi(2);
        self.tree = None;

        if !self.points.is_empty() {
            self.tree = Some(points_to_data_kdtree(&self.points));
        }
    }
}

==> ./planner/state/mod.rs <==
mod global_cache;
mod path;
mod rotation;
mod world_path;

use crate::model::motor_action::MotorAction;

use roboq_types::from_variant;
use serde::{Deserialize, Serialize};

pub use global_cache::WaypointsCache;
pub use path::{PathSharedData, PathState, PathTracker, RobotPath};
pub use rotation::RotationState;
pub use world_path::WorldPath;

use super::PlannerSimulationConfig;

#[derive(Serialize, Deserialize)]
pub struct FollowingData {
    /// provided by external client obligatory points in global path
    pub waypoints: WaypointsCache,
    #[serde(skip)]
    pub state: FollowingState,
}

impl FollowingData {
    pub fn new(config: &PlannerSimulationConfig) -> Self {
        let mut waypoints = WaypointsCache::default();
        waypoints.rebuild(&config.global);

        Self {
            waypoints,
            state: FollowingState::NotInit,
        }
    }

    pub fn update_with_config(&mut self, config: &PlannerSimulationConfig) {
        self.waypoints.rebuild(&config.global);
    }
}

pub enum FollowingState {
    NotInit,
    WorldPath(WorldPath),
    Path(RobotPath),
    Manual(MotorAction),
    Rotation(RotationState),
}

impl Default for FollowingState {
    fn default() -> Self {
        Self::NotInit
    }
}

impl FollowingState {
    pub fn reset(&mut self) {
        *self = FollowingState::NotInit;
    }

    /// check that current following state is active
    pub fn is_active(&self) -> bool {
        !matches!(self, FollowingState::NotInit)
    }

    pub fn planner_path(&self) -> Option<&RobotPath> {
        match self {
            FollowingState::Path(path) => Some(path),
            _ => None,
        }
    }

    pub fn planner_path_mut(&mut self) -> Option<&mut RobotPath> {
        match self {
            FollowingState::Path(path) => Some(path),
            _ => None,
        }
    }

    pub fn manual_action(&self) -> Option<MotorAction> {
        match self {
            FollowingState::Manual(action) => Some(*action),
            _ => None,
        }
    }

    pub fn rotation_mut(&mut self) -> Option<&mut RotationState> {
        match self {
            FollowingState::Rotation(state) => Some(state),
            _ => None,
        }
    }

    pub fn world_path_mut(&mut self) -> Option<&mut WorldPath> {
        match self {
            FollowingState::WorldPath(path) => Some(path),
            _ => None,
        }
    }
}

impl From<RobotPath> for FollowingState {
    fn from(value: RobotPath) -> Self {
        Self::Path(value)
    }
}

impl From<MotorAction> for FollowingState {
    fn from(value: MotorAction) -> Self {
        Self::Manual(value)
    }
}

impl From<f32> for FollowingState {
    fn from(value: f32) -> Self {
        Self::Rotation(RotationState::new(value))
    }
}

from_variant!(FollowingState, WorldPath);

==> ./planner/state/path.rs <==
use std::time::{Duration, Instant};

use roboq_types::model::{
    localization::RobotState,
    pose::{Pose2D, VelocityPose2D},
    waypoint::{Waypoint, WaypointId},
};

use crate::planner::{metrics::MetricsData, PlannerSimulationConfig};

pub enum PathState {
    GlobalPathEstimation,
    /// The state when robot rotates
    /// towards the first point
    Rotation {
        goals: Vec<Pose2D>,
        heading: Option<f32>,
        last_angular: Option<f32>,
    },
    Running(PathSharedData),
}

pub struct RobotPath {
    pub global_target_id: WaypointId,
    pub global_route: Vec<Waypoint>,
    pub target_heading: Option<f32>,
    ///apply initial rotation only once
    pub skip_initial_rotation: bool,
    pub state: PathState,
}

impl RobotPath {
    pub fn empty(point: Waypoint) -> Self {
        Self {
            global_target_id: point.id,
            global_route: vec![point.clone()],
            skip_initial_rotation: false,
            state: PathState::GlobalPathEstimation,
            target_heading: point.heading,
        }
    }

    pub fn new_route(route: Vec<Waypoint>) -> Self {
        let target = route.last().cloned().expect("Route should be not empty");

        if route.len() == 1 {
            return Self::empty(target);
        }

        Self {
            global_target_id: target.id,
            global_route: route,
            skip_initial_rotation: false,
            state: PathState::GlobalPathEstimation,
            target_heading: target.heading,
        }
    }

    pub fn reset(&mut self) {
        self.state = PathState::GlobalPathEstimation;
        self.skip_initial_rotation = false;
    }

    pub fn on_update_map(&mut self) {
        match &mut self.state {
            PathState::Running(path_data) => {
                path_data.metrics.on_update_map();
            }

            PathState::Rotation { .. } => {}
            PathState::GlobalPathEstimation => {}
        }
    }

    pub fn init(
        &mut self,
        mut local_goals: Vec<Pose2D>,
        config: &PlannerSimulationConfig,
    ) {
        assert!(!local_goals.is_empty());

        if let Some(heading) = self.target_heading {
            local_goals.last_mut().expect("Not empty array").heading_rad =
                heading;
        }

        self.state = PathState::Rotation {
            goals: local_goals,
            last_angular: None,
            heading: None,
        };

        if self.skip_initial_rotation {
            self.start(config);
        }
    }

    pub fn rotate(&mut self) {
        match &self.state {
            PathState::GlobalPathEstimation => {
                panic!("No local goals is know to rotate");
            }

            PathState::Rotation { .. } => { //already rotated
            }

            PathState::Running(path_data) => {
                let goals = path_data.local_goals
                    [path_data.next_local_goal_id..]
                    .to_vec();

                self.state = PathState::Rotation {
                    goals,
                    last_angular: None,
                    heading: None,
                };
            }
        }
    }

    pub fn start(&mut self, config: &PlannerSimulationConfig) {
        if let PathState::Rotation { ref goals, .. } = self.state {
            assert!(!goals.is_empty());

            self.state = PathState::Running(PathSharedData {
                local_goals: goals.to_vec(),
                next_local_goal_id: 0,
                metrics: MetricsData::from_config(config),
                tracker: Default::default(),
            });

            self.skip_initial_rotation = true;
        }
    }
}

#[derive(Default)]
pub struct PathTracker {
    v: Option<VelocityPose2D>,
    estimated: Option<RobotState>,
    stuck_start: Option<Instant>,
    //aggregate how much is motion taken
    elapsed_in_motion: Duration,
}

impl PathTracker {
    pub fn track(
        &mut self,
        current: &RobotState,
        v: VelocityPose2D,
        dt: Duration,
    ) {
        self.estimated = (*current).into();
        if v.translation.x.abs() < f32::EPSILON {
            self.elapsed_in_motion = Duration::default();
            self.v = None;
        } else {
            self.elapsed_in_motion += dt;
            self.v = v.into();
        }
    }

    pub fn last_state(&self) -> Option<RobotState> {
        self.estimated
    }

    pub fn last_velocity(&self) -> Option<VelocityPose2D> {
        self.v
    }
    //return the current duration for stuck
    pub fn detect_stuck(&mut self) -> Duration {
        if let Some(start) = self.stuck_start.as_ref() {
            return start.elapsed();
        }

        let start = Instant::now();

        self.stuck_start = start.into();

        start.elapsed()
    }

    pub fn elapsed_in_motion(&self) -> Duration {
        self.elapsed_in_motion
    }

    pub fn reset_stuck(&mut self) {
        self.stuck_start = None;
    }
}

pub struct PathSharedData {
    /// goals for local planner
    pub local_goals: Vec<Pose2D>,
    pub next_local_goal_id: usize,
    pub metrics: MetricsData,
    pub tracker: PathTracker,
}

impl PathSharedData {
    /// the path of points to visit
    /// visited points are skipped
    pub fn global_path(&self) -> Vec<Pose2D> {
        assert!(self.next_local_goal_id < self.local_goals.len());

        self.local_goals[self.next_local_goal_id..].to_vec()
    }

    /// return true if local goal is changed
    /// return false otherwise
    pub fn move_local_goal(&mut self) -> bool {
        assert!(!self.local_goals.is_empty());

        self.metrics.reset();

        let Some(_) = self.local_goals.get(self.next_local_goal_id + 1) else {
            return false;
        };

        self.next_local_goal_id += 1;
        true
    }

    pub fn next_goal(&self) -> Pose2D {
        self.local_goals[self.next_local_goal_id]
    }
}

==> ./planner/state/rotation.rs <==
use std::time::SystemTime;

pub enum RotationState {
    /// trying to rotate to given angle
    /// without assumption that rotation estimation
    /// can be invalid
    Direct {
        heading: f32,
        last_angular: Option<f32>,
    },
    /// Delayed rotation
    /// time of delay =  SystemTime::now() and Direct end + max_device_update_time
    Delayed(SystemTime, f32),
}

impl RotationState {
    pub fn new(heading: f32) -> Self {
        Self::Direct {
            heading,
            last_angular: None,
        }
    }

    pub fn angle(&self) -> f32 {
        match self {
            RotationState::Direct { heading, .. } => *heading,
            RotationState::Delayed(_, angle) => *angle,
        }
    }
}

==> ./planner/state/world_path.rs <==
#![allow(unused)]
use std::time::Duration;

use nalgebra::Point2;

pub struct Params {
    pub base_velocity: f32,
    pub base_timeout: Duration,

    //angle to target optimized by some method
    estimated_angle: f32,
}

pub struct WorldPath {
    p: Vec<Point2<f32>>,
    pub params: Option<Params>,
}

impl WorldPath {
    pub fn with_target(_target: Point2<f64>, _current: Point2<f64>) -> Self {
        Self {
            p: vec![],
            params: None,
        }
    }

    pub fn path_points(&self) -> &[Point2<f32>] {
        &self.p
    }
}

==> ./shared_data/mod.rs <==
#[cfg(feature = "rt")]
mod runtime_data;
#[cfg(feature = "rt")]
mod sync_state;

pub use roboq_types::model::debug::{DebugData, DebugDataKind};

#[cfg(feature = "rt")]
pub use runtime_data::{RuntimeData, SharedData};


==> ./shared_data/runtime_data.rs <==
use std::{
    fs::File,
    io::{BufReader, BufWriter},
    ops::DerefMut,
    path::Path,
    sync::{atomic::AtomicBool, Arc, RwLock},
};

use nalgebra::Point2;
use roboq_types::model::{
    debug::DebugData,
    localization::RobotState,
    map::{MapFile, MetresPerPixel},
    pose::Pose2D,
    robot_params::MapObstacles,
    Metres,
};
use serde::{Deserialize, Serialize};

use crate::{
    config::NavigationConfig,
    correlative_scan_matching::scan_matcher::ScanMatcher,
    debug,
    devices::imu::ImuSharedData,
    localization::MotionEstimation,
    model::{
        big_map::{BigMap, Map, MapChunk},
        scan_ring_buffer::ScanRingBuffer,
    },
    pipeline::RunningConfig,
    planner::{DynamicObstacles, FollowingData, PlannerSharedData},
};

#[cfg(feature = "gps")]
use crate::localization::WorldTransform;

use super::sync_state::{SyncError, SyncState};

pub type RuntimeData = Arc<SharedData>;

#[derive(Serialize, Deserialize)]
pub struct SharedData {
    pub big_map: Arc<RwLock<BigMap>>,

    #[cfg(feature = "localization")]
    pub motion_estimation: RwLock<MotionEstimation>,
    pub correlative_scan_matching: RwLock<ScanMatcher>,

    pub plan: RwLock<FollowingData>,

    #[serde(skip)]
    pub reset_map_in_plan: AtomicBool,

    //holds latests matched scan
    pub scan_history: RwLock<ScanRingBuffer>,

    /// map obstacles on specific place
    #[serde(skip, default)]
    pub map_obstacles: Arc<RwLock<Vec<MapObstacles>>>,
    /// used in scan matching to estimate robot movement
    #[serde(skip)]
    pub last_added_pose: RwLock<Option<Pose2D>>,

    #[cfg(feature = "gps")]
    pub world_transform: RwLock<Option<WorldTransform>>,

    #[serde(skip)]
    sync_state: SyncState,

    #[serde(skip)]
    pub imu_history: RwLock<ImuSharedData>,
    //tricky way to detect collision
    #[serde(skip)]
    stereo_collision: AtomicBool,
    #[serde(skip)]
    use_stereo: AtomicBool,

    config: RunningConfig,
}

#[derive(Debug, thiserror::Error)]
pub enum LoadError {
    #[error("Encoding error: {0}")]
    EncodingError(#[from] bincode::Error),

    #[error("Runtime Update Failed: {0}")]
    FailedUpdate(#[from] std::io::Error),
}

impl SharedData {
    #[cfg(feature = "fs")]
    pub fn to_file<PATH: AsRef<Path>>(
        &self,
        path: PATH,
    ) -> std::io::Result<()> {
        use std::io::Write;

        let file = File::create(path.as_ref())?;
        let writer = BufWriter::new(file);
        bincode::serialize_into(writer, self)
            // rmp_serde::encode::write(&mut writer, self)
            .expect("Failed serialize shared data");

        let mut config_file = File::create(&self.config.file_name)?;
        let raw_config =
            toml::to_string_pretty(&self.config().blocking_read().clone())
                .expect("Failed to serialize to config file");
        config_file.write_all(raw_config.as_bytes())?;

        Ok(())
    }

    #[cfg(feature = "fs")]
    pub fn save_map<PATH: AsRef<Path>>(
        &self,
        path: PATH,
    ) -> std::io::Result<()> {
        use std::collections::HashMap;

        use roboq_types::model::map::MapCellData;

        use crate::model::big_map::Map;

        let state = self
            .motion_estimation
            .read()
            .unwrap()
            .get_estimated_state_unchecked();

        let (cells, points) = {
            let map = self.big_map.read().unwrap();
            (map.iter_cell(), map.get_points())
        };
        let grid = cells
            .into_iter()
            .map(|(coords, lock)| {
                let data = lock.read().unwrap().as_data_cell();

                (coords, data)
            })
            .collect::<HashMap<Point2<i32>, MapCellData>>();

        let file_map = MapFile {
            grid,
            points,
            start_pose: Some(state.position),
        };

        let file = File::create(path.as_ref())?;
        let writer = BufWriter::new(file);
        bincode::serialize_into(writer, &file_map)
            // rmp_serde::encode::write(&mut writer, self)
            .expect("Failed serialize shared data");

        Ok(())
    }

    #[cfg(feature = "fs")]
    pub async fn from_file(path: &Path) -> Result<Self, LoadError> {
        let path = path.to_owned();

        tokio::task::spawn_blocking(move || {
            let file = File::open(path).unwrap();
            let reader = BufReader::new(file);

            let mut shared_data: Self = bincode::deserialize_from(reader)?;

            shared_data.update_from_config_file()?;

            Ok(shared_data)
        })
        .await
        .expect("Failed to spawn thread")
    }

    #[cfg(feature = "fs")]
    pub async fn update_map_from_file(&self, path: &Path) {
        let path = path.to_owned();

        let map_file = tokio::task::spawn_blocking(move || {
            let file = File::open(path).unwrap();
            let reader = BufReader::new(file);
            bincode::deserialize_from(reader).unwrap()
        })
        .await
        .unwrap();

        let MapFile {
            start_pose,
            grid,
            points,
        } = map_file;

        if let Some(start_pose) = start_pose {
            //there is no needs to additionaly enable synchronization
            //as this method is supposed to be called
            //on init stage to build shared data instance
            self.motion_estimation
                .write()
                .unwrap()
                .reset_with_position(start_pose);
        }

        let mut map = self.big_map.write().unwrap();
        map.reset();

        for (coords, cell) in grid.into_iter() {
            map.update(coords, cell.into());
        }

        map.add_points(&points);
    }

    pub fn from_config(config_name: &str, config: NavigationConfig) -> Self {
        let big_map =
            BigMap::new(Metres(15.0), MetresPerPixel::new(Metres(15.0), 150));

        SharedData {
            big_map: RwLock::new(big_map).into(),
            last_added_pose: RwLock::new(None),
            motion_estimation: MotionEstimation::new(
                config.icp_slam_init_config.start_position,
                config.estimation_config.clone(),
            )
            .into(),

            correlative_scan_matching: ScanMatcher::new().into(),
            scan_history: ScanRingBuffer::new(
                config.planner_config.ring_buffer_size as usize,
            )
            .into(),
            plan: FollowingData::new(&config.planner_config).into(),
            sync_state: SyncState::default(),
            reset_map_in_plan: AtomicBool::new(true),
            config: RunningConfig::new(config_name, config),
            stereo_collision: AtomicBool::new(false),
            use_stereo: AtomicBool::new(false),
            map_obstacles: RwLock::new(Vec::new()).into(),

            #[cfg(feature = "gps")]
            world_transform: RwLock::new(None),
            #[cfg(feature = "imu")]
            imu_history: RwLock::new(Default::default()),
        }
    }

    pub fn config(&self) -> Arc<tokio::sync::RwLock<NavigationConfig>> {
        let lock = self
            .config
            .lock
            .as_ref()
            .expect("Config is not initialized");

        Arc::clone(lock)
    }

    /// read running config and update instances
    fn update_from_config_file(&mut self) -> std::io::Result<()> {
        let raw_config = std::fs::read_to_string(&self.config.file_name)?;
        let config: NavigationConfig =
            toml::from_str(&raw_config).expect("Failed to parse toml config");

        self.config.set(config);

        self.on_update_config_blocking();

        Ok(())
    }

    pub fn init_debug(&self, tx: debug::Sender<DebugData>) {
        self.motion_estimation.write().unwrap().debug_tx = Some(tx);
    }

    // Synchronize internal state according new values in config
    pub fn on_update_config_blocking(&self) {
        let config = self.config().blocking_read().clone();

        self.motion_estimation
            .write()
            .unwrap()
            .update_with_config(&config.estimation_config);

        self.plan
            .write()
            .unwrap()
            .update_with_config(&config.planner_config);

        //reset transform due it will be updated
        #[cfg(feature = "gps")]
        {
            *self.world_transform.write().unwrap() = None;
        }
    }

    pub fn on_update_map(&self) {
        self.reset_map_in_plan
            .store(true, std::sync::atomic::Ordering::Release);
    }

    /// Unconditionally enable sync state
    /// whereis state were previously enable or not
    pub fn enable_sync(&self) {
        if self.sync_state.set().is_ok() {
            //sync state is enabled
            log::trace!("Sync is enabled");
        }
        //sync state is previously enabled
    }

    /// Enabling sync state if it not was previously enabled
    pub fn try_enable_sync(&self) -> Result<(), SyncError> {
        if self.sync_state.set().is_err() {
            self.sync_state.reset();
            return Err(SyncError::Running);
        }

        Ok(())
    }

    pub fn disable_sync(&self) {
        if self.sync_state.is_running() {
            self.sync_state.reset();
        }

        log::debug!("Disabling sync state while it already disabled");
    }

    pub fn is_sync_state(&self) -> bool {
        self.sync_state.is_running()
    }

    pub fn set_stereo_collision(&self, enable: bool) {
        use std::sync::atomic::Ordering;

        let stereo_collision = if self.use_stereo.load(Ordering::SeqCst) {
            enable
        } else {
            false
        };

        self.stereo_collision
            .store(stereo_collision, Ordering::SeqCst);
    }

    pub fn has_stereo_collision(&self) -> bool {
        use std::sync::atomic::Ordering;

        self.stereo_collision.load(Ordering::SeqCst)
    }

    pub fn use_stereo_collision_detection(&self, use_it: bool) {
        use std::sync::atomic::Ordering;

        self.use_stereo.store(use_it, Ordering::SeqCst);

        if !use_it {
            self.stereo_collision.store(false, Ordering::SeqCst);
        }
    }
}

impl PlannerSharedData for SharedData {
    fn estimated_state(&self) -> Option<RobotState> {
        self.motion_estimation
            .write()
            .unwrap()
            .get_estimated_state()
            .inspect_err(|cause| {
                log::debug!("Poisoned state: {cause}");
            })
            .ok()
    }

    fn build_obstacles(&self) -> Option<DynamicObstacles> {
        let fixed_obstacles = {
            let obstacles = self
                .map_obstacles
                .read()
                .expect("Failed to read information of other robots");

            DynamicObstacles::generate_obstacle_points(obstacles.clone())
        };

        let scan_buffer = self.scan_history.read().unwrap();

        if scan_buffer.is_empty() {
            return None;
        }

        if fixed_obstacles.is_empty() {
            log::trace!("No fixed obstacles");
            return Some(DynamicObstacles::from_buffer(&scan_buffer));
        }

        Some(DynamicObstacles::with_other_robots(
            &scan_buffer,
            fixed_obstacles,
        ))
    }

    fn build_chunk(&self, center: Point2<f32>, radius: Metres) -> MapChunk {
        let mut map = self.big_map.write().unwrap();
        map.get_chunk_at(center, radius)
    }

    fn state_mut(&self) -> impl DerefMut<Target = FollowingData> {
        let mut lock = self.plan.write().unwrap();

        if self
            .reset_map_in_plan
            .load(std::sync::atomic::Ordering::Acquire)
        {
            self.reset_map_in_plan
                .store(false, std::sync::atomic::Ordering::Relaxed);

            if let Some(path) = lock.state.planner_path_mut() {
                path.on_update_map();
            }
        }

        lock
    }

    #[cfg(all(feature = "localization", feature = "gps"))]
    fn world_transform(
        &self,
    ) -> impl std::ops::Deref<Target = Option<WorldTransform>> {
        self.world_transform.read().unwrap()
    }
}

==> ./shared_data/sync_state.rs <==
use std::sync::atomic::{AtomicUsize, Ordering};

use thiserror::Error;
#[derive(Debug, Error)]
pub enum SyncError {
    #[error("Synchronization is running")]
    Running,
}

#[allow(unused)]
pub struct SyncState {
    sync_counts: AtomicUsize,
}

impl Default for SyncState {
    fn default() -> Self {
        Self::new()
    }
}

impl SyncState {
    pub fn new() -> Self {
        Self {
            sync_counts: AtomicUsize::new(0),
        }
    }

    pub fn set(&self) -> Result<(), SyncError> {
        let old_sync_count = self.sync_counts.fetch_add(1, Ordering::SeqCst);

        if old_sync_count == 0 {
            return Ok(());
        }

        Err(SyncError::Running)
    }

    pub fn reset(&self) {
        let old_count = self.sync_counts.fetch_sub(1, Ordering::Release);
        assert!(old_count > 0, "Reset without setting stopped");
    }

    ///check that nav2 is not in sync state
    ///return Ok if sync state is released
    pub fn is_running(&self) -> bool {
        if self.sync_counts.load(Ordering::Acquire) > 0 {
            return true;
        }

        false
    }
}
